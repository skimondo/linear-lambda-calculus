%------------------------------------------------------%
% Basic properties of judgment
%------------------------------------------------------%

% 'Prune' LF context to remove dependencies:
% Obtain from [Î¨,x:obj âŠ¢ merge Î”â‚ Î”â‚‚ Î”[..]] that neither Î”â‚ nor Î”â‚‚ depend on x
% and from [Î¨,x:obj âŠ¢ merge Î”â‚[..] Î”â‚‚ Î”] that neither Î”â‚‚ nor Î” depend on x

inductive PruneMerge : (Î¨:vctx) {MG:[Î¨,x:obj âŠ¢ merge Î”â‚ Î”â‚‚ Î”[..]]} ctype =
  | Prune-Merge : [Î¨,x:obj âŠ¢ cx_eq Î”â‚ Î”â‚'[..]] â†’ [Î¨,x:obj âŠ¢ cx_eq Î”â‚‚ Î”â‚‚'[..]] â†’ [Î¨ âŠ¢ merge Î”â‚' Î”â‚‚' Î”]
    â†’ {MG:[Î¨,x:obj âŠ¢ merge Î”â‚ Î”â‚‚ Î”[..]]} PruneMerge [Î¨,x:obj âŠ¢ MG];

rec prune_merge : (Î¨:vctx) {MG:[Î¨,x:obj âŠ¢ merge Î”â‚ Î”â‚‚ Î”[..]]} PruneMerge [Î¨,x:obj âŠ¢ MG] =
  / total 1 /
  mlam MG â‡’ case [_,x:obj âŠ¢ MG] of
  | [_,x:obj âŠ¢ mg/n] â‡’ Prune-Merge [_ âŠ¢ cx/refl] [_ âŠ¢ cx/refl] [_ âŠ¢ mg/n] [_ âŠ¢ _]
  | [_,x:obj âŠ¢ mg/c MG1 MLT[]] â‡’
    let Prune-Merge [_,x:obj âŠ¢ cx/refl] [_ âŠ¢ cx/refl] [_ âŠ¢ MG1'] [_ âŠ¢ _] = prune_merge [_,x:obj âŠ¢ MG1] in
    Prune-Merge [_ âŠ¢ cx/refl] [_ âŠ¢ cx/refl] [_ âŠ¢ mg/c MG1' MLT[]] [_ âŠ¢ _]
  ;

inductive PruneMerge_l : (Î¨:vctx) {MG:[Î¨,x:obj âŠ¢ merge Î”â‚[..] Î”â‚‚ Î”]} ctype =
  | Prune-Merge-l : [Î¨,x:obj âŠ¢ cx_eq Î”â‚‚ Î”â‚‚'[..]] â†’ [Î¨,x:obj âŠ¢ cx_eq Î” Î”'[..]] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚' Î”']
    â†’ {MG:[Î¨,x:obj âŠ¢ merge Î”â‚[..] Î”â‚‚ Î”]} PruneMerge_l [Î¨,x:obj âŠ¢ MG];

rec prune_merge_l : (Î¨:vctx) {MG:[Î¨,x:obj âŠ¢ merge Î”â‚[..] Î”â‚‚ Î”]} PruneMerge_l [Î¨,x:obj âŠ¢ MG] =
  / total 1 /
  mlam MG â‡’ case [_,x:obj âŠ¢ MG] of
  | [_,x:obj âŠ¢ mg/n] â‡’ Prune-Merge-l [_ âŠ¢ cx/refl] [_ âŠ¢ cx/refl] [_ âŠ¢ mg/n] [_ âŠ¢ _]
  | [_,x:obj âŠ¢ mg/c MG1 MLT[]] â‡’
    let Prune-Merge-l [_ âŠ¢ cx/refl] [_ âŠ¢ cx/refl] [_ âŠ¢ MG2] [_ âŠ¢ _] = prune_merge_l [_,x:obj âŠ¢ MG1] in
    Prune-Merge-l [_ âŠ¢ cx/refl] [_ âŠ¢ cx/refl] [_ âŠ¢ mg/c MG2 MLT[]] [_ âŠ¢ _]
  ;

%------------------------------------------------------%
% Algebraic properties
%------------------------------------------------------%

% If Î”â‚ â‹ˆ Î”â‚‚ = Î” and Î”â‚ â‹ˆ Î”â‚‚ = Î”', then Î” = Î”'

rec merge_func : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”'] â†’ [Î¨ âŠ¢ cx_eq Î” Î”'] =
  / total 1 /
  fn mg1, mg2 â‡’ case mg1 of
  | [_ âŠ¢ mg/n] â‡’ let [_ âŠ¢ mg/n] = mg2 in [_ âŠ¢ cx/refl]
  | [_ âŠ¢ mg/c MG1 MLT1[]] â‡’
    let [_ âŠ¢ mg/c MG2 MLT2[]] = mg2 in
    let [_ âŠ¢ cx/refl] = merge_func [_ âŠ¢ MG1] [_ âŠ¢ MG2] in
    let [ âŠ¢ mult/refl] = mult_func [ âŠ¢ MLT1] [ âŠ¢ MLT2] in
    [_ âŠ¢ cx/refl]
  ;

% Î”â‚ â‹ˆ Î”â‚‚ = Î”â‚‚ â‹ˆ Î”â‚

rec merge_comm : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ merge Î”â‚‚ Î”â‚ Î”] =
  / total 1 /
  fn MG â‡’ case MG of
  | [_ âŠ¢ mg/n] â‡’ [_ âŠ¢ mg/n]
  | [_ âŠ¢ mg/c MG1 MLT1[]] â‡’
    let [_ âŠ¢ MG2] = merge_comm [_ âŠ¢ MG1] in
    let [ âŠ¢ MLT2] = mult_comm [ âŠ¢ MLT1] in
    [_ âŠ¢ mg/c MG2 MLT2[]]
  ;

% If exh(Î”â‚), then Î”â‚ â‹ˆ Î”â‚‚ = Î”â‚‚

rec merge_id : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ exh Î”â‚] â†’ [Î¨ âŠ¢ cx_eq Î”â‚‚ Î”] =
  / total 1 /
  fn MG, EXH â‡’ case MG of
  | [_ âŠ¢ mg/n] â‡’ [_ âŠ¢ cx/refl]
  | [_ âŠ¢ mg/c MG1 MLT[]] â‡’
    let [_ âŠ¢ exh/c EXH1] = EXH in
    let [_ âŠ¢ cx/refl] = merge_id [_ âŠ¢ MG1] [_ âŠ¢ EXH1] in
    let [ âŠ¢ mult/refl] = mult_id [ âŠ¢ MLT] in
    [_ âŠ¢ cx/refl]
  ;

rec merge_id_r : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ exh Î”â‚‚] â†’ [Î¨ âŠ¢ cx_eq Î”â‚ Î”] =
  / total 1 /
  fn MG, EXH â‡’ merge_id (merge_comm MG) EXH
  ;

%{ - - - - - - - - - - - - - - - - %
% If Î”â‚ â‹ˆ Î”â‚‚ = Î”â‚‚ then Î”â‚ is exhausted

rec merge_id_2 : (Î¨:vctx) [Î³ âŠ¢ merge Î” Î”' Î”'] â†’ [Î¨ âŠ¢ exh Î”] = ? ;
% - - - - - - - - - - - - - - - - }%

% Existence of identity context for any Î”; i.e., obtain the result of setting all linear names to `used`

LF mg_getid : lctx â†’ type = merge-getid : merge Î” Î”' Î” â†’ exh Î”' â†’ mg_getid Î”;

rec merge_getid : (Î¨:vctx) {Î”:[Î¨ âŠ¢ lctx]} [Î¨ âŠ¢ mg_getid Î”] =
  / total 1 /
  mlam Î” â‡’
  case [_ âŠ¢ Î”] of
  | [_ âŠ¢ nil] â‡’ [_ âŠ¢ merge-getid mg/n exh/n]
  | [_ âŠ¢ cons Î”' _ A[] Î±[]] â‡’ ?
    % let [_ âŠ¢ merge-getid MG EXH] = merge_getid [_ âŠ¢ Î”'] in
    % case [ âŠ¢ Î±] of
    % | [ âŠ¢ used] â‡’ [_ âŠ¢ merge-getid (mg/c MG â€¢/us) (exh/c EXH)]
    % | [ âŠ¢ lin] â‡’ [_ âŠ¢ merge-getid (mg/c MG â€¢/a1) (exh/c EXH)]
  ;

% (Î”â‚ â‹ˆ Î”â‚‚) â‹ˆ Î”â‚ƒ = Î”â‚ â‹ˆ (Î”â‚‚ â‹ˆ Î”â‚ƒ)

  LF mg_assoc : merge _ _ _ â†’ merge _ _ _ â†’ type = mg-assoc :
      merge Î”â‚‚ Î”â‚ƒ Î”â‚‚â‚ƒ â†’ merge Î”â‚ Î”â‚‚â‚ƒ Î”
   â†’ {MG1:merge Î”â‚â‚‚ Î”â‚ƒ Î”} {MG2:merge Î”â‚ Î”â‚‚ Î”â‚â‚‚} mg_assoc MG1 MG2;

rec merge_assoc : (Î¨:vctx) {MG1:[Î¨ âŠ¢ merge Î”â‚â‚‚ Î”â‚ƒ Î”]} {MG2:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”â‚â‚‚]} [Î¨ âŠ¢ mg_assoc MG1 MG2] =
  / total 1 /
  mlam MG1, MG2 â‡’
  case [_ âŠ¢ MG1] of
  | [_ âŠ¢ mg/n] â‡’ let [_ âŠ¢ mg/n] = [_ âŠ¢ MG2] in [_ âŠ¢ mg-assoc mg/n mg/n _ _]
  | [_ âŠ¢ mg/c MG1' MLT1[]] â‡’
    let [_ âŠ¢ mg/c MG2' MLT2[]] = [_ âŠ¢ MG2] in
    let [_ âŠ¢ mg-assoc MG3 MG4 _ _] = merge_assoc [_ âŠ¢ MG1'] [_ âŠ¢ MG2'] in
    let [ âŠ¢ â€¢/assoc MLT3 MLT4 _ _] = mult_assoc [ âŠ¢ MLT2] [ âŠ¢ MLT1] in
    [_ âŠ¢ mg-assoc (mg/c MG3 MLT3[]) (mg/c MG4 MLT4[]) _ _]
  ;

% If Î”â‚ â‹ˆ Î”â‚‚ = Î”â‚ â‹ˆ Î”â‚‚', then Î”â‚‚ = Î”â‚‚' [unused]

rec merge_cancl : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚' Î”] â†’ [Î¨ âŠ¢ cx_eq Î”â‚‚ Î”â‚‚'] =
  / total 1 /
  fn MG1, MG2 â‡’ case MG1 of
  | [_ âŠ¢ mg/n] â‡’ let [_ âŠ¢ mg/n] = MG2 in [_ âŠ¢ cx/refl]
  | [_ âŠ¢ mg/c MG1' MLT1[]] â‡’
    let [_ âŠ¢ mg/c MG2' MLT2[]] = MG2 in
    let [_ âŠ¢ cx/refl] = merge_cancl [_ âŠ¢ MG1'] [_ âŠ¢ MG2'] in
    let [ âŠ¢ mult/refl] = mult_canc [ âŠ¢ MLT1] [ âŠ¢ MLT2] in
    [_ âŠ¢ cx/refl]
  ;

%------------------------------------------------------%
% Context size
%------------------------------------------------------%

% Merged typing contexts are of the same size

%{ - - - - - - - - - - - - - - - - %
inductive sameLength : (Î¨:vctx)  {Î”â‚:[Î¨ âŠ¢ lctx]} {Î”â‚‚:[Î¨ âŠ¢ lctx]} {Î”:[Î¨ âŠ¢ lctx]} ctype =
  | EqLength : {n:[_ âŠ¢ nat]} [Î¨ âŠ¢ len Î”â‚ n[]]  â†’ [Î¨ âŠ¢ len Î”â‚‚ n[]] â†’ [Î¨ âŠ¢ len Î” n[]]
	       â†’ sameLength [Î¨ âŠ¢ Î”â‚] [Î¨ âŠ¢ Î”â‚‚] [Î¨ âŠ¢ Î”]
  ;

rec len_merge_eq :   (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ sameLength [Î¨ âŠ¢ Î”â‚] [Î¨ âŠ¢ Î”â‚‚] [Î¨ âŠ¢ Î”] =
 / total 1 /
  fn MG â‡’ case MG of
  | [_ âŠ¢ mg/n] â‡’ EqLength [ âŠ¢ zero] [_ âŠ¢ len/n] [_ âŠ¢ len/n][_ âŠ¢ len/n]
  | [_ âŠ¢ mg/c MG MLT[]] â‡’
    let EqLength [ âŠ¢ n] [_ âŠ¢ L1] [_ âŠ¢ L2] [_ âŠ¢ L] = len_merge_eq [_ âŠ¢ MG] in
    EqLength [ âŠ¢ suc n] [_ âŠ¢ len/c L1] [_ âŠ¢ len/c L2] [_ âŠ¢ len/c L]		     	    
  ;
% - - - - - - - - - - - - - - - - }%

rec len_merge1_l : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ len Î” n] â†’ [Î¨ âŠ¢ len Î”â‚ n] =
  / total 1 /
  fn MG, NN â‡’ case MG of
  | [_ âŠ¢ mg/n] â‡’ NN
  | [_ âŠ¢ mg/c MG1 MLT[]] â‡’
    let [_ âŠ¢ len/c NN1] = NN in
    let [_ âŠ¢ NN2] = len_merge1_l [_ âŠ¢ MG1] [_ âŠ¢ NN1] in
    [_ âŠ¢ len/c NN2]
  ;

rec len_merge1_r : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ len Î” n] â†’ [Î¨ âŠ¢ len Î”â‚‚ n] =
  / total /
  fn MG, NN â‡’ len_merge1_l (merge_comm MG) NN
  ;

rec len_merge2_l : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ len Î”â‚ n] â†’ [Î¨ âŠ¢ len Î” n] =
  / total 1 /
  fn MG, NN â‡’ case MG of
  | [_ âŠ¢ mg/n] â‡’ NN
  | [_ âŠ¢ mg/c MG1 MLT[]] â‡’
    let [_ âŠ¢ len/c NN1] = NN in
    let [_ âŠ¢ NN2] = len_merge2_l [_ âŠ¢ MG1] [_ âŠ¢ NN1] in
    [_ âŠ¢ len/c NN2]
  ;

rec len_merge2_r : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ len Î”â‚‚ n] â†’ [Î¨ âŠ¢ len Î” n] =
  / total /
  fn MG, NN â‡’ len_merge2_l (merge_comm MG) NN
  ;

%------------------------------------------------------%
% Interaction with context manipulation
%------------------------------------------------------%

% Î”â‚ â‹ˆ Î”â‚‚ = Î” iff Î”â‚â§µ{(X:A)^Î±â‚} â‹ˆ Î”â‚‚â§µ{(X:A)^Î±â‚‚} = Î”â§µ{(X:A)^(Î±â‚â€¢Î±â‚‚)}
% (Can also be viewed as lookup properties:
  % - (X:A)^Î± âˆˆâ‚™ (Î”â‚ â‹ˆ Î”â‚‚), then (X:A)^Î±â‚ âˆˆâ‚™ Î”â‚ and (X:A)^Î±â‚‚ âˆˆâ‚™ Î”â‚‚ for some Î±â‚âˆ™Î±â‚‚ = Î±
  % - If (X:A) âˆˆâ‚™ Î”â‚, then (X:A)^Î±â‚‚ âˆˆâ‚™ Î”â‚‚ and (X:A)^Î± âˆˆâ‚™ (Î”â‚ â‹ˆ Î”â‚‚) for some Î±â‚âˆ™Î±â‚‚ = Î±

LF mg_str : rmv Î” _ _ _ _ _ â†’ merge _ _ Î” â†’ type =
  mg-str : rmv Î”â‚ X A Î±â‚ n Î”â‚'
	  â†’ rmv Î”â‚‚ X A Î±â‚‚ n Î”â‚‚'
	  â†’ â€¢ Î±â‚ Î±â‚‚ Î±
	  â†’ merge Î”â‚' Î”â‚‚' Î”'
	  â†’ {RMV:rmv Î” X A Î± n Î”'} {MG:merge Î”â‚ Î”â‚‚ Î”} mg_str RMV MG;

rec merge_str : (Î¨:vctx) {RMV:[Î¨ âŠ¢ rmv Î” X A Î± n Î”']} {MG:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]} [_ âŠ¢ mg_str RMV MG] =
  / total 1 /
  mlam RMV, MG â‡’ case [_ âŠ¢ RMV] of
  | [_ âŠ¢ rmv/t LN] â‡’
    let [_ âŠ¢ mg/c MG1 MLT] = [_ âŠ¢ MG] in
    let [_ âŠ¢ LN1] = len_merge1_l [_ âŠ¢ MG1] [_ âŠ¢ LN] in
    let [_ âŠ¢ LN2] = len_merge1_r [_ âŠ¢ MG1] [_ âŠ¢ LN] in
    [_ âŠ¢ mg-str (rmv/t LN1) (rmv/t LN2) MLT MG1 _ _]

  | [_ âŠ¢ rmv/n RMV1] â‡’
    let [_ âŠ¢ mg/c MG1 MLT1] = [_ âŠ¢ MG] in
    let [_ âŠ¢ mg-str RMV2 RMV3 MLT2 MG2 _ _] = merge_str [_ âŠ¢ RMV1] [_ âŠ¢ MG1] in
    [_ âŠ¢ mg-str (rmv/n RMV2) (rmv/n RMV3) MLT2 (mg/c MG2 MLT1) _ _]
  ;

LF mg_str2 : rmv Î”â‚ _ _ _ _ _ â†’ merge Î”â‚ _ _ â†’ type =
  mg-str2 : rmv Î”â‚‚ X A Î±â‚‚ n Î”â‚‚' â†’ rmv Î” X A Î± n Î”' â†’ â€¢ Î±â‚ Î±â‚‚ Î± â†’ merge Î”â‚' Î”â‚‚' Î”' â†’ {RMV:rmv Î”â‚ X A Î±â‚ n Î”â‚'} {MG:merge Î”â‚ Î”â‚‚ Î”} mg_str2 RMV MG;

rec merge_str2 : (Î¨:vctx) {RMV:[Î¨ âŠ¢ rmv Î”â‚ X A Î±â‚ n Î”â‚']} {MG:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]} [_ âŠ¢ mg_str2 RMV MG] =
  / total 1 /
  mlam RMV, MG â‡’ case [_ âŠ¢ RMV] of
  | [_ âŠ¢ rmv/t LN1] â‡’
    let [_ âŠ¢ mg/c MG1 MLT] = [_ âŠ¢ MG] in
    let [_ âŠ¢ LN2] = len_merge2_l [_ âŠ¢ MG1] [_ âŠ¢ LN1] in
    let [_ âŠ¢ LN3] = len_merge1_r [_ âŠ¢ MG1] [_ âŠ¢ LN2] in
    [_ âŠ¢ mg-str2 (rmv/t LN3) (rmv/t LN2) MLT MG1 _ _]
  | [_ âŠ¢ rmv/n RMV1] â‡’
    let [_ âŠ¢ mg/c MG1 MLT1] = [_ âŠ¢ MG] in
    let [_ âŠ¢ mg-str2 RMV2 RMV3 MLT2 MG2 _ _] = merge_str2 [_ âŠ¢ RMV1] [_ âŠ¢ MG1] in
    [_ âŠ¢ mg-str2 (rmv/n RMV2) (rmv/n RMV3) MLT2 (mg/c MG2 MLT1) _ _]
  ;

LF mg_weak : rmv _ _ _ Î± _ Î” â†’ merge _ _ Î” â†’ â€¢ _ _ Î± â†’ type =
  mg-weak : rmv Î”â‚' X A Î±â‚ n Î”â‚ â†’ rmv Î”â‚‚' X A Î±â‚‚ n Î”â‚‚ â†’ merge Î”â‚' Î”â‚‚' Î”' â†’ {RMV:rmv Î”' X A Î± n Î”} {MG:merge Î”â‚ Î”â‚‚ Î”} {MLT:â€¢ Î±â‚ Î±â‚‚ Î±} mg_weak RMV MG MLT;

rec merge_weak : (Î¨:vctx) {RMV:[Î¨ âŠ¢ rmv Î”' X A[] Î±[] n[] Î”]} {MG:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]} {MLT:[ âŠ¢ â€¢ Î±â‚ Î±â‚‚ Î±]} [Î¨ âŠ¢ mg_weak RMV MG MLT[]] =
  / total 2 /
  mlam RMV, MG, MLT â‡’ case [_ âŠ¢ RMV] of
  | [_ âŠ¢ rmv/t LN1] â‡’
    let [_ âŠ¢ LN2] = len_merge1_l [_ âŠ¢ MG] [_ âŠ¢ LN1] in
    let [_ âŠ¢ LN3] = len_merge1_r [_ âŠ¢ MG] [_ âŠ¢ LN1] in
    [_ âŠ¢ mg-weak (rmv/t LN2) (rmv/t LN3) (mg/c MG MLT[]) _ _ _]
  | [_ âŠ¢ rmv/n RMV1] â‡’
    let [_ âŠ¢ mg/c MG1 MLT1] = [_ âŠ¢ MG] in
    let [_ âŠ¢ mg-weak RMV2 RMV3 MG2 _ _ _] = merge_weak [_ âŠ¢ RMV1] [_ âŠ¢ MG1] [ âŠ¢ MLT] in
    [_ âŠ¢ mg-weak (rmv/n RMV2) (rmv/n RMV3) (mg/c MG2 MLT1) _ _ _]
  ;

LF mg_weak2 : rmv _ _ _ Î±â‚ _ Î”â‚ â†’ merge Î”â‚ _ _ â†’ â€¢ Î±â‚ _ _ â†’ type =
  mg-weak2 : rmv Î”â‚‚' X A Î±â‚‚ n Î”â‚‚ â†’ rmv Î”' X A Î± n Î” â†’ merge Î”â‚' Î”â‚‚' Î”' â†’ {RMV:rmv Î”â‚' X A Î±â‚ n Î”â‚} {MG:merge Î”â‚ Î”â‚‚ Î”} {MLT:â€¢ Î±â‚ Î±â‚‚ Î±} mg_weak2 RMV MG MLT;

rec merge_weak2 : (Î¨:vctx) {RMV:[Î¨ âŠ¢ rmv Î”â‚' X A[] Î±â‚[] n[] Î”â‚]} {MG:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]} {MLT:[ âŠ¢ â€¢ Î±â‚ Î±â‚‚ Î±]} [Î¨ âŠ¢ mg_weak2 RMV MG MLT[]] =
  / total 2 /
  mlam RMV, MG, MLT â‡’ case [_ âŠ¢ RMV] of
  | [_ âŠ¢ rmv/t LN1]:[_ âŠ¢ rmv _ _ _ Î±[] _ _] â‡’
    let [_ âŠ¢ LN2] = len_merge2_l [_ âŠ¢ MG] [_ âŠ¢ LN1] in
    let [_ âŠ¢ LN3] = len_merge1_r [_ âŠ¢ MG] [_ âŠ¢ LN2] in
    [_ âŠ¢ mg-weak2 (rmv/t LN3) (rmv/t LN2) (mg/c MG MLT[]) _ _ _]
  | [_ âŠ¢ rmv/n RMV1] â‡’
    let [_ âŠ¢ mg/c MG1 MLT1] = [_ âŠ¢ MG] in
    let [_ âŠ¢ mg-weak2 RMV2 RMV3 MG2 _ _ _] = merge_weak2 [_ âŠ¢ RMV1] [_ âŠ¢ MG1] [ âŠ¢ MLT] in
    [_ âŠ¢ mg-weak2 (rmv/n RMV2) (rmv/n RMV3) (mg/c MG2 MLT1) _ _ _]
  ;

%{ - - - - - - - - - - - - - - - - %
rec merge_str_nt : (Î¨:vctx) [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [Î¨ âŠ¢ rmv Î”â‚ X A Î± n Î”â‚'] â†’ [Î¨ âŠ¢ lookup_nti X A n Î”] =
  / total 1 /
  fn MG, RMV â‡’
  let ([_ âŠ¢ MG'],[_ âŠ¢ RMV']) = (MG,RMV) in
  let [_ âŠ¢ mg-str2 RMV2 RMV3 MLT _ _] = merge_str2 [_ âŠ¢ RMV'] [_ âŠ¢ MG'] in
  [_ âŠ¢ looknti RMV3]
  ;
% - - - - - - - - - - - - - - - - }%

% Interaction with exchange

LF mg_exch_exp : rmv _ _ _ _ _ _ â†’ rmv _ _ _ _ _ _ â†’ rmv _ _ _ _ _ _ â†’ rmv _ _ _ _ _ _ â†’ merge _ _ _ â†’ type =
  | mg-exch-exp :
    rmv Î”â‚ X A Î±â‚ n Î”â‚â‚™ â†’ rmv Î”â‚'' Y B Î²â‚ n' Î”â‚â‚™ â†’ rmv Î”â‚'' Y B Î²â‚ m Î”â‚â‚˜ â†’ rmv Î”â‚' X A Î±â‚ m' Î”â‚â‚˜
    â†’ rmv Î”â‚‚ X A Î±â‚‚ n Î”â‚‚â‚™ â†’ rmv Î”â‚‚'' Y B Î²â‚‚ n' Î”â‚‚â‚™ â†’ rmv Î”â‚‚'' Y B Î²â‚‚ m Î”â‚‚â‚˜ â†’ rmv Î”â‚‚' X A Î±â‚‚ m' Î”â‚‚â‚˜
    â†’ â€¢ Î±â‚ Î±â‚‚ Î± â†’ â€¢ Î²â‚ Î²â‚‚ Î² â†’ merge Î”â‚â‚™ Î”â‚‚â‚™ Î”â‚™ â†’ merge Î”â‚'' Î”â‚‚'' Î”'' â†’ merge Î”â‚â‚˜ Î”â‚‚â‚˜ Î”â‚˜ â†’ merge Î”â‚' Î”â‚‚' Î”'
    â†’ {RMV1:rmv Î” X A Î± n Î”â‚™} {RMV2:rmv Î”'' Y B Î² n' Î”â‚™}
    {RMV3:rmv Î”'' Y B Î² m Î”â‚˜} {RMV4:rmv Î”' X A Î± m' Î”â‚˜} {MG:merge Î”â‚ Î”â‚‚ Î”}
    mg_exch_exp RMV1 RMV2 RMV3 RMV4 MG
  ;

rec merge_exch_exp : (Î¨:vctx)
{RMV1:[Î¨ âŠ¢ rmv Î” X A[] Î±[] n[] Î”â‚™]} {RMV2:[Î¨ âŠ¢ rmv Î”'' Y B[] Î²[] n'[] Î”â‚™]}
{RMV3:[Î¨ âŠ¢ rmv Î”'' Y B[] Î²[] m[] Î”â‚˜]} {RMV4:[Î¨ âŠ¢ rmv Î”' X A[] Î±[] m'[] Î”â‚˜]}
{MG:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]}
[Î¨ âŠ¢ mg_exch_exp RMV1 RMV2 RMV3 RMV4 MG] =
  / total /
  mlam RMV1, RMV2, RMV3, RMV4, MG â‡’
  let [_ âŠ¢ mg-str RMV1a RMV1b MLTa[] MGm _ _] = merge_str [_ âŠ¢ RMV1] [_ âŠ¢ MG] in
  let [_ âŠ¢ _]:[_ âŠ¢ rmv _ _ _ _ n'[] _] = [_ âŠ¢ RMV2] in
  let [_ âŠ¢ _]:[_ âŠ¢ rmv _ _ _ Î²[] m[] _] = [_ âŠ¢ RMV3] in
  case comp_nats [ âŠ¢ n'] [ âŠ¢ m] of
  | [ âŠ¢ comp_names/eq] â‡’
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV2] [_ âŠ¢ RMV3] in
    let [_ âŠ¢ mg-weak RMV4a RMV4b MG' _ _ _] = merge_weak [_ âŠ¢ RMV4] [_ âŠ¢ MGm] [ âŠ¢ MLTa] in
    (case [ âŠ¢ Î²] of
    | [ âŠ¢ ğŸ˜ ] â‡’ ?
      % let [_ âŠ¢ mg-weak RMV2a RMV2b MG3 _ _ _] = merge_weak [_ âŠ¢ RMV2] [_ âŠ¢ MGm] [ âŠ¢ â€¢/us] in
      % [_ âŠ¢ mg-exch-exp RMV1a RMV2a RMV2a RMV4a RMV1b RMV2b RMV2b RMV4b MLTa[] â€¢/us MGm MG3 MGm MG' _ _ _ _ _]
    | [ âŠ¢ ğŸ™ ] â‡’ ?
    %   let [_ âŠ¢ mg-weak RMV2a RMV2b MG3 _ _ _] = merge_weak [_ âŠ¢ RMV2] [_ âŠ¢ MGm] [ âŠ¢ â€¢/a1] in
    %   [_ âŠ¢ mg-exch-exp RMV1a RMV2a RMV2a RMV4a RMV1b RMV2b RMV2b RMV4b MLTa[] â€¢/a1 MGm MG3 MGm MG' _ _ _ _ _]
		    %
    )
  | [ âŠ¢ comp_names/neq NEQ] â‡’
    % Extend diagram
    let [_ âŠ¢ rmv-po RMV3' RMV2' IF2[] IF3[] _ _] = rmv_pushout_idx [_ âŠ¢ RMV2] [_ âŠ¢ RMV3] [ âŠ¢ NEQ] in
    let [_ âŠ¢ rmv-ch RMV3'' RMV1' IF1[] IF3'[] _ _] = rmv_changeorder [_ âŠ¢ RMV1] [_ âŠ¢ RMV3'] in
    let [_ âŠ¢ rmv-ch RMV2'' RMV4' IF4[] IF2'[] _ _] = rmv_changeorder [_ âŠ¢ RMV4] [_ âŠ¢ RMV2'] in
    let [_ âŠ¢ rmv-pb RMV4'' RMV1'' IF1'[] IF4'[] _ _] = rmv_pullback [_ âŠ¢ RMV1'] [_ âŠ¢ RMV4'] in
    % NW
    let [_ âŠ¢ mg-str RMV3a'' RMV3b'' MLTb[] MGn' _ _] = merge_str [_ âŠ¢ RMV3''] [_ âŠ¢ MG] in
    let [_ âŠ¢ mg-str RMV3a' RMV3b' MLTb'[] MGnm _ _] = merge_str [_ âŠ¢ RMV3'] [_ âŠ¢ MGm] in
    let [_ âŠ¢ mg-str RMV1a' RMV1b' MLTa'[] _ _ _] = merge_str [_ âŠ¢ RMV1'] [_ âŠ¢ MGn'] in
    let [_ âŠ¢ rmv-ch RMV3a_2'' RMV1a_2' IF1a[] IF3a'[] _ _] = rmv_changeorder [_ âŠ¢ RMV1a] [_ âŠ¢ RMV3a'] in
    let [_ âŠ¢ rmv-ch RMV3b_2'' RMV1b_2' IF1b[] IF3b'[] _ _] = rmv_changeorder [_ âŠ¢ RMV1b] [_ âŠ¢ RMV3b'] in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (iflt_iflt_eq [ âŠ¢ IF1] [ âŠ¢ IF1a],iflt_iflt_eq [ âŠ¢ IF1] [ âŠ¢ IF1b]) in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (ifleq_ifleq_eq [ âŠ¢ IF3'] [ âŠ¢ IF3a'],ifleq_ifleq_eq [ âŠ¢ IF3'] [ âŠ¢ IF3b']) in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV3a''] [_ âŠ¢ RMV3a_2''] in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV3b''] [_ âŠ¢ RMV3b_2''] in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV1a'] [_ âŠ¢ RMV1a_2'] in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV1b'] [_ âŠ¢ RMV1b_2'] in
    % NE
    let [_ âŠ¢ mg-weak RMV4a' RMV4b' MGm' _ _ _] = merge_weak [_ âŠ¢ RMV4'] [_ âŠ¢ MGnm] [ âŠ¢ MLTa] in
    let [_ âŠ¢ rmv-pb RMV4a'' RMV1a'' IF1a'[] IF4a'[] _ _] = rmv_pullback [_ âŠ¢ RMV1a'] [_ âŠ¢ RMV4a'] in
    let [_ âŠ¢ rmv-pb RMV4b'' RMV1b'' IF1b'[] IF4b'[] _ _] = rmv_pullback [_ âŠ¢ RMV1b'] [_ âŠ¢ RMV4b'] in
    let [_ âŠ¢ mg-weak RMV1a_2'' RMV1b_2'' MG''' _ _ _] = merge_weak [_ âŠ¢ RMV1''] [_ âŠ¢ MGm'] [ âŠ¢ MLTa] in
    let [_ âŠ¢ mg-weak RMV4a_2'' RMV4b_2'' _ _ _ _] = merge_weak [_ âŠ¢ RMV4''] [_ âŠ¢ MGn'] [ âŠ¢ MLTa] in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (iflt_iflt_eq [ âŠ¢ IF1'] [ âŠ¢ IF1a'],iflt_iflt_eq [ âŠ¢ IF1'] [ âŠ¢ IF1b']) in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (ifleq_ifleq_eq [ âŠ¢ IF4'] [ âŠ¢ IF4a'],ifleq_ifleq_eq [ âŠ¢ IF4'] [ âŠ¢ IF4b']) in
    let [_ âŠ¢ cx/refl] = str_lunq [_ âŠ¢ RMV1a_2''] [_ âŠ¢ RMV1a''] in
    let [_ âŠ¢ cx/refl] = str_lunq [_ âŠ¢ RMV1b_2''] [_ âŠ¢ RMV1b''] in
    let [_ âŠ¢ cx/refl] = str_lunq [_ âŠ¢ RMV4a_2''] [_ âŠ¢ RMV4a''] in
    let [_ âŠ¢ cx/refl] = str_lunq [_ âŠ¢ RMV4b_2''] [_ âŠ¢ RMV4b''] in
    % SW
    let [_ âŠ¢ mg-weak RMV2a RMV2b MG'' _ _ _] = merge_weak [_ âŠ¢ RMV2] [_ âŠ¢ MGm] [ âŠ¢ MLTb] in
    let [_ âŠ¢ mg-str RMV3a RMV3b MLTb''[] MGn _ _] = merge_str [_ âŠ¢ RMV3] [_ âŠ¢ MG''] in
    let [_ âŠ¢ mg-str RMV2a' RMV2b' MLTb'''[] _ _ _] = merge_str [_ âŠ¢ RMV2'] [_ âŠ¢ MGn] in
    let [_ âŠ¢ rmv-po RMV3a_2' RMV2a_2' IF2a[] IF3a[] _ _] = rmv_pushout_idx [_ âŠ¢ RMV2a] [_ âŠ¢ RMV3a] [ âŠ¢ NEQ] in
    let [_ âŠ¢ rmv-po RMV3b_2' RMV2b_2' IF2b[] IF3b[] _ _] = rmv_pushout_idx [_ âŠ¢ RMV2b] [_ âŠ¢ RMV3b] [ âŠ¢ NEQ] in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (iflt_iflt_eq [ âŠ¢ IF2a] [ âŠ¢ IF2],iflt_iflt_eq [ âŠ¢ IF2b] [ âŠ¢ IF2]) in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (iflt_iflt_eq [ âŠ¢ IF3a] [ âŠ¢ IF3],iflt_iflt_eq [ âŠ¢ IF3b] [ âŠ¢ IF3]) in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV2a'] [_ âŠ¢ RMV2a_2'] in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV2b'] [_ âŠ¢ RMV2b_2'] in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV3a'] [_ âŠ¢ RMV3a_2'] in
    let [_ âŠ¢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ âŠ¢ RMV3b'] [_ âŠ¢ RMV3b_2'] in
    % SE
    let [_ âŠ¢ mg-weak RMV4a RMV4b MG' _ _ _] = merge_weak [_ âŠ¢ RMV4] [_ âŠ¢ MGn] [ âŠ¢ MLTa] in
    let [_ âŠ¢ rmv-ch RMV2a'' RMV4a_2' IF4a[] IF2a'[] _ _] = rmv_changeorder [_ âŠ¢ RMV4a] [_ âŠ¢ RMV2a'] in
    let [_ âŠ¢ rmv-ch RMV2b'' RMV4b_2' IF4b[] IF2b'[] _ _] = rmv_changeorder [_ âŠ¢ RMV4b] [_ âŠ¢ RMV2b'] in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (iflt_iflt_eq [ âŠ¢ IF4] [ âŠ¢ IF4a],iflt_iflt_eq [ âŠ¢ IF4] [ âŠ¢ IF4b]) in
    let ([ âŠ¢ nat/refl],[ âŠ¢ nat/refl]) = (ifleq_ifleq_eq [ âŠ¢ IF2'] [ âŠ¢ IF2a'],ifleq_ifleq_eq [ âŠ¢ IF2'] [ âŠ¢ IF2b']) in
    let [_ âŠ¢ cx/refl] = str_lunq [_ âŠ¢ RMV4a'] [_ âŠ¢ RMV4a_2'] in
    let [_ âŠ¢ cx/refl] = str_lunq [_ âŠ¢ RMV4b'] [_ âŠ¢ RMV4b_2'] in
    % Conclusion
    [_ âŠ¢ mg-exch-exp
      RMV1a RMV2a RMV3a RMV4a RMV1b RMV2b RMV3b RMV4b
      MLTa[] MLTb[] MGm MG'' MGn MG' _ _ _ _ _]
  ;

LF mg_exch : exch Î” X Y Î”' â†’ merge Î”â‚ Î”â‚‚ Î” â†’ type =
  | mg-exch :
    exch Î”â‚ X Y Î”â‚' â†’ exch Î”â‚‚ X Y Î”â‚‚' â†’ merge Î”â‚' Î”â‚‚' Î”'
    â†’ {EXC:exch Î” X Y Î”'} {MG:merge Î”â‚ Î”â‚‚ Î”}
    mg_exch EXC MG
  ;

rec merge_exch : (Î¨:vctx)
{EXC:[Î¨ âŠ¢ exch Î” X Y Î”']} {MG:[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]} [Î¨ âŠ¢ mg_exch EXC MG] =
  mlam EXC, MG â‡’
  let [_ âŠ¢ exchg RMVx1 RMVy1 RMVy2 RMVx2] = [_ âŠ¢ EXC] in
  let [_ âŠ¢ mg-exch-exp RMVx1a RMVy1a RMVy2a RMVx2a
    RMVx1b RMVy1b RMVy2b RMVx2b _ _ _ _ _ MG2 _ _ _ _ _] =
    merge_exch_exp [_ âŠ¢ RMVx1] [_ âŠ¢ RMVy1] [_ âŠ¢ RMVy2] [_ âŠ¢ RMVx2] [_ âŠ¢ MG] in
  [_ âŠ¢ mg-exch (exchg RMVx1a RMVy1a RMVy2a RMVx2a) (exchg RMVx1b RMVy1b RMVy2b RMVx2b) MG2 _ _]
  ;

%------------------------------------------------------%
% Context membership
%------------------------------------------------------%

% X âˆ‰ (Î”â‚ â‹ˆ Î”â‚‚) iff X âˆ‰ Î”â‚ (or Î”â‚‚, by commutativity)

rec notin_merge : (Î¨:vctx) ([Î¨ âŠ¢ lookup_n X Î”] â†’ [ âŠ¢ false]) â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ ([Î¨ âŠ¢ lookup_n X Î”â‚] â†’ [ âŠ¢ false]) =
  / total 3 /
  fn NIN, MG, AP â‡’
  let [_ âŠ¢ lookn RMV] = AP in
  case [_ âŠ¢ RMV] of
  | [_ âŠ¢ rmv/t LN1] â‡’
    let [_ âŠ¢ mg/c MG1 _] = MG in
    NIN (look_top [_ âŠ¢ _])
  | [_ âŠ¢ rmv/n RMV1] â‡’
    let [_ âŠ¢ mg/c MG1 _] = MG in
    let [_ âŠ¢ mg-str2 _ RMV2 _ _ _ _] = merge_str2 [_ âŠ¢ RMV1] [_ âŠ¢ MG1] in
    NIN [_ âŠ¢ lookn (rmv/n RMV2)]
  ;

rec notin_merge_l : (Î¨:vctx) ([Î¨ âŠ¢ lookup_n X Î”â‚] â†’ [ âŠ¢ false]) â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ ([Î¨ âŠ¢ lookup_n X Î”] â†’ [ âŠ¢ false]) =
  / total 3 /
  fn NIN, MG, LK â‡’
  let [_ âŠ¢ lookn RMV] = LK in
  case [_ âŠ¢ RMV] of
  | [_ âŠ¢ rmv/t LN1] â‡’
    let [_ âŠ¢ mg/c MG1 _] = MG in
    NIN (look_top [_ âŠ¢ _])
  | [_ âŠ¢ rmv/n RMV1] â‡’
    let [_ âŠ¢ mg/c MG1 _] = MG in
    let [_ âŠ¢ mg-str RMV2 _ _ _ _ _] = merge_str [_ âŠ¢ RMV1] [_ âŠ¢ MG1] in
    NIN [_ âŠ¢ lookn (rmv/n RMV2)]
  ;

%------------------------------------------------------%
% Context well-formedness
%------------------------------------------------------%

% Wf [Î¨ âŠ¢ Î”â‚] iff Wf [Î¨ âŠ¢ Î”â‚ â‹ˆ Î”â‚‚]

rec wf_merge : Wf [Î¨ âŠ¢ Î”] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ Wf [Î¨ âŠ¢ Î”â‚] =
  / total wf (wf_merge _ _ _ _ wf _) /
  fn WF, MG â‡’
  case WF of
  | Wf/n â‡’ let [_ âŠ¢ mg/n] = MG in Wf/n
  | Wf/c WF1 NIN â‡’
    let [_ âŠ¢ mg/c MG1 _] = MG in
    Wf/c (wf_merge WF1 [_ âŠ¢ MG1]) (notin_merge NIN [_ âŠ¢ MG1])
  ;

rec wf_merge_r : Wf [Î¨ âŠ¢ Î”] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ Wf [Î¨ âŠ¢ Î”â‚‚] =
  / total /
  fn WF, MG â‡’ wf_merge WF (merge_comm MG)
  ;

rec wf_merge_l : Wf [Î¨ âŠ¢ Î”â‚] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ Wf [Î¨ âŠ¢ Î”] =
  / total wf (wf_merge_l _ _ _ _ wf _) /
  fn WF, MG â‡’
  case WF of
  | Wf/n â‡’ let [_ âŠ¢ mg/n] = MG in Wf/n
  | Wf/c WF1 NIN â‡’
    let [_ âŠ¢ mg/c MG1 _] = MG in
    Wf/c (wf_merge_l WF1 [_ âŠ¢ MG1]) (notin_merge_l NIN [_ âŠ¢ MG1])
  ;

rec wf_merge2_r : Wf [Î¨ âŠ¢ Î”â‚‚] â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ Wf [Î¨ âŠ¢ Î”] =
  / total /
  fn WF, MG â‡’ wf_merge_l WF (merge_comm MG)
  ;

%------------------------------------------------------%
% Useful corollaries
%------------------------------------------------------%

rec merge_pres_str :
[Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]
â†’ [Î¨ âŠ¢ rmv Î”â‚ X Aâ‚ Î±â‚ nâ‚ Î”â‚'] â†’ [Î¨ âŠ¢ rmv Î”â‚‚ X Aâ‚‚ Î±â‚‚ nâ‚‚ Î”â‚‚'] â†’ [Î¨ âŠ¢ rmv Î” X A Î± n Î”']
â†’ Wf [Î¨ âŠ¢ Î”] â†’ [Î¨ âŠ¢ merge Î”â‚' Î”â‚‚' Î”'] =
  / total /
  fn MG, RMV1, RMV2, RMV, WF â‡’
  let ([_ âŠ¢ MG'],[_ âŠ¢ RMV']) = (MG,RMV) in
  let [_ âŠ¢ mg-str RMV1' RMV2' MLT1 MG1 _ _] = merge_str [_ âŠ¢ RMV'] [_ âŠ¢ MG'] in
  let [_ âŠ¢ tp-mult-nat-lctx-refl] = str_runq RMV1 [_ âŠ¢ RMV1'] (wf_merge WF MG) in
  let [_ âŠ¢ tp-mult-nat-lctx-refl] = str_runq RMV2 [_ âŠ¢ RMV2'] (wf_merge_r WF MG) in
  [_ âŠ¢ MG1]
  ;
