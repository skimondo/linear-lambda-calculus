%------------------------------------------------------%
% Pruning lemmata I
%------------------------------------------------------%

inductive PruneRmv : (Ψ:vctx) {UPD:[Ψ,x:obj ⊢ rmv Δ[..] X A[] α[] n[] Δ']} ctype =
  | Prune-Rmv : [Ψ,x:obj ⊢ cx_eq Δ' Δ''[..]] → [Ψ,x:obj ⊢ obj_eq X X'[..]]
    → [Ψ ⊢ rmv Δ X' A[] α[] n[] Δ'']
    → {UPD:[Ψ,x:obj ⊢ rmv Δ[..] X A[] α[] n[] Δ']} PruneRmv [Ψ,x:obj ⊢ UPD];

rec prune_rmv : {RMV:[Ψ,x:obj ⊢ rmv Δ[..] X A[] α[] n[] Δ']} PruneRmv [Ψ,x:obj ⊢ RMV] =
  / total 1 /
  mlam RMV ⇒ case [_ ⊢ RMV] of
  | [_,x:obj ⊢ rmv/t LN1] ⇒
    let [_ ⊢ LN2] = prune_len [_,x:obj ⊢ LN1] in
    Prune-Rmv [_ ⊢ cx/refl] [_,x:obj ⊢ obj/refl] [_ ⊢ rmv/t LN2] [_,x:obj ⊢ _]
  | [_,x:obj ⊢ rmv/n RMV1] ⇒
    let Prune-Rmv [_ ⊢ cx/refl] [_,x:obj ⊢ obj/refl] [_ ⊢ RMV2] [_,x:obj ⊢ _] = prune_rmv [_ ⊢ RMV1] in
    Prune-Rmv [_ ⊢ cx/refl] [_,x:obj ⊢ obj/refl] [_ ⊢ rmv/n RMV2] [_,x:obj ⊢ _]
  ;

%------------------------------------------------------%
% Context size
%------------------------------------------------------%

% Non-empty contexts are not of length 0

rec len_nonempty : (Ψ:vctx) [Ψ ⊢ len Δ n[]] → [Ψ ⊢ rmv Δ X A α m Δ'] → [ ⊢ is_suc n] =
  / total /
  fn LN, RMV ⇒ case LN of
  | [_ ⊢ len/n] ⇒ impossible RMV
  | [_ ⊢ len/c LN1'] ⇒ [ ⊢ is-suc]
  ;

% If n ∈ Δ then 0 < n ≤ |Δ|

rec lookup_is_suc : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [ ⊢ is_suc n] =
  / total 1 /
  fn RMV ⇒ case RMV of
  | [_ ⊢ rmv/t _] ⇒ [ ⊢ is-suc]
  | [_ ⊢ rmv/n RMV1] ⇒ lookup_is_suc [_ ⊢ RMV1]
  ;

% Adding / removing an element from a typing context grows / shrinks its size by 1

LF len_pred : lctx → nat → type = len-pred : len Δ k → len_pred Δ (suc k);

rec len_str : (Ψ:vctx) [Ψ ⊢ len Δ k] → [Ψ ⊢ rmv Δ X A α n Δ'] → [Ψ ⊢ len_pred Δ' k] =
  / total 2 /
  fn LN, RMV ⇒ case RMV of
  | [_ ⊢ rmv/t _] ⇒
    let [_ ⊢ len/c LN1] = LN in
    [_ ⊢ len-pred LN1]
  | [_ ⊢ rmv/n RMV1] ⇒
    let [_ ⊢ len/c LN1] = LN in
    let [_ ⊢ len-pred LN2] = len_str [_ ⊢ LN1] [_ ⊢ RMV1] in
    [_ ⊢ len-pred (len/c LN2)]
  ;

rec len_weak : (Ψ:vctx) [Ψ ⊢ len Δ' k[]] → [Ψ ⊢ rmv Δ X A α n Δ'] → [Ψ ⊢ len Δ (suc k[])] =
  / total 2 /
  fn LN, RMV ⇒ case RMV of
  | [_ ⊢ rmv/t _] ⇒
    let [_ ⊢ LN1] = LN in
    [_ ⊢ len/c LN1]
  | [_ ⊢ rmv/n RMV1] ⇒
    let [_ ⊢ len/c LN1] = LN in
    let [_ ⊢ LN2] = len_weak [_ ⊢ LN1] [_ ⊢ RMV1] in
    [_ ⊢ len/c LN2]
  ;

rec len_str_leq : (Ψ:vctx) [Ψ ⊢ len Δ k[]] → [Ψ ⊢ rmv Δ X A α n[] Δ'] → [ ⊢ leq n k] =
  / total 2 /
  fn LN, RMV ⇒ case RMV of
  | [_ ⊢ rmv/t LN1] ⇒
    let [_ ⊢ len/c LN2] = LN in
    let [ ⊢ nat/refl] = len_unq [_ ⊢ LN1] [_ ⊢ LN2] in
    [ ⊢ leq/id]
  | [_ ⊢ rmv/n RMV1] ⇒
    let [_ ⊢ len/c LN1] = LN in
    let [ ⊢ LT] = leq_suc_lt (len_str_leq [_ ⊢ LN1] [_ ⊢ RMV1]) in
    [ ⊢ leq/lt LT]
  ;

rec len_weak_leq : (Ψ:vctx) [Ψ ⊢ len Δ' k[]] → [Ψ ⊢ rmv Δ X A α n[] Δ'] → [ ⊢ leq n (suc k)] =
  / total /
  fn LN, RMV ⇒
  len_str_leq (len_weak LN RMV) RMV
  ;

%------------------------------------------------------%
% Basic properties of rmv
%------------------------------------------------------%

% Generate `rmv` relation resulting from removing the topmost element of a typing context

rec str_top : (Ψ:vctx) [Ψ ⊢ len Δ n[]] → {X:[Ψ ⊢ var]} {A:[ ⊢ tp]} {α:[ ⊢ mult]} [Ψ ⊢ rmv (cons Δ X A[] α[]) X A[] α[] (suc n[]) Δ] =
  / total /
  fn LN ⇒ mlam X, A, α ⇒
  let [_ ⊢ LN'] = LN in
  [_ ⊢ rmv/t LN']
  ;

LF get_rmv_top : lctx → obj → tp → mult → type =
  rmv-t : rmv (cons Δ X A α) X A α (suc n) Δ → len Δ n → get_rmv_top Δ X A α;

rec get_str_top : (Ψ:vctx) {Δ:[Ψ ⊢ lctx]} {X:[Ψ ⊢ var]} {A:[ ⊢ tp]} {α:[ ⊢ mult]} [Ψ ⊢ get_rmv_top Δ X A[] α[]] =
  / total /
  mlam Δ, X, A, α ⇒
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ] in
  [_ ⊢ rmv-t (rmv/t LN) LN]
  ;

% Obtain the result of inserting an entry at position 0 < k ≤ |Δ| + 1

LF get_wk : lctx → obj → tp → mult → nat → type = get-wk : rmv Δ' X A α k Δ → get_wk Δ X A α k;

rec get_weak : (Ψ:vctx) [Ψ ⊢ len Δ n[]] → [ ⊢ leq k n]
→ {X:[Ψ ⊢ var]} {A:[ ⊢ tp]} {α:[ ⊢ mult]} [Ψ ⊢ get_wk Δ X A[] α[] (suc k[])] =
  / total 1 /
  fn LN, LEQ ⇒ mlam X, A, α ⇒
  case LEQ of
  | [ ⊢ leq/id] ⇒ let [_ ⊢ LN'] = LN in [_ ⊢ get-wk (rmv/t LN')]
  | [ ⊢ leq/lt LT1] ⇒
    case LN of
    | [_ ⊢ len/n] ⇒ impossible [ ⊢ LT1]
    | [_ ⊢ len/c LN1] ⇒
      let [_ ⊢ get-wk RMV1] = get_weak [_ ⊢ LN1] (lt_suc_leq [ ⊢ LT1]) [_ ⊢ X] [ ⊢ A] [ ⊢ α] in
      [_ ⊢ get-wk (rmv/n RMV1)]
  ;

rec get_weak_cor : (Ψ:vctx) [Ψ ⊢ rmv Δ' X A α k[] Δ]
→ {Y:[Ψ ⊢ var]} {B:[ ⊢ tp]} {β:[ ⊢ mult]} [Ψ ⊢ get_wk Δ Y B[] β[] k[]] =
  / total /
  fn RMV ⇒ mlam Y, B, β ⇒
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ _ Δ] = RMV in
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ] in
  let [ ⊢ is-suc] = lookup_is_suc RMV in
  get_weak [_ ⊢ LN] (lt_suc_leq (lt_leq_trans (lt_suc [ ⊢ _]) (len_weak_leq [_ ⊢ LN] RMV))) [_ ⊢ _] [ ⊢ _] [ ⊢ _]
  ;

%------------------------------------------------------%
% Algebraic properties I
%------------------------------------------------------%

rec str_lunq : (Ψ:vctx) [Ψ ⊢ rmv Δ' X A α n Δ] → [Ψ ⊢ rmv Δ'' X A α n Δ] → [Ψ ⊢ cx_eq Δ' Δ''] =
  / total 1 /
  fn RMV1, RMV2 ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    (case RMV2 of
    | [_ ⊢ rmv/t _] ⇒ [_ ⊢ cx/refl]
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [_ ⊢ len/c LN1'] = [_ ⊢ LN1] in
      impossible suc_leq_contra (len_weak_leq [_ ⊢ LN1'] [_ ⊢ RMV2'])
    )
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV2 of
    | [_ ⊢ rmv/t (len/c LN2)] ⇒
      impossible suc_leq_contra (len_weak_leq [_ ⊢ LN2] [_ ⊢ RMV1'])
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [_ ⊢ cx/refl] = str_lunq [_ ⊢ RMV1'] [_ ⊢ RMV2'] in
      [_ ⊢ cx/refl]
  ;

LF tp_mult_nat_lctx_eq : tp → tp → mult → mult → nat → nat → lctx → lctx → type =
  tp-mult-nat-lctx-refl : tp_mult_nat_lctx_eq A A α α n n Δ Δ;

LF var_tp_mult_lctx_eq : obj → obj → tp → tp → mult → mult → lctx → lctx → type =
  var-tp-mult-nat-lctx-refl : var_tp_mult_lctx_eq X X A A α α Δ Δ;

rec str_runq_idx : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n Δ'] → [Ψ ⊢ rmv Δ Y B β n Δ'']
→ [Ψ ⊢ var_tp_mult_lctx_eq X Y A B α β Δ' Δ''] =
  fn RMV1, RMV2 ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    (case RMV2 of
    | [_ ⊢ rmv/t LN2] ⇒ [_ ⊢ var-tp-mult-nat-lctx-refl]
    | [_ ⊢ rmv/n RMV2'] ⇒ impossible suc_leq_contra (len_str_leq [_ ⊢ LN1] [_ ⊢ RMV2'])
    )
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV2 of
    | [_ ⊢ rmv/t LN2] ⇒ impossible suc_leq_contra (len_str_leq [_ ⊢ LN2] [_ ⊢ RMV1'])
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ ⊢ RMV1'] [_ ⊢ RMV2'] in
      [_ ⊢ var-tp-mult-nat-lctx-refl]
  ;

rec str_runq : [Ψ ⊢ rmv Δ X A α n Δ'] → [Ψ ⊢ rmv Δ X A' α' n' Δ''] → Wf [Ψ ⊢ Δ]
→ [Ψ ⊢ tp_mult_nat_lctx_eq A A' α α' n n' Δ' Δ''] =
  fn RMV1, RMV2, WF ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    (case RMV2 of
    | [_ ⊢ rmv/t LN2] ⇒
      let [ ⊢ nat/refl] = len_unq [_ ⊢ LN1] [_ ⊢ LN2] in
      [_ ⊢ tp-mult-nat-lctx-refl]
    | [_ ⊢ rmv/n RMV2'] ⇒
      let Wf/c WF1 NIN1 = WF in
      impossible NIN1 [_ ⊢ lookn RMV2']
    )
  | [_ ⊢ rmv/n RMV1'] ⇒
    let Wf/c WF1 NIN1 = WF in
    case RMV2 of
    | [_ ⊢ rmv/t _] ⇒ impossible NIN1 [_ ⊢ lookn RMV1']
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [_ ⊢ tp-mult-nat-lctx-refl] = str_runq [_ ⊢ RMV1'] [_ ⊢ RMV2'] WF1 in
      [_ ⊢ tp-mult-nat-lctx-refl]
  ;

% Commutativity for strengthening / weakening

rec weak_comm : (Ψ:vctx) [Ψ ⊢ rmv Δ₁ Y B β m[] Δ₂] → [Ψ ⊢ rmv Δ₂ X A α n[] Δ₃]
→ [Ψ ⊢ rmv Δ₁' X A α (suc n[]) Δ₂'] → [Ψ ⊢ rmv Δ₂' Y B β m[] Δ₃]
→ [ ⊢ leq m n] → [Ψ ⊢ cx_eq Δ₁ Δ₁'] =
  / total 1 /
  fn RMV1, RMV2, RMV3, RMV4, LEQ ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    impossible suc_leq_contra (leq_trans LEQ (len_str_leq [_ ⊢ LN1] RMV2))
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV2 of
    | [_ ⊢ rmv/t LN2] ⇒
      let [_ ⊢ cx/refl] = str_lunq [_ ⊢ RMV1'] RMV4 in
      (case RMV3 of
      | [_ ⊢ rmv/t _] ⇒ [_ ⊢ cx/refl]
      | [_ ⊢ rmv/n RMV4'] ⇒
        let [_ ⊢ len/c LN1] = len_weak [_ ⊢ LN2] [_ ⊢ RMV1'] in
        impossible suc_leq_contra (len_weak_leq [_ ⊢ LN1] [_ ⊢ RMV4'])
      )
    | [_ ⊢ rmv/n RMV2'] ⇒
      case RMV4 of
      | [_ ⊢ rmv/t (len/c LN4)] ⇒
        impossible suc_leq_contra (leq_trans LEQ (len_weak_leq [_ ⊢ LN4] [_ ⊢ RMV2']))
      | [_ ⊢ rmv/n RMV4'] ⇒
        case RMV3 of
        | [_ ⊢ rmv/t (len/c LN3)] ⇒
          let [_ ⊢ len-pred LN2] = len_str [_ ⊢ LN3] [_ ⊢ RMV4'] in
          impossible suc_leq_contra (len_weak_leq [_ ⊢ LN2] [_ ⊢ RMV2'])
        | [_ ⊢ rmv/n RMV3'] ⇒
          let [_ ⊢ cx/refl] = weak_comm [_ ⊢ RMV1'] [_ ⊢ RMV2'] [_ ⊢ RMV3'] [_ ⊢ RMV4'] LEQ in
          [_ ⊢ cx/refl]
  ;

rec str_comm_idx : (Ψ:vctx) [Ψ ⊢ rmv Δ₁ Y B β m[] Δ₂] → [Ψ ⊢ rmv Δ₂ X A α n[] Δ₃]
→ [Ψ ⊢ rmv Δ₁ X A α (suc n[]) Δ₂'] → [Ψ ⊢ rmv Δ₂' Y B β m[] Δ₃']
→ [ ⊢ leq m n] → [Ψ ⊢ cx_eq Δ₃ Δ₃'] =
  / total 2 /
  fn RMV1, RMV2, RMV3, RMV4, LEQ ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    impossible suc_leq_contra (leq_trans LEQ (len_str_leq [_ ⊢ LN1] RMV2))
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV3 of
    | [_ ⊢ rmv/t LN3] ⇒
      let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ ⊢ RMV1'] RMV4 in
      (case RMV2 of
      | [_ ⊢ rmv/t _] ⇒ [_ ⊢ cx/refl]
      | [_ ⊢ rmv/n RMV2'] ⇒
        let [_ ⊢ len-pred LN2] = len_str [_ ⊢ LN3] [_ ⊢ RMV1'] in
        impossible suc_leq_contra (len_str_leq [_ ⊢ LN2] [_ ⊢ RMV2'])
      )
    | [_ ⊢ rmv/n RMV3'] ⇒
      case RMV2 of
      | [_ ⊢ rmv/t LN2] ⇒ impossible suc_leq_contra (len_str_leq (len_weak [_ ⊢ LN2] [_ ⊢ RMV1']) [_ ⊢ RMV3'])
      | [_ ⊢ rmv/n RMV2'] ⇒
        case RMV4 of
        | [_ ⊢ rmv/t LN4] ⇒
          let [_ ⊢ len-pred LN2] = len_str (len_weak [_ ⊢ LN4] [_ ⊢ RMV3']) [_ ⊢ RMV1'] in
          impossible suc_leq_contra (leq_trans LEQ (len_str_leq [_ ⊢ LN2] [_ ⊢ RMV2']))
        | [_ ⊢ rmv/n RMV4'] ⇒
          let [_ ⊢ cx/refl] = str_comm_idx [_ ⊢ RMV1'] [_ ⊢ RMV2'] [_ ⊢ RMV3'] [_ ⊢ RMV4'] LEQ in
          [_ ⊢ cx/refl]
  ;

%------------------------------------------------------%
% Lookup properties
%------------------------------------------------------%

% If (X : A^α) ∈ₙ Δ and (Y : B^β) ∈ₘ Δ, then n ≠ m iff X ≠ Y

rec lookup_neq_var2nat : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ Y B β m[] Δ'']
→ ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) → [ ⊢ neq n m] =
  / total 1 /
  fn RMV1, RMV2, NEQ ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    (case RMV2 of
    | [_ ⊢ rmv/t _] ⇒ impossible NEQ [_ ⊢ obj/refl]
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [ ⊢ LT] = leq_suc_lt (len_str_leq [_ ⊢ LN1] [_ ⊢ RMV2']) in
      [ ⊢ neq/2 LT]
    )
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV2 of
    | [_ ⊢ rmv/t LN2] ⇒
      let [ ⊢ LT] = leq_suc_lt (len_str_leq [_ ⊢ LN2] [_ ⊢ RMV1']) in
      [ ⊢ neq/1 LT]
    | [_ ⊢ rmv/n RMV2'] ⇒ lookup_neq_var2nat [_ ⊢ RMV1'] [_ ⊢ RMV2'] NEQ
  ;

rec lookup_neq_nat2var : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ Y B β m[] Δ'']
→ [ ⊢ neq n m] → Wf [Ψ ⊢ Δ] → ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) =
  / total /
  fn RMV1, RMV2, NEQ, WF, EQ ⇒
  let [_ ⊢ obj/refl] = EQ in
  let [_ ⊢ tp-mult-nat-lctx-refl] = str_runq RMV1 RMV2 WF in
  neq_irreflex NEQ
  ;

LF lookup_i_ife : obj → tp → mult → nat → nat → nat → lctx → type =
| look_i_ife : if_lt_else n' n m k → rmv Δ X A α n' _ → lookup_i_ife X A α n m k Δ;

rec lookup_str_idx : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ Y B β (suc m[]) Δ'']
→ [ ⊢ neq n (suc m)] → [Ψ ⊢ lookup_i_ife Y B β (suc m[]) n[] m[] Δ'] =
  / total 1 /
  fn RMV1, RMV2, NEQ ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    (case RMV2 of
    | [_ ⊢ rmv/t LN2] ⇒
      let [ ⊢ nat/refl] = len_unq [_ ⊢ LN1] [_ ⊢ LN2] in
      impossible neq_irreflex NEQ
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [ ⊢ LT] = leq_suc_lt (len_str_leq [_ ⊢ LN1] [_ ⊢ RMV2']) in
      [_ ⊢ look_i_ife (if-lt/t LT[]) RMV2']
    )
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV2 of
    | [_ ⊢ rmv/t LN1] ⇒
      let [_ ⊢ len-pred LN2] = len_str [_ ⊢ LN1] [_ ⊢ RMV1'] in
      let [ ⊢ LT] = leq_suc_lt (len_str_leq [_ ⊢ LN1] [_ ⊢ RMV1']) in
      [_ ⊢ look_i_ife (if-lt/f (leq/lt LT[])) (rmv/t LN2)]
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [_ ⊢ look_i_ife IFLT RMV3] = lookup_str_idx [_ ⊢ RMV1'] [_ ⊢ RMV2'] NEQ in
      [_ ⊢ look_i_ife IFLT (rmv/n RMV3)]
  ;

%{ - - - - - - - - - - - - - - - - - - - - - - - - - - %
rec lookup_str_idx_2 : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ Y B β (suc m[]) Δ'']
→ [ ⊢ leq n m] → [Ψ ⊢ lookup_i_ife Y B β (suc m[]) n[] m[] Δ'] =
  fn RMV1, RMV2, LEQ ⇒
  let [ ⊢ LT] = leq_suc_lt LEQ in
  lookup_str_idx RMV1 RMV2 [ ⊢ neq/1 LT]
  ;
% - - - - - - - - - - - - - - - - - - - - - - - - - - }%

rec lookup_str : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ Y B β m[] Δ'']
→ ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) → [Ψ ⊢ lookup Y B β Δ'] =
  / total /
  fn RMV1, RMV2, NEQ ⇒
  let [ ⊢ is-suc] = lookup_is_suc RMV2 in
  let [_ ⊢ look_i_ife _ RMV3] = lookup_str_idx RMV1 RMV2 (lookup_neq_var2nat RMV1 RMV2 NEQ) in
  [_ ⊢ look RMV3]
  ;

rec lookup_weak_idx : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ' Y B[] β[] m[] Δ'']
→ [Ψ ⊢ lookup_i_ife Y B[] β[] m[] n[] (suc m[]) Δ] =
  / total 1 /
  fn RMV1, RMV2 ⇒
  case RMV1 of
  | [_ ⊢ rmv/t LN1] ⇒
    let [_ ⊢ RMV2'] = RMV2 in
    let [ ⊢ LT] = leq_suc_lt (len_str_leq [_ ⊢ LN1] RMV2) in
    [_ ⊢ look_i_ife (if-lt/t LT[]) (rmv/n RMV2')]
  | [_ ⊢ rmv/n RMV1'] ⇒
    case RMV2 of
    | [_ ⊢ rmv/t LN1] ⇒
      let [_ ⊢ LN2] = len_weak [_ ⊢ LN1] [_ ⊢ RMV1'] in
      let [ ⊢ LEQ] = len_str_leq [_ ⊢ LN2] [_ ⊢ RMV1'] in
      [_ ⊢ look_i_ife (if-lt/f LEQ[]) (rmv/t LN2)]
    | [_ ⊢ rmv/n RMV2'] ⇒
      let [_ ⊢ look_i_ife IFLT RMV3'] = lookup_weak_idx [_ ⊢ RMV1'] [_ ⊢ RMV2'] in
      [_ ⊢ look_i_ife IFLT (rmv/n RMV3')]
  ;

rec lookup_weak : (Ψ:vctx) [Ψ ⊢ rmv Δ X A α n[] Δ'] → [Ψ ⊢ rmv Δ' Y B[] β[] m[] Δ''] → [Ψ ⊢ lookup Y B[] β[] Δ] =
  / total /
  fn RMV1, RMV2 ⇒
  let [_ ⊢ look_i_ife _ RMV3] = lookup_weak_idx RMV1 RMV2 in
  [_ ⊢ look RMV3]
  ;

% Corollaries:

rec lookup_lab_neq_idx : (Ψ:vctx) [Ψ ⊢ rmv Δ X A lin n[] Δ'] → [Ψ ⊢ rmv Δ Y B used m[] Δ''] → [ ⊢ neq n m] =
  / total /
  fn RMV1, RMV2 ⇒
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ n[] _] = RMV1 in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ m[] _] = RMV2 in
  case comp_nats [ ⊢ n] [ ⊢ m] of
  | [ ⊢ comp_names/eq] ⇒ ? % impossible str_runq_idx RMV1 RMV2
  | [ ⊢ comp_names/neq NEQ] ⇒ [ ⊢ NEQ]
  ;

rec lookup_lab_neq : (Ψ:vctx) [Ψ ⊢ rmv Δ X A[] lin n[] Δ'] → [Ψ ⊢ rmv Δ Y B[] used m[] Δ'']
→ Wf [Ψ ⊢ Δ] → ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) =
  / total /
  fn RMV1, RMV2, WF, EQ ⇒ ?
%  let [_ ⊢ obj/refl] =  EQ in   impossible str_runq RMV1 RMV2 WF
  ;

%------------------------------------------------------%
% Algebraic properties II
%------------------------------------------------------%

rec str_comm : (Ψ:vctx) [Ψ ⊢ rmv Δ₁ Y B[] β[] m[] Δ₂] → [Ψ ⊢ rmv Δ₂ X A[] α[] n[] Δ₃]
→ [Ψ ⊢ rmv Δ₁ X A[] α[] n'[] Δ₂'] → [Ψ ⊢ rmv Δ₂' Y B[] β[] m'[] Δ₃']
→ Wf [Ψ ⊢ Δ₁] → [Ψ ⊢ cx_eq Δ₃ Δ₃'] =
  / total /
  fn RMV1, RMV2, RMV3, RMV4, WF ⇒
  let [_ ⊢ look_i_ife IFLT1[] RMV1'] = lookup_weak_idx RMV3 RMV4 in
  let [_ ⊢ look_i_ife IFLT2[] RMV3'] = lookup_weak_idx RMV1 RMV2 in
  let [_ ⊢ tp-mult-nat-lctx-refl] = str_runq RMV1 [_ ⊢ RMV1'] WF in
  let [_ ⊢ tp-mult-nat-lctx-refl] = str_runq RMV3 [_ ⊢ RMV3'] WF in
  case [ ⊢ IFLT1] of
  | [ ⊢ if-lt/t LT1] ⇒
    (case [ ⊢ IFLT2] of
    | [ ⊢ if-lt/t LT2] ⇒ impossible lt_irreflex (lt_trans [ ⊢ LT1] [ ⊢ LT2])
    | [ ⊢ if-lt/f LEQ2] ⇒ str_comm_idx RMV1 RMV2 RMV3 RMV4 [_ ⊢ LEQ2]
    )
  | [ ⊢ if-lt/f LEQ1] ⇒
    case [ ⊢ IFLT2] of
    | [ ⊢ if-lt/t LT2] ⇒
      let [_ ⊢ cx/refl] = str_comm_idx RMV3 RMV4 RMV1 RMV2 (lt_suc_leq [_ ⊢ LT2]) in
      [_ ⊢ cx/refl]
    | [ ⊢ if-lt/f LEQ2] ⇒ impossible suc_lt_contra (lt_leq_trans (leq_suc_lt [ ⊢ LEQ1]) [_ ⊢ LEQ2])
  ;

%------------------------------------------------------%
% Useful corollaries
%------------------------------------------------------%

LF rmv-changeorder : rmv _ _ _ _ _ Δ → rmv Δ _ _ _ _ _ → type =
  rmv-ch : rmv Δ₁ Y B β m' Δ₂' → rmv Δ₂' X A α n' Δ₃
    → if_lt_else m' m (suc n) (suc m) → if_leq_else n' (suc n) m n
    → {RMV1:rmv Δ₁ X A α (suc n) Δ₂} {RMV2:rmv Δ₂ Y B β m Δ₃} rmv-changeorder RMV1 RMV2;

rec rmv_changeorder : (Ψ:vctx) {RMV1:[Ψ ⊢ rmv Δ₁ X A[] α[] n[] Δ₂]} {RMV2:[Ψ ⊢ rmv Δ₂ Y B[] β[] m[] Δ₃]}
→ [Ψ ⊢ rmv-changeorder RMV1 RMV2] =
  mlam RMV1, RMV2 ⇒
  let [_ ⊢ look_i_ife IFLT1[] RMV3] = lookup_weak_idx [_ ⊢ RMV1] [_ ⊢ RMV2] in
  let [ ⊢ is-suc] = lookup_is_suc [_ ⊢ RMV1] in
  let [_ ⊢ look_i_ife IFLT2[] RMV4] = lookup_str_idx [_ ⊢ RMV3] [_ ⊢ RMV1] (iflt_neq [ ⊢ IFLT1]) in
  case ([ ⊢ IFLT1],[ ⊢ IFLT2]) of
  | ([ ⊢ if-lt/t LT1],[ ⊢ if-lt/t LT2]) ⇒ impossible lt_irreflex (lt_trans [ ⊢ LT1] [ ⊢ LT2])
  | ([ ⊢ if-lt/t LT1],[ ⊢ if-lt/f _]) ⇒
    let [_ ⊢ cx/refl] = str_comm_idx [_ ⊢ RMV3] [_ ⊢ RMV4] [_ ⊢ RMV1] [_ ⊢ RMV2] (lt_suc_leq [ ⊢ LT1]) in
    [_ ⊢ rmv-ch RMV3 RMV4 IFLT1[] (if-leq/f LT1[]) RMV1 RMV2]
  | ([ ⊢ if-lt/f LEQ1],[ ⊢ if-lt/t _]) ⇒
    let [_ ⊢ cx/refl] = str_comm_idx [_ ⊢ RMV1] [_ ⊢ RMV2] [_ ⊢ RMV3] [_ ⊢ RMV4] [ ⊢ LEQ1] in
    [_ ⊢ rmv-ch RMV3 RMV4 IFLT1[] (if-leq/t LEQ1[]) RMV1 RMV2]
  | ([ ⊢ if-lt/f LEQ1],[ ⊢ if-lt/f LEQ2]) ⇒ impossible lt_irreflex (leq_suc_lt (leq_trans [ ⊢ LEQ2] [ ⊢ LEQ1]))
  ;

LF rmv-pushout : rmv Δ _ _ _ _ _ → rmv Δ _ _ _ _ _ → type =
  | rmv-po : rmv Δₘ Y B β m' Δ' → rmv Δₙ X A α n' Δ'
    → if_lt_else m' (suc m) (suc n) m → if_lt_else n' (suc n) (suc m) n
    → {RMV1:rmv Δₘₙ X A α (suc n) Δₘ} {RMV2:rmv Δₘₙ Y B β (suc m) Δₙ} rmv-pushout RMV1 RMV2
  ;

rec rmv_pushout_idx : (Ψ:vctx) {RMV1:[Ψ ⊢ rmv Δ X A[] α[] n[] Δ']} {RMV2:[Ψ ⊢ rmv Δ Y B[] β[] m[] Δ'']}
[ ⊢ neq n m] → [Ψ ⊢ rmv-pushout RMV1 RMV2] =
  / total /
  mlam RMV1, RMV2 ⇒ fn NEQ ⇒
  let ([_ ⊢ is-suc],[_ ⊢ is-suc]) = (lookup_is_suc [_ ⊢ RMV1],lookup_is_suc [_ ⊢ RMV2]) in
  let [_ ⊢ look_i_ife IFLT1[] RMV3] = lookup_str_idx [_ ⊢ RMV1] [_ ⊢ RMV2] NEQ in
  let [_ ⊢ look_i_ife IFLT2[] RMV4] = lookup_str_idx [_ ⊢ RMV2] [_ ⊢ RMV1] (neq_comm NEQ) in
  case [ ⊢ IFLT1] of
  | [ ⊢ if-lt/t LT1] ⇒
    (case [_ ⊢ IFLT2] of
    | [ ⊢ if-lt/t LT2] ⇒ impossible lt_irreflex (lt_trans [_ ⊢ LT1] [_ ⊢ LT2])
    | [ ⊢ if-lt/f (leq/lt _)] ⇒
      let [_ ⊢ cx/refl] = str_comm_idx [_ ⊢ RMV2] [_ ⊢ RMV4] [_ ⊢ RMV1] [_ ⊢ RMV3] (lt_suc_leq [ ⊢ LT1]) in
      [_ ⊢ rmv-po RMV3 RMV4 IFLT1[] IFLT2[] _ _]
    | [ ⊢ if-lt/f leq/id] ⇒ impossible neq_irreflex NEQ
    )
  | [ ⊢ if-lt/f (leq/lt LT1)] ⇒
    (case [_ ⊢ IFLT2] of
    | [ ⊢ if-lt/t _] ⇒
      let [_ ⊢ cx/refl] = str_comm_idx [_ ⊢ RMV1] [_ ⊢ RMV3] [_ ⊢ RMV2] [_ ⊢ RMV4] (lt_suc_leq [ ⊢ LT1]) in
      [_ ⊢ rmv-po RMV3 RMV4 IFLT1[] IFLT2[] _ _]
    | [ ⊢ if-lt/f LEQ2] ⇒ impossible lt_irreflex (lt_leq_trans [_ ⊢ LT1] [_ ⊢ LEQ2])
    )
  | [ ⊢ if-lt/f leq/id] ⇒ impossible neq_irreflex NEQ
  ;

rec rmv_pushout : (Ψ:vctx)  {RMV1:[Ψ ⊢ rmv Δ X A[] α[] n[] Δ']} {RMV2:[Ψ ⊢ rmv Δ Y B[] β[] m[] Δ'']}
→ ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) → [Ψ ⊢ rmv-pushout RMV1 RMV2] =
  mlam RMV1, RMV2 ⇒ fn NEQ ⇒
  rmv_pushout_idx [_ ⊢ RMV1] [_ ⊢ RMV2] (lookup_neq_var2nat [_ ⊢ RMV1] [_ ⊢ RMV2] NEQ)
  ;

LF rmv-pullback : rmv _ _ _ _ _ Δ → rmv _ _ _ _ _ Δ → type =
  rmv-pb : rmv Δₘₙ Y B β m' Δₙ → rmv Δₘₙ X A α n' Δₘ
    → if_lt_else n' n m (suc n) → if_leq_else m' m n (suc m)
    → {RMV1:rmv Δₙ X A α n Δ} {RMV2:rmv Δₘ Y B β m Δ} rmv-pullback RMV1 RMV2;

rec rmv_pullback : (Ψ:vctx) {RMV1:[Ψ ⊢ rmv Δₙ X A[] α[] n[] Δ]} {RMV2:[Ψ ⊢ rmv Δₘ Y B[] β[] m[] Δ]}
[Ψ ⊢ rmv-pullback RMV1 RMV2] =
  / total /
  mlam RMV1, RMV2 ⇒
  let [_ ⊢ _]:[_ ⊢ rmv _ X A[] α[] n[] Δ] = [_ ⊢ RMV1] in
  let [_ ⊢ _]:[_ ⊢ rmv _ Y B[] β[] m[] _] = [_ ⊢ RMV2] in
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ] in
  let (LN1,LN2) = (len_weak [_ ⊢ LN] [_ ⊢ RMV1],len_weak [_ ⊢ LN] [_ ⊢ RMV2]) in
  let ([ ⊢ is-suc],[ ⊢ is-suc]) = (lookup_is_suc [_ ⊢ RMV1],lookup_is_suc [_ ⊢ RMV2]) in
  let [ ⊢ LT1] = lt_leq_trans (lt_suc [ ⊢ _]) (len_str_leq LN1 [_ ⊢ RMV1]) in
  let [ ⊢ LT2] = lt_leq_trans (lt_suc [ ⊢ _]) (len_str_leq LN2 [_ ⊢ RMV2]) in
  let [_ ⊢ get-wk RMV3] = get_weak LN1 [ ⊢ leq/lt LT2] [_ ⊢ Y] [ ⊢ B] [ ⊢ β] in
  let [_ ⊢ get-wk RMV4] = get_weak LN2 [ ⊢ leq/lt LT1] [_ ⊢ X] [ ⊢ A] [ ⊢ α] in
  let [_ ⊢ get-wk RMV3_s] = get_weak LN1 (len_str_leq LN2 [_ ⊢ RMV2]) [_ ⊢ Y] [ ⊢ B] [ ⊢ β] in
  let [_ ⊢ get-wk RMV4_s] = get_weak LN2 (len_str_leq LN1 [_ ⊢ RMV1]) [_ ⊢ X] [ ⊢ A] [ ⊢ α] in
  case comp_nats [ ⊢ n] [ ⊢ m] of
  | [ ⊢ comp_names/eq] ⇒
    let [_ ⊢ cx/refl] = weak_comm [_ ⊢ RMV3] [_ ⊢ RMV1] [_ ⊢ RMV4_s] [_ ⊢ RMV2] [ ⊢ leq/id] in
    [_ ⊢ rmv-pb RMV3 RMV4_s (if-lt/f leq/id) (if-leq/t leq/id) RMV1 RMV2]
  | [ ⊢ comp_names/neq (neq/1 LT)] ⇒
    let [_ ⊢ cx/refl] = weak_comm [_ ⊢ RMV4] [_ ⊢ RMV2] [_ ⊢ RMV3_s] [_ ⊢ RMV1] [ ⊢ leq/lt LT] in
    [_ ⊢ rmv-pb RMV3_s RMV4 (if-lt/t LT[]) (if-leq/f LT[]) RMV1 RMV2]
  | [ ⊢ comp_names/neq (neq/2 LT)] ⇒
    let [_ ⊢ cx/refl] = weak_comm [_ ⊢ RMV3] [_ ⊢ RMV1] [_ ⊢ RMV4_s] [_ ⊢ RMV2] [ ⊢ leq/lt LT] in
    [_ ⊢ rmv-pb RMV3 RMV4_s (if-lt/f (leq/lt LT[])) (if-leq/t (leq/lt LT[])) RMV1 RMV2]
  ;

%------------------------------------------------------%
% Manipulating exhausted contexts
%------------------------------------------------------%

% Strengthen `exh` judgment

rec prune_exh : (Ψ:vctx) [Ψ,x:obj ⊢ exh Δ[..]] → [Ψ ⊢ exh Δ] =
  / total 1 /
  fn EXH ⇒
  case EXH of
  | [_,x:obj ⊢ exh/n] ⇒ [_ ⊢ exh/n]
  | [_,x:obj ⊢ exh/c EXH1] ⇒
    let [_ ⊢ EXH2] = prune_exh [_,x:obj ⊢ EXH1] in
    [_ ⊢ exh/c EXH2]
  ;

% Exhausted typing contexts contain no linear elements:

% rec exh_lookup : (Ψ:vctx) [Ψ ⊢ exh Δ] → [Ψ ⊢ rmv Δ X A α[] n Δ'] → [ ⊢ mult_eq α used] =
%   / total 2 /
%   fn EXH, RMV ⇒ case RMV of
%   | [_ ⊢ rmv/t _] ⇒
%     let [_ ⊢ exh/c EXH1] = EXH in
%     [ ⊢ mult/refl]
%   | [_ ⊢ rmv/n RMV1] ⇒
%     let [_ ⊢ exh/c EXH1] = EXH in
%     exh_lookup [_ ⊢ EXH1] [_ ⊢ RMV1]
%   ;

% % Removing elements from a typing context preserves exhaustedness:

% rec exh_str : (Ψ:vctx) [Ψ ⊢ exh Δ] → [Ψ ⊢ rmv Δ X A α n Δ'] → [Ψ ⊢ exh Δ'] =
%   / total 2 /
%   fn EXH, RMV ⇒
%   case RMV of
%   | [_ ⊢ rmv/t LN1] ⇒ let [_ ⊢ exh/c EXH1] = EXH in [_ ⊢ EXH1]
%   | [_ ⊢ rmv/n RMV1] ⇒
%     let [_ ⊢ exh/c EXH1] = EXH in
%     let [_ ⊢ EXH2] = exh_str [_ ⊢ EXH1] [_ ⊢ RMV1] in
%     [_ ⊢ exh/c EXH2]
%   ;

% % Adding elements of multiplicity 0 to typing contexts preserves exhaustedness:

% rec exh_weak : (Ψ:vctx) [Ψ ⊢ exh Δ] → [Ψ ⊢ rmv Δ' X A used n Δ] → [Ψ ⊢ exh Δ'] =
%   / total 2 /
%   fn EXH, RMV ⇒
%   case RMV of
%   | [_ ⊢ rmv/t LN1] ⇒ let [_ ⊢ EXH'] = EXH in [_ ⊢ exh/c EXH']
%   | [_ ⊢ rmv/n RMV1] ⇒
%     let [_ ⊢ exh/c EXH1] = EXH in
%     let [_ ⊢ EXH2] = exh_weak [_ ⊢ EXH1] [_ ⊢ RMV1] in
%     [_ ⊢ exh/c EXH2]
%   ;

% % Adding an element of multiplicity α to and then removing an element of multiplicity α
% % from an exhausted context results in an exhausted context

% rec exh_weakstr : (Ψ:vctx) [Ψ ⊢ exh Δ]
% → [Ψ ⊢ rmv Δ'' X A[] α[] n[] Δ] → [Ψ ⊢ rmv Δ'' Y B[] α[] m[] Δ']
% → [Ψ ⊢ exh Δ'] =
%   / total /
%   fn EXH, RMV1, RMV2 ⇒
%   let [_ ⊢ _]:[_ ⊢ rmv _ _ _ α[] n[] _] = RMV1 in
%   case [ ⊢ α] of
%   | [ ⊢ used] ⇒ exh_str (exh_weak EXH RMV1) RMV2
%   | [ ⊢ lin] ⇒
%     let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ m[] _] = RMV2 in
%     case comp_nats [ ⊢ n] [ ⊢ m] of
%     | [ ⊢ comp_names/eq] ⇒
%       let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx RMV1 RMV2 in
%       EXH
%     | [ ⊢ comp_names/neq NEQ] ⇒
%       let [ ⊢ is-suc] = lookup_is_suc RMV2 in
%       let [_ ⊢ look_i_ife _ RMV3] = lookup_str_idx RMV1 RMV2 [ ⊢ NEQ] in
%       impossible exh_lookup EXH [_ ⊢ RMV3] 
%   ;

%{ - - - - - - - - - - - - - - - - - - - - - - - - - - %
LF var_tp_nat_lctx_eq : obj → obj → tp → tp → nat → nat → lctx → lctx → type =
  var-tp-nat-lctx-refl : var_tp_nat_lctx_eq X X A A n n Δ Δ;

rec unqlin_unq : (Ψ:vctx) [Ψ ⊢ exh Δ]
→ [Ψ ⊢ rmv Δ'' X A[] lin n[] Δ] → [Ψ ⊢ rmv Δ'' X' A'[] lin n'[] Δ']
→ [Ψ ⊢ var_tp_nat_lctx_eq X X' A[] A'[] n[] n'[] Δ Δ'] =
  / total /
  fn EXH, RMV1, RMV2 ⇒
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ n[] _] = RMV1 in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ n'[] _] = RMV2 in
  case comp_nats [ ⊢ n] [ ⊢ n'] of
  | [ ⊢ comp_names/eq] ⇒
    let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx RMV1 RMV2 in
    [_ ⊢ var-tp-nat-lctx-refl]
  | [ ⊢ comp_names/neq NEQ] ⇒
    let [ ⊢ is-suc] = lookup_is_suc RMV2 in
    let [_ ⊢ look_i_ife _ RMV3] = lookup_str_idx RMV1 RMV2 [ ⊢ NEQ] in
    impossible exh_lookup EXH [_ ⊢ RMV3] 
  ;
% - - - - - - - - - - - - - - - - - - - - - - - - - - }%

%------------------------------------------------------%
% Context membership
%------------------------------------------------------%

% Various properties of context membership

rec look_top : (Ψ:vctx) {Δ:[Ψ ⊢ lctx]} [Ψ ⊢ lookup_n X (cons Δ X A[] α[])] =
  mlam Δ ⇒
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ] in
  [_ ⊢ lookn (rmv/t LN)]
  ;

rec notin_contra : (Ψ:vctx) [Ψ,x:obj ⊢ lookup_n x Δ[..]] → [ ⊢ false] =
  / total /
  fn LK ⇒
  let [_,x:obj ⊢ lookn RMV1] = LK in
  let Prune-Rmv [_ ⊢ _] [_,x:obj ⊢ EQ] [_ ⊢ _] [_,x:obj ⊢ _] = prune_rmv [_ ⊢ RMV1] in
  impossible [_,x:obj ⊢ EQ]
  ;

rec notin_swap : (Ψ:vctx) ([Ψ,x:obj,y:obj ⊢ lookup_n X Δ] → [ ⊢ false])
→ ([Ψ,y:obj,x:obj ⊢ lookup_n X[..,x,y] Δ[..,x,y]] → [ ⊢ false]) =
  / total /
  fn NIN, LK ⇒ let [_,x:obj,y:obj ⊢ LK'] = LK in NIN [_,x:obj,y:obj ⊢ LK'[..,y,x]]
  ;

rec notin_nil : (Ψ:vctx) [Ψ ⊢ lookup_n X nil] → [ ⊢ false] =
  / total /
  fn LK ⇒
  let [_ ⊢ lookn RMV] = LK in impossible [_ ⊢ RMV]
  ;

rec notin_to_nmeq : (Ψ:vctx) ([Ψ ⊢ lookup_n Y Δ] → [ ⊢ false]) → [Ψ ⊢ rmv Δ X A[] α[] n[] Δ']
→ ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) =
  / total /
  fn NIN, RMV, EQ ⇒
  let ([_ ⊢ RMV1],[_ ⊢ obj/refl]) = (RMV,EQ) in
  NIN [_ ⊢ lookn RMV1]
  ;

rec notin_peel : (Ψ:vctx) ([Ψ ⊢ lookup_n X (cons Δ Y B[] β[])] → [ ⊢ false]) → ([Ψ ⊢ lookup_n X Δ] → [ ⊢ false]) =
  / total /
  fn NIN, LK ⇒
  let [_ ⊢ lookn RMV] = LK in
  impossible NIN [_ ⊢ lookn (rmv/n RMV)]
  ;

rec notin_prune : (Ψ:vctx) ([Ψ,x:obj ⊢ lookup_n X[..] Δ[..]] → [ ⊢ false]) → [Ψ ⊢ lookup_n X Δ] → [ ⊢ false] =
  / total /
  fn NIN, LK ⇒
  let [_,x:obj ⊢ lookn RMV] = LK in
  NIN [_,x:obj,y:obj ⊢ lookn RMV[..,x]]
  ;

rec notin_rmv : (Ψ:vctx) ([Ψ ⊢ lookup_n X Δ] → [ ⊢ false]) → [Ψ ⊢ rmv Δ Y B[] β[] n[] Δ'] → ([Ψ ⊢ lookup_n X Δ'] → [ ⊢ false]) =
  / total /
  fn NIN, RMV, LK ⇒
  let [_ ⊢ lookn RMV1] = LK in
  let [_ ⊢ look RMV2] = lookup_weak RMV [_ ⊢ RMV1] in
  NIN [_ ⊢ lookn RMV2]
  ;

rec notin_weak : (Ψ:vctx) ([Ψ ⊢ lookup_n X Δ] → [ ⊢ false]) → [Ψ ⊢ rmv Δ' Y B[] β[] m[] Δ]
→ ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) → ([Ψ ⊢ lookup_n X Δ'] → [ ⊢ false]) =
  / total /
  fn NIN, RMV, NEQ, LK ⇒
  let [_ ⊢ lookn RMV1] = LK in
  let [_ ⊢ look RMV2] = lookup_str RMV [_ ⊢ RMV1] (neq_comm_v NEQ) in
  NIN [_ ⊢ lookn RMV2]
  ;

rec notin_wf_weak : Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv Δ X A α n Δ'] → ([Ψ ⊢ lookup_n X Δ'] → [ ⊢ false]) =
  / total 2 /
  fn WF, RMV ⇒ case RMV of
  | [_ ⊢ rmv/t _] ⇒ let Wf/c WF1 NIN = WF in NIN
  | [_ ⊢ rmv/n RMV1]:[_ ⊢ rmv _ _ _ _ _ (cons Δ' _ _ _)] ⇒
    let Wf/c WF1 NIN = WF in
    let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ'] in
    notin_weak (notin_wf_weak WF1 [_ ⊢ RMV1]) [_ ⊢ rmv/t LN] (notin_to_nmeq NIN [_ ⊢ RMV1])
  ;

%{ - - - - - - - - - - - - - - - - - - - - - - - - - - %
rec notin_upd : [Ψ ⊢ upd Δ X Y A B α β Δ'] → Wf [Ψ ⊢ Δ] → ([Ψ ⊢ obj_eq X Y] → [ ⊢ false]) → ([Ψ ⊢ lookup_n X Δ'] → [ ⊢ false]) =
  / total 1 /
  fn UPD, WF, NEQ, LK ⇒ ?
  ;

rec notin_exch : ([Ψ ⊢ lookup_n X Δ] → [ ⊢ false]) → [Ψ ⊢ exch Δ Y Z Δ'] → Wf [Ψ ⊢ Δ] → ([Ψ ⊢ lookup_n X Δ'] → [ ⊢ false]) =
  / total 1 /
  fn LK, EXC, WF, LK ⇒ ?
  ;
% - - - - - - - - - - - - - - - - - - - - - - - - - - }%

rec notin_changenat : (Ψ:vctx) ([Ψ ⊢ lookup_n X Δ] → [ ⊢ false])
→ [Ψ ⊢ rmv Δ'' Y B[] β[] n[] Δ] → [Ψ ⊢ rmv Δ'' Y B[] β[] m[] Δ'] → ([Ψ ⊢ lookup_n X Δ'] → [ ⊢ false]) =
  / total /
  fn NIN, RMV1, RMV2, LK ⇒
  let [_ ⊢ lookn RMV]:[_ ⊢  lookup_n X _] = LK in
  let [_ ⊢ RMV1']:[_ ⊢ rmv _ Y _ _ n[] _] = RMV1 in
  let [_ ⊢ RMV2']:[_ ⊢ rmv _ Y _ _ m[] _] = RMV2 in
  let [_ ⊢ rmv-ch RMV3 RMV4 _ _ _ _] = rmv_changeorder [_ ⊢ RMV2'] [_ ⊢ RMV] in
  case comp_nats [ ⊢ n] [ ⊢ m] of
  | [ ⊢ comp_names/eq] ⇒ let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx RMV1 RMV2 in  NIN LK
  | [ ⊢ comp_names/neq NEQ1] ⇒
    let [ ⊢ is-suc]:[ ⊢ is_suc (suc k')] = lookup_is_suc [_ ⊢ RMV3] in
    case comp_nats [ ⊢ n] [ ⊢ suc k'] of
    | [ ⊢ comp_names/eq] ⇒
      let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx RMV1 [_ ⊢ RMV3] in
      NIN [_ ⊢ lookn RMV4]
    | [ ⊢ comp_names/neq NEQ2] ⇒
      let [_ ⊢ look_i_ife _ RMV5] = lookup_str_idx [_ ⊢ RMV1'] [_ ⊢ RMV3] [ ⊢ NEQ2] in
      NIN [_ ⊢ lookn RMV5]
  ;

% 'Prune' LF context to remove dependencies: obtain from [Ψ,x:obj ⊢ rmv Δ x Δ'] that Δ' cannot depend on x if Δ is well-formed

inductive PruneCtx : (Ψ:vctx) {Δ:[Ψ,x:obj ⊢ lctx]} ctype =
  | Prune-Ctx : [Ψ,x:obj ⊢ cx_eq Δ Δ'[..]] → PruneCtx [Ψ,x:obj ⊢ Δ];

rec notin_prunectx : {Δ:[Ψ,x:obj ⊢ lctx]} ([Ψ,x:obj ⊢ lookup_n x Δ] → [ ⊢ false]) → PruneCtx [Ψ,x:obj ⊢ Δ] =
  / total 1 /
  mlam Δ ⇒ fn NIN ⇒
  case [_,x:obj ⊢ Δ] of
  | [_,x:obj ⊢ nil] ⇒ Prune-Ctx [_ ⊢ cx/refl]
  | [_,x:obj ⊢ cons Δ' X A[] α[]] ⇒
    let Prune-Ctx [_ ⊢ cx/refl] = notin_prunectx [_,x:obj ⊢ Δ'] (notin_peel NIN) in
    let [_,x:obj ⊢ get-len LN] = get_len [_,x:obj ⊢ Δ'] in
    let Prune-Obj = prune_obj [_,x:obj ⊢ _] (notin_to_nmeq NIN [_ ⊢ rmv/t LN]) in
    Prune-Ctx [_ ⊢ cx/refl]
  ;

%------------------------------------------------------%
% Useful corollaries
%------------------------------------------------------%

LF tp_mult_lctx_eq : tp → tp → mult → mult → lctx → lctx → type =
  tp-mult-lctx-refl : tp_mult_lctx_eq A A α α Δ Δ;

% @TODO: use more (replace wherever use `impossible notin_contra [_,x:obj ⊢ lookn RMV1']` or the like)
rec rmv_istop : (Ψ:vctx) [Ψ,x:obj ⊢ rmv (cons Δ[..] x A[] α[]) x B[] β[] n[] Δ']
→ [Ψ,x:obj ⊢ tp_mult_lctx_eq A[] B[] α[] β[] Δ[..] Δ'] =
  / total /
  fn RMV ⇒ case RMV of
  | [_,x:obj ⊢ rmv/t _] ⇒ [_,x:obj ⊢ tp-mult-lctx-refl]
  | [_,x:obj ⊢ rmv/n RMV1] ⇒ impossible notin_contra [_,x:obj ⊢ lookn RMV1]
  ;

%------------------------------------------------------%
% Pruning lemmata II
%------------------------------------------------------%

rec prune_rmv_cx : [Ψ,x:obj ⊢ rmv Δ x A α n Δ'] → Wf [Ψ,x:obj ⊢ Δ] → PruneCtx [Ψ,x:obj ⊢ Δ'] =
  / total 1 /
  fn RMV, WF ⇒ case RMV of
  | [_,x:obj ⊢ rmv/t _] ⇒
    let Wf/c WF1 NIN = WF in
    notin_prunectx [_,x:obj ⊢ _] NIN
  | [_,x:obj ⊢ rmv/n RMV1] ⇒
    let Wf/c WF1 NIN = WF in
    let Prune-Ctx [_ ⊢ cx/refl] = prune_rmv_cx [_,x:obj ⊢ RMV1] WF1 in
    let Prune-Obj = prune_obj [_,x:obj ⊢ _] (neq_comm_v (notin_to_nmeq NIN [_,x:obj ⊢ RMV1])) in
    Prune-Ctx [_ ⊢ cx/refl]
  ;

rec notin_ext : (Ψ:vctx) ([Ψ ⊢ lookup_n X Δ] → [ ⊢ false]) → ([Ψ,x:obj ⊢ lookup_n X[..] Δ[..]] → [ ⊢ false]) =
  / total /
  fn NIN, LK ⇒
  let [_,x:obj ⊢ lookn RMV1] = LK in
  let Prune-Rmv [_ ⊢ cx/refl] [_,x:obj ⊢ obj/refl] [_ ⊢ RMV2] [_,x:obj ⊢ _] = prune_rmv [_ ⊢ RMV1] in
  NIN [_ ⊢ lookn RMV2]
  ;

%------------------------------------------------------%
% Context well-formedness
%------------------------------------------------------%

inductive IsVar : (Ψ:vctx) [Ψ ⊢ var] → ctype =
  | Is-Var : IsVar [Ψ ⊢ #p];

rec wf_isvar : (Ψ:vctx) Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv Δ X A[] α[] n[] Δ'] → IsVar [Ψ ⊢ X] =
  / total 2 /
  fn wf, rm ⇒ case rm of
  | [_ ⊢ rmv/t LN] ⇒ let Wf/c _ _ = wf in Is-Var
  | [_ ⊢ rmv/n RMV1] ⇒ let Wf/c WF1 _ = wf in wf_isvar WF1 [_ ⊢ RMV1]
  ;

% Various properties of context well-formedness condition

rec wf_ext : Wf [Ψ ⊢ Δ] → Wf [Ψ,x:obj ⊢ Δ[..]] =
  / total 1 /
  fn WF ⇒
  case WF of
  | Wf/n ⇒ Wf/n
  | Wf/c WF1 NIN ⇒ let WF2 = wf_ext WF1 in Wf/c WF2 (notin_ext NIN)
  ;

rec wf_prune : Wf [Ψ,x:obj ⊢ Δ[..]] → Wf [Ψ ⊢ Δ] =
  / total 1 /
  fn WF ⇒
  case WF of
  | Wf/n ⇒ Wf/n
  | Wf/c WF1 NIN ⇒ let WF2 = wf_prune WF1 in Wf/c WF2 (notin_prune NIN)
  ;

rec wf_swap : Wf [Ψ,x:obj,y:obj ⊢ Δ] → Wf [Ψ,y:obj,x:obj ⊢ Δ[..,x,y]] =
  / total 1 /
  fn WF ⇒ case WF of
  | Wf/n ⇒ Wf/n
  | Wf/c WF1 NIN ⇒ Wf/c (wf_swap WF1) (notin_swap NIN)
  ;

rec wf_extcons : Wf [Ψ ⊢ Δ] → Wf [Ψ,x:obj ⊢ cons Δ[..] x A[] α[]] =
  / total /
  fn WF ⇒
  case WF of
  | Wf/n ⇒ Wf/c Wf/n notin_nil
  | Wf/c WF1 NIN ⇒ Wf/c (wf_ext WF) notin_contra
  ;

rec wf_str : Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv Δ X A α n Δ'] → Wf [Ψ ⊢ Δ'] =
  / total 2 /
  fn WF, RMV ⇒ case RMV of
  | [_ ⊢ rmv/t _] ⇒ let Wf/c WF1 NIN = WF in WF1
  | [_ ⊢ rmv/n RMV1] ⇒
    let Wf/c WF1 NIN = WF in
    Wf/c (wf_str WF1 [_ ⊢ RMV1]) (notin_rmv NIN [_ ⊢ RMV1])
  ;

rec wf_weak : Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv Δ' #p A α n Δ] → ([Ψ ⊢ lookup_n #p Δ] → [ ⊢ false]) → Wf [Ψ ⊢ Δ'] =
  / total 2 /
  fn WF, RMV, NIN ⇒
  case RMV of
  | [_ ⊢ rmv/t _] ⇒ Wf/c WF NIN
  | [_ ⊢ rmv/n RMV1] ⇒
    let Wf/c WF1 NIN1 = WF in
    let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ _ (cons Δ X A[] α[])] = RMV in
    let [_ ⊢ rmv-t RMV2 LN1] = get_str_top [_ ⊢ Δ] [_ ⊢ X] [ ⊢ A] [ ⊢ α] in
    Wf/c (wf_weak WF1 [_ ⊢ RMV1] (notin_peel NIN)) (notin_weak NIN1 [_ ⊢ RMV1] (notin_to_nmeq NIN [_ ⊢ RMV2]))
  ;

rec wf_weak_cor : Wf [Ψ ⊢ Δ] → [Ψ,x:obj ⊢ rmv Δ' x A α n Δ[..]] → Wf [Ψ,x:obj ⊢ Δ'] =
  fn WF, RMV ⇒
  wf_weak (wf_ext WF) RMV notin_contra
  ;

%{ - - - - - - - - - - - - - - - - - - - - - - - - - - %
rec wf_upd : Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv Δ X A α n Δ''] → [Ψ ⊢ rmv Δ' X B β n Δ''] → Wf [Ψ ⊢ Δ'] =
  / total /
  fn WF, RMV1, RMV2 ⇒ wf_weak (wf_str WF RMV1) RMV2 (notin_wf_weak WF RMV1)
  ;

rec wf_upd_neq : Wf [Ψ ⊢ Δ] → [Ψ ⊢ upd Δ X Y A B α β Δ'] → ([Ψ ⊢ lookup_n Y Δ] → [ ⊢ false]) → Wf [Ψ ⊢ Δ'] =
  / total 1 /
  fn WF, UPD, NIN ⇒
  ?
  ;
% - - - - - - - - - - - - - - - - - - - - - - - - - - }%

rec wf_weakstr : Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv Δ'' #p A α n[] Δ] → [Ψ ⊢ rmv Δ'' #p A α m[] Δ'] → Wf [Ψ ⊢ Δ'] =
  / total /
  fn WF, RMV1, RMV2 ⇒
  let [_ ⊢ RMV1']:[_ ⊢ rmv _ _ _ _ n[] _] = RMV1 in
  let [_ ⊢ RMV2']:[_ ⊢ rmv _ _ _ _ m[] _] = RMV2 in
  case comp_nats [ ⊢ n] [ ⊢ m] of
  | [ ⊢ comp_names/eq] ⇒ let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx RMV1 RMV2 in WF
  | [ ⊢ comp_names/neq NEQ] ⇒
    let [_ ⊢ rmv-po RMV3 RMV4 _ _ _ _] = rmv_pushout_idx [_ ⊢ RMV1'] [_ ⊢ RMV2'] [ ⊢ NEQ] in
    wf_weak (wf_str WF [_ ⊢ RMV3]) [_ ⊢ RMV4] (notin_wf_weak WF [_ ⊢ RMV3])
  ;

rec wf_exch : Wf [Ψ ⊢ Δ] → [Ψ ⊢ exch Δ X #q Δ'] → Wf [Ψ ⊢ Δ'] =
  / total /
  fn WF, EX ⇒
  let [_ ⊢ exchg RMVx1 RMVy1 RMVy2 RMVx2] = EX in
  let Is-Var = wf_isvar WF [_ ⊢ RMVx1] in
  let WF1 = wf_weakstr (wf_str WF [_ ⊢ RMVx1]) [_ ⊢ RMVy1] [_ ⊢ RMVy2] in
  let NIN1 = notin_changenat (notin_wf_weak WF [_ ⊢ RMVx1]) [_ ⊢ RMVy1] [_ ⊢ RMVy2] in
  wf_weak WF1 [_ ⊢ RMVx2] NIN1
  ;

%------------------------------------------------------%
% Exchange
%------------------------------------------------------%

%{
Δ  ⇢ Δₘ' ⇠ Δ'''
↓     ⇣     ⇣
Δₙ  ⇢ Δₙₘ ⇠ Δₙ'
↑     ⇡     ⇡
Δ'' → Δₘ ← Δ'
}%

%{ - - - - - - - - - - - - - - - - - - - - - - - - - - %
LF exch_exp : rmv _ _ _ _ _ _ → rmv _ _ _ _ _ _ → rmv _ _ _ _ _ _ → rmv _ _ _ _ _ _ → type =
  | exch-ext :
    rmv Δ Y B β m'' Δₘ' → rmv Δₘ' X A α n'' Δₙₘ → if_eq_else m'' m n (suc m) → if_leq_else n'' (suc n) m n
    → rmv Δₙ Y B β m' Δₙₘ → rmv Δₘ Y B β n' Δₙₘ → if_lt_else m' (suc m) (suc n) m → if_lt_else n' (suc n) (suc m) n
    → rmv Δ' Y B β n''' Δₙ' → rmv Δₙ' X A α m''' Δₙₘ → if_eq_else n''' n m (suc n) → if_leq_else m''' (suc m) n m
    → rmv Δ''' X A α mᶦ Δₘ' → rmv Δ''' X A α nᶦ Δₙ' → if_neq_else nᶦ (suc n) m (suc (suc n)) → if_eq2_else mᶦ m n (suc n) (suc m)
    → {RMVx1:rmv Δ X A α (suc n) Δₙ} {RMVy1:rmv Δ'' Y B β (suc n) Δₙ}
      {RMVy2:rmv Δ'' Y B β (suc m) Δₘ} {RMVx2:rmv Δ' X A α (suc m) Δₘ}
    exch_exp RMVx1 RMVy1 RMVy2 RMVx2;
  
rec exch_expand : (Ψ:vctx) {RMVx1:[Ψ ⊢ rmv Δ X A[] α[] n[] Δₙ]} {RMVy1:[Ψ ⊢ rmv Δ'' Y B[] β[] n[] Δₙ]}
{RMVy2:[Ψ ⊢ rmv Δ'' Y B[] β[] m[] Δₘ]} {RMVx2:[Ψ ⊢ rmv Δ' X A[] α[] m[] Δₘ]}
[ ⊢ neq n m] → [_ ⊢ exch_exp RMVx1 RMVy1 RMVy2 RMVx2] =
  / total /
  mlam RMVx1, RMVy1, RMVy2, RMVx2 ⇒ fn NEQ ⇒
  let [_ ⊢ rmv-po RMV1 RMV2 IFLT1[] IFLT2[] _ _] = rmv_pushout_idx [_ ⊢ RMVy1] [_ ⊢ RMVy2] NEQ in
  let [_ ⊢ rmv-ch RMV3 RMV4 IFLT3[] IFLT4[] _ _] = rmv_changeorder [_ ⊢ RMVx1] [_ ⊢ RMV1] in
  let [_ ⊢ rmv-ch RMV5 RMV6 IFLT5[] IFLT6[] _ _] = rmv_changeorder [_ ⊢ RMVx2] [_ ⊢ RMV2] in
  let [_ ⊢ rmv-pb RMV7 RMV8 IFLT7[] IFLT8[] _ _] = rmv_pullback [_ ⊢ RMV4] [_ ⊢ RMV6] in
  case ([ ⊢ IFLT1],[ ⊢ IFLT2]) of
  | ([ ⊢ if-lt/t LT1],[ ⊢ if-lt/t LT2]) ⇒ impossible lt_irreflex (lt_trans [ ⊢ LT1] [ ⊢ LT2])
  | ([ ⊢ if-lt/t LT1],[ ⊢ if-lt/f _]) ⇒
    let [ ⊢ nat/refl] = iflt_t [ ⊢ IFLT3] [ ⊢ LT1] in
    let [ ⊢ nat/refl] = ifleq_f [ ⊢ IFLT4] [ ⊢ LT1] in
    (case [ ⊢ IFLT5] of
    | [ ⊢ if-lt/t LT5] ⇒ impossible nats_discrete [ ⊢ LT5] [ ⊢ LT1]
    | [ ⊢ if-lt/f LEQ5] ⇒
      let [ ⊢ nat/refl] = ifleq_t [ ⊢ IFLT6] [ ⊢ LEQ5] in
      let [ ⊢ nat/refl] = iflt_f [ ⊢ IFLT7] [_ ⊢ LEQ5] in
      let [ ⊢ nat/refl] = ifleq_t [ ⊢ IFLT8] [_ ⊢ LEQ5] in
      let [ ⊢ lt/s LT1'] = [ ⊢ LT1] in
      let [ ⊢ LT1''] = lt_trans (lt_suc [ ⊢ _]) [ ⊢ LT1] in
      [_ ⊢ exch-ext RMV3 RMV4 (if-eq/f (neq/1 LT1'[])) (if-leq/f LT1''[]) RMV1 RMV2 IFLT1[] IFLT2[] RMV5 RMV6 (if-eq/f (neq/2 LT1'[])) IFLT6[] RMV7 RMV8 (if-neq/t (neq/2 LT1''[])) (if-eq2/f (neq/1 LT1'[]) (neq/1 LT1''[])) _ _ _ _]
    )
  | ([ ⊢ if-lt/f _],[ ⊢ if-lt/t LT2]) ⇒
    let [ ⊢ nat/refl] = iflt_t [ ⊢ IFLT5] [ ⊢ LT2] in
    let [ ⊢ nat/refl] = ifleq_f [ ⊢ IFLT6] [ ⊢ LT2] in
    let [ ⊢ lt/s LT2'] = [ ⊢ LT2] in
    (case [ ⊢ IFLT3] of
    | [ ⊢ if-lt/t LT3] ⇒ impossible nats_discrete [ ⊢ LT2'] [ ⊢ LT3]
    | [ ⊢ if-lt/f LEQ3] ⇒
      let [ ⊢ nat/refl] = ifleq_t [ ⊢ IFLT4] [ ⊢ LEQ3] in
      let [ ⊢ LT2''] = lt_trans (lt_suc [ ⊢ _]) [ ⊢ LT2] in
      (case [ ⊢ LEQ3] of
      | [ ⊢ leq/id] ⇒
        let [ ⊢ nat/refl] = iflt_f [ ⊢ IFLT7] [ ⊢ leq/id] in
        let [ ⊢ nat/refl] = ifleq_t [ ⊢ IFLT8] [ ⊢ leq/id] in
        [_ ⊢ exch-ext RMV3 RMV4 (if-eq/f (neq/2 LT2'[])) IFLT4[] RMV1 RMV2 IFLT1[] IFLT2[] RMV5 RMV6 (if-eq/f (neq/1 LT2'[])) (if-leq/f LT2''[]) RMV7 RMV8 if-neq/f if-eq2/t2 _ _ _ _]
      | [ ⊢ leq/lt LT3] ⇒
        let [ ⊢ nat/refl] = iflt_t [ ⊢ IFLT7] [ ⊢ LT3] in
        let [ ⊢ nat/refl] = ifleq_f [ ⊢ IFLT8] [ ⊢ LT3] in
        [_ ⊢ exch-ext RMV3 RMV4 (if-eq/f (neq/2 LT2'[])) IFLT4[] RMV1 RMV2 IFLT1[] IFLT2[] RMV5 RMV6 (if-eq/f (neq/1 LT2'[])) (if-leq/f LT2''[]) RMV7 RMV8 (if-neq/t (neq/1 LT3[])) (if-eq2/f (neq/2 LT2'[]) (neq/2 LT3[])) _ _ _ _]
      )
    )
  | ([ ⊢ if-lt/f LEQ1],[ ⊢ if-lt/f LEQ2]) ⇒
    let [ ⊢ nat/refl] = leq_eq [ ⊢ LEQ1] [ ⊢ LEQ2] in
    impossible neq_irreflex NEQ
  ;
% - - - - - - - - - - - - - - - - - - - - - - - - - - }%

% Δ[X ↔ X] = Δ

rec exch_id : [Ψ ⊢ exch Δ X X Δ'] → Wf [Ψ ⊢ Δ] → [Ψ ⊢ cx_eq Δ Δ'] =
  / total /
  fn ex1, wf ⇒
  let [_ ⊢ exchg RMV1x RMV1y RMV2y RMV2x] = ex1 in
  let Is-Var = wf_isvar wf [_ ⊢ RMV1x] in
  let [_ ⊢ tp-mult-nat-lctx-refl] = str_runq [_ ⊢ RMV1y] [_ ⊢ RMV2y] 
    (wf_weak (wf_str wf [_ ⊢ RMV1x]) [_ ⊢ RMV1y] (notin_wf_weak wf [_ ⊢ RMV1x])) in
  str_lunq [_ ⊢ RMV1x] [_ ⊢ RMV2x]
  ;

% If (X :^α A) ∈ Δ, then (X :^α A) ∈ Δ[Y ↔ Z]

rec exch_lookup : (Ψ:vctx) {RMV:[Ψ ⊢ rmv Δ X A[] α[] n[] Δ'']} {EX:[Ψ ⊢ exch Δ Y Z Δ']}
[Ψ ⊢ lookup X A[] α[] Δ'] =
  / total /
  mlam RMV, EX ⇒
  let [_ ⊢ exchg RMVx1 RMVy1 RMVy2 RMVx2] = [_ ⊢ EX] in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ n[] _] = [_ ⊢ RMVy1] in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ m[] _] = [_ ⊢ RMVy2] in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ k[] _] = [_ ⊢ RMV] in
  case comp_nats [ ⊢ n] [ ⊢ m] of
  | [ ⊢ comp_names/eq] ⇒
    let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ ⊢ RMVy1] [_ ⊢ RMVy2] in
    let [_ ⊢ cx/refl] = str_lunq [_ ⊢ RMVx1] [_ ⊢ RMVx2] in
    [_ ⊢ look RMV]
  | [ ⊢ comp_names/neq NEQ1] ⇒
    case comp_nats [ ⊢ n] [ ⊢ k] of
    | [ ⊢ comp_names/eq] ⇒
      let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ ⊢ RMVx1] [_ ⊢ RMV] in
      [_ ⊢ look RMVx2]
    | [ ⊢ comp_names/neq NEQ2] ⇒
      let [ ⊢ is-suc] = lookup_is_suc [_ ⊢ RMV] in
      let [_ ⊢ look_i_ife _ RMV1] = lookup_str_idx [_ ⊢ RMVx1] [_ ⊢ RMV] [ ⊢ NEQ2] in
      let [_ ⊢ look_i_ife _ RMV2] = lookup_weak_idx [_ ⊢ RMVy1] [_ ⊢ RMV1] in
      let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ k''[] _] = [_ ⊢ RMV2] in
      case comp_nats [ ⊢ m] [ ⊢ k''] of
      | [ ⊢ comp_names/eq] ⇒
        let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ ⊢ RMVy2] [_ ⊢ RMV2] in
        let [ ⊢ is-suc] = lookup_is_suc [_ ⊢ RMVy1] in
        let [_ ⊢ look_i_ife _ RMV3] = lookup_str_idx [_ ⊢ RMVy2] [_ ⊢ RMVy1] (neq_comm [ ⊢ NEQ1]) in
        let [_ ⊢ look_i_ife _ RMV4] = lookup_weak_idx [_ ⊢ RMVx2] [_ ⊢ RMV3] in
        [_ ⊢ look RMV4]
      | [ ⊢ comp_names/neq NEQ3] ⇒
        let [ ⊢ is-suc] = lookup_is_suc [_ ⊢ RMV2] in
        let [_ ⊢ look_i_ife _ RMV3] = lookup_str_idx [_ ⊢ RMVy2] [_ ⊢ RMV2] [ ⊢ NEQ3] in
        let [_ ⊢ rmv-ch RMV4 _ _ _ _ _] = rmv_changeorder [_ ⊢ RMVx2] [_ ⊢ RMV3] in
        [_ ⊢ look RMV4]
  ;

% If exh(Δ), then exh(Δ[X ↔ Y])

%{ - - - - - - - - - - - - - - - - - - - - - - - - - - %
rec exch_exh : (Ψ:vctx) [Ψ ⊢ exch Δ X Y Δ'] → [Ψ ⊢ exh Δ] → [Ψ ⊢ exh Δ'] =
  fn ex1, exh1 ⇒
  let [_ ⊢ exchg RMVx1 RMVy1 RMVy2 RMVx2]:[_ ⊢ exch _ X Y _] = ex1 in
  let [ ⊢ mult/refl] = exh_lookup exh1 [_ ⊢ RMVx1] in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ n[] _] = [_ ⊢ RMVx1] in
  let [_ ⊢ _]:[_ ⊢ rmv _ _ _ _ m[] _] = [_ ⊢ RMVx2] in
  case comp_nats [ ⊢ n] [ ⊢ m] of
  | [ ⊢ comp_names/eq] ⇒
    let [_ ⊢ var-tp-mult-nat-lctx-refl] = str_runq_idx [_ ⊢ RMVy1] [_ ⊢ RMVy2] in
    let [_ ⊢ cx/refl] = str_lunq [_ ⊢ RMVx1] [_ ⊢ RMVx2] in
    exh1
  | [ ⊢ comp_names/neq NEQ] ⇒
    let [_ ⊢ exch-ext RMV1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _] = exch_expand [_ ⊢ RMVx1] [_ ⊢ RMVy1] [_ ⊢ RMVy2] [_ ⊢ RMVx2] [ ⊢ NEQ] in
    let [ ⊢ mult/refl] = exh_lookup exh1 [_ ⊢ RMV1] in
    exh_weak (exh_str (exh_weak (exh_str exh1 [_ ⊢ RMVx1]) [_ ⊢ RMVy1]) [_ ⊢ RMVy2]) [_ ⊢ RMVx2]
  ;
% - - - - - - - - - - - - - - - - - - - - - - - - - - }%
