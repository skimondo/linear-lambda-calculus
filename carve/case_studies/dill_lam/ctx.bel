
% Linear contexts as lists of atoms and resource annotations
% DZ: arbitrary atoms or `hy x A`'s?

LF lctx : type =
| nil : lctx
| cons : lctx → atm → mult → lctx;

LF cx_eq : lctx → lctx → type = cx/refl : cx_eq Δ Δ;

% `Unrestricted` qualifier

%{
LF unr_pair : atm → mult → type =
| up/u : {A:atm} unr_pair A 𝟘
| up/ω : {A:atm} unr_pair A ω; % intuit assums
%| up/d : {X:name} unr_pair (hy X done) 𝟙
}%

LF unr : lctx → type =
| un/n : unr nil
| un/c : unr Δ → mult_neq α lin → unr (cons Δ A α);

% Splitting / merging linear contexts: Δ₁ ⋈ Δ₂ = Δ

LF merge : lctx → lctx → lctx → type =
| mg/n : merge nil nil nil
| mg/c : merge Δ₁ Δ₂ Δ → • α₁ α₂ α → merge (cons Δ₁ A α₁) (cons Δ₂ A α₂) (cons Δ A α);

% Lookup and remove an element from a linear context

LF rmv : lctx → atm → mult → lctx → type =
| rmv/t : rmv (cons Δ A α) A α Δ
| rmv/n : rmv Δ A α Δ' → rmv (cons Δ B β) A α (cons Δ' B β);

% Context well-formedness

false : type.

inductive Wf : (Ψ:ictx) {Δ:[Ψ ⊢ lctx]} ctype =
| Wf/n : Wf [Ψ ⊢ nil]
| Wf/c : Wf [Ψ ⊢ Δ] → ([Ψ ⊢ lookup_name #p Δ] → [ ⊢ false]) → Wf [Ψ ⊢ cons Δ (hy #p A[]) _];

inductive Wf_lin : (Ψ:ictx) {Δ:[Ψ ⊢ lctx]} ctype =
| Wfl/n : Wf_lin [Ψ ⊢ nil]
| Wfl/c : Wf_lin [Ψ ⊢ Δ] → ([Ψ ⊢ lookup_name #p Δ] → [ ⊢ false]) → [ ⊢ mult_neq α ω] → Wf_lin [Ψ ⊢ cons Δ (hy #p A[]) α[]];
