%======================================================%
% Lemmas
%======================================================%

%------------------------------------------------------%
% Structural properties of typing judgment
%------------------------------------------------------%

% Exchange lemma:
% If ฮ โข M : A and ฮ[(n, x) โ (m, y)] = ฮ', then ฮ' โข M : A

rec oft_exch : (ฮจ:ctx) (ฮ:[ฮจ โข lctx k[]]) [ฮจ โข oft ฮ M A] โ [ฮจ โข exch ฮ n X m Y ฮ']
โ [ฮจ โข oft ฮ' M A] =
  / total 1 /
  fn oft1, ex1 โ
  let [_ โข exch/u NEQ[] U1 U2] = ex1 in
  case oft1 of
  | [_ โข oft/var U3 E1] โ
    let [_ โข exch-e EX1' EX2' U4 IF1 IF2 _ _ _] = exch_upd [ โข NEQ] [_ โข U1] [_ โข U2] [_ โข U3] in
    let [_ โข E2] = exch_exh [_ โข E1] [_ โข exch/u NEQ[] EX1' EX2'] in
    [_ โข oft/var U4 E2]
  | [_ โข oft/lam \x.O1] โ
    let [_,x:obj โข O2] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n U1[..]) (upd/n U2[..])] in
    [_ โข oft/lam \x.O2]
  | [_ โข oft/app O1 O2 M1] โ
    let [_ โข exch-mg U1a U2a U1b U2b _ M2 _ _ _ _ _] = exch_merge [_ โข U1] [_ โข U2] [_ โข M1] in
    let [_ โข O1'] = oft_exch [_ โข O1] [_ โข exch/u NEQ[] U1a U2a] in
    let [_ โข O2'] = oft_exch [_ โข O2] [_ โข exch/u NEQ[] U1b U2b] in
    [_ โข oft/app O1' O2' M2]
  ;

rec oft_exch_top : (ฮจ:ctx) (ฮ:[ฮจ โข lctx k[]]) [ฮจ โข oft (cons (cons ฮ Y B[] ฮฒ[]) Z C[] ฮณ[]) M A]
โ [ฮจ โข oft (cons (cons ฮ Z C[] ฮณ[]) Y B[] ฮฒ[]) M A] =
  / total /
  fn oft1 โ oft_exch oft1 (exch_top [_ โข _] [_ โข _] [ โข _] [ โข _] [_ โข _] [ โข _] [ โข _])
  ;

% Strengthening lemma:
% If ฮ, x :โฐ B โข M : A, then (1) M does not depend on x and (2) ฮ โข M : A 

inductive StrTop: (ฮจ:ctx) (ฮ:[ฮจ โข lctx k[]]) {O:[ฮจ โข oft ฮ M A[]]} ctype =
  | Str-Top : [ฮจ โข oft ฮ M A[]] โ {O:[ฮจ,x:obj โข oft (cons ฮ[..] x B[] ๐) M[..] A[]]} StrTop [ฮจ,x:obj โข O]
  ;

rec oft_str : {O:[ฮจ,x:obj โข oft (cons ฮ[..] x B[] ๐) M A[]]} StrTop [ฮจ,x:obj โข O] =
  / total d (oft_str d) /
  mlam O โ case [_,x:obj โข O] of
  | [_,x:obj โข oft/var (upd/n U1) (exh/c E1 _)] โ
    let Prune-Upd [_ โข U2] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let [_ โข E2] = prune_exh [_ โข E1] in
    Str-Top [_ โข oft/var U2 E2] [_,x:obj โข _]
  | [_,x:obj โข oft/lam \y.O1] โ
    let [_,x:obj,y:obj โข O1'[..,y,x]] = oft_exch_top [_,x:obj,y:obj โข O1] in
    let Str-Top [_,x:obj โข O2] [_,x:obj,y:obj โข _] = oft_str [_,x:obj,y:obj โข O1'] in
    Str-Top [_ โข oft/lam \x.O2] [_,x:obj โข _]
  | [_,x:obj โข oft/app O1 O2 (mg/c M1 โข/us)] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    let Str-Top [_ โข O1'] [_,x:obj โข _] = oft_str [_,x:obj โข O1] in
    let Str-Top [_ โข O2'] [_,x:obj โข _] = oft_str [_,x:obj โข O2] in
    Str-Top [_ โข oft/app O1' O2' M2] [_,x:obj โข _]
  ;

% Weakening lemma:
% If ฮ โข M : A, then ฮ, x :โฐ B โข M : A for any B

rec oft_weak : (ฮจ:ctx) (ฮ:[ฮจ โข lctx k[]]) [ฮจ โข oft ฮ M A[]]
โ {B:[ โข tp]} [ฮจ,x:obj โข oft (cons ฮ[..] x B[] ๐) M[..] A[]] =
  / total 1 /
  fn oft1 โ mlam B โ case oft1 of
  | [_ โข oft/var U1 E1] โ [_ โข oft/var (upd/n U1[..]) (exh/c E1[..] unr/0)]
  | [_ โข oft/lam \x.O1] โ
    let [_,x:obj,y:obj โข O1'[..,y,x]] = oft_exch_top (oft_weak [_,x:obj โข O1] [ โข B]) in
    [_,x:obj โข oft/lam \y.O1']
  | [_ โข oft/app O1 O2 M1] โ
    let [_,x:obj โข O1'] = oft_weak [_ โข O1] [ โข B] in
    let [_,x:obj โข O2'] = oft_weak [_ โข O2] [ โข B] in
    [_,x:obj โข oft/app O1' O2' (mg/c M1[..] โข/us)]
  ;

%------------------------------------------------------%
% Main lemmas
%------------------------------------------------------%

% Substitution lemma:
% If (1) ฮโ, x :ยน B โข M : A, (2) ฮโ โข N : B, and (3) ฮโ โ ฮโ = ฮ, then ฮ โข [N/x]M : A

rec sub_lem : (ฮจ:ctx) (ฮ:[ฮจ โข lctx k[]]) [ฮจ,x:obj โข oft (cons ฮโ[..] x B[] ๐) M A[]]
โ [ฮจ โข oft ฮโ N B[]] โ [ฮจ โข merge ฮโ ฮโ ฮ]
โ [ฮจ โข oft ฮ M[..,N] A[]] =
  / total d (sub_lem d) /
  fn d1, d2, mg โ
  let [_ โข M1] = mg in
  case d1 of
  | [_,x:obj โข oft/var U1 E1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข exh/c E2 _] = [_,x:obj โข E1] in
      let [_ โข cx/refl] = merge_id mg (prune_exh [_ โข E2]) in
      d2
    | [_,x:obj โข upd/n _] โ
      let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E1] in
      impossible [ โข T]
    )
  | [_,x:obj โข oft/lam \y.O1] โ
    let [_,y:obj,x:obj โข O1'[..,x,y]] = oft_exch_top [_,x:obj,y:obj โข O1] in
    let [_,x:obj โข O2] = sub_lem [_,x:obj,y:obj โข O1'] (oft_weak d2 [ โข _]) [_,x:obj โข mg/c M1[..] โข/a1] in
    [_ โข oft/lam \x.O2]
  | [_,x:obj โข oft/app O1 O2 (mg/c M2' MLT[])] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M2'] in
    case [ โข MLT] of
    | [ โข โข/a1] โ
      let [_ โข M2_comm] = merge_comm [_ โข M2] in
      let [_ โข mg-assoc M3 M4_comm _ _] = merge_assoc [_ โข M1] [_ โข M2_comm] in
      let [_ โข M4] = merge_comm [_ โข M4_comm] in
      let Str-Top [_ โข O2'] [_,x:obj โข _] = oft_str [_,x:obj โข O2] in
      let [_ โข O1'] = sub_lem [_,x:obj โข O1] d2 [_ โข M3] in
      [_ โข oft/app O1' O2' M4]
    | [ โข โข/a2] โ
      let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M1] [_ โข M2] in
      let Str-Top [_ โข O1'] [_,x:obj โข _] = oft_str [_,x:obj โข O1] in
      let [_ โข O2'] = sub_lem [_,x:obj โข O2] d2 [_ โข M3] in
      [_ โข oft/app O1' O2' M4]
  ;