% Top-level exchange lemma
% DZ: Need more general exchange lemma; will not be able to call IH in Î» case

rec oft_exch :
Oft [Î¨,x:tm,y:tm âŠ¢ cons (cons Î” x Tâ‚[] Î±) y Tâ‚‚[] Î²] [Î¨, x:tm, y:tm âŠ¢ M] [ âŠ¢ T]
â†’ Oft [Î¨,y:tm,x:tm âŠ¢ cons (cons Î” y Tâ‚‚[] Î²) x Tâ‚[] Î±] [Î¨, y:tm, x:tm âŠ¢ M[..,x,y]] [ âŠ¢ T] =
  fn d â‡’ case d of
  | Oft/var (Lkp/exh Rmv/t (Exh/c ex)) â‡’ Oft/var (Lkp/exh (Rmv/c Rmv/t) (Exh/c ex))
  | Oft/var (Lkp/exh (Rmv/c Rmv/t) (Exh/c ex)) â‡’ Oft/var (Lkp/exh Rmv/t (Exh/c ex))
  | Oft/var (Lkp/exh (Rmv/c (Rmv/c rm1)) (Exh/c (Exh/c ex))) â‡’ Oft/var (Lkp/exh (Rmv/c (Rmv/c rm1)) (Exh/c (Exh/c ex)))
  %| Oft/app dm1 dm2 mg â‡’ ?
  %| Oft/lam dm â‡’ ?
  ;

%{
BP:

"I think that one can prove exchange by defining an append on contexts and then using append to define exchange. Something like
 
If Append [Î¨ âŠ¢ Î”, x:^a A, y:^b B] [Î¨â€™ âŠ¢ Î”â€™] [Î¦ âŠ¢ Î”â‚€]
and Append [Î¨ âŠ¢ Î”, y:^b B, x:^a A] [Î¨â€™ âŠ¢ Î”â€™] [Î¦â€™ âŠ¢ Î”â‚€â€™]
and Oft [Î¦ âŠ¢ Î”â‚€] [Î¦ âŠ¢ M] [ âŠ¢ T]
and $S: [Î¦â€™ âŠ¢ Î¦] then
Oft [Î¦â€™ âŠ¢ Î”â‚€â€™] [Î¦ âŠ¢ M[$S[..]]] [ âŠ¢ T]

There are probably some weakenings missing in the above sketch, but you get the idea."
}%

% Strengthening lemma

inductive ExStrT : (Î¨:tctx) [Î¨,x:tm âŠ¢ lctx] â†’ [Î¨, x:tm âŠ¢ tm] â†’ [ âŠ¢ tp] â†’ ctype =
  | ExStr/tm :
    Oft [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ M] [ âŠ¢ S] â†’ ExStrT [Î¨,x:tm âŠ¢ cons Î”[..] x T[] ğŸ˜] [Î¨, x:tm âŠ¢ M[..]] [ âŠ¢ S]
  ;

rec oft_str_top :
Oft [Î¨,x:tm âŠ¢ cons Î”[..] x T[] ğŸ˜] [Î¨, x:tm âŠ¢ M] [ âŠ¢ S]
â†’ ExStrT [Î¨,x:tm âŠ¢ cons Î”[..] x T[] ğŸ˜] [Î¨, x:tm âŠ¢ M] [ âŠ¢ S] =
  fn d â‡’ case d of
  | Oft/var l â‡’
    let Lkp/str l' = lkup_str_top l in
    ExStr/tm (Oft/var l')
  | Oft/app dm1 dm2 (Mg/c m12 [ âŠ¢ â€¢/us]) â‡’
    let ExStr/tm dm1' = oft_str_top dm1 in
    let ExStr/tm dm2' = oft_str_top dm2 in
    ExStr/tm (Oft/app dm1' dm2' m12)
  | Oft/lam dm â‡’
    % exchange and IH (induction order on term M, since the typing derivation is not structurally smaller
    let ExStr/tm dm' = oft_str_top (oft_exch dm) in
    ExStr/tm (Oft/lam dm')
  ;

%{ - - - - - - - - - - - - - - - - - -
% More generally:

inductive ExStr : (Î¨:tctx) (Î¨':tctx) {$S:$[Î¨ âŠ¢ Î¨']} [Î¨' âŠ¢ lctx] â†’ [Î¨ âŠ¢ tm] â†’ [ âŠ¢ tp] â†’ ctype =
  | ExStr/tm :
    Oft [Î¨' âŠ¢ Î”] [Î¨' âŠ¢ M] [ âŠ¢ A]
    â†’ ExStr $[Î¨ âŠ¢ $S] [Î¨' âŠ¢ Î”] [Î¨ âŠ¢ M[$S]] [ âŠ¢ A]
  ;

rec oft_str : (Î¦:tctx)
Oft [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ M] [ âŠ¢ S]
â†’ Rmv [Î¨] [Î¦] [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ #p] [ âŠ¢ ğŸ˜] [ âŠ¢ A] $[Î¨ âŠ¢ $S] [Î¦ âŠ¢ Î”']
â†’ ExStr $[Î¨ âŠ¢ $S] [Î¦ âŠ¢ Î”'] [Î¨ âŠ¢ M] [ âŠ¢ S] =
  %/ total 1 /
  fn d, rm â‡’ case d of
  | Oft/var l â‡’
    let Lkp'/str l' = lkup_str' l rm in
    ExStr/tm (Oft/var l')
  | Oft/app dm1 dm2 m â‡’
    let Mg/str m' [ âŠ¢ â€¢/us] rm1 rm2 = merge_str m rm in
    let ExStr/tm dm1' = oft_str dm1 rm1 in
    let ExStr/tm dm2' = oft_str dm2 rm2 in
    ExStr/tm (Oft/app dm1' dm2' m')
  | Oft/lam dm â‡’
    let ExStr/tm dm' = oft_str dm (Rmv/c rm) in
    ExStr/tm (Oft/lam dm')
  ;
%- - - - - - - - - - - - - - - - - - }%

% Weakening lemma

rec oft_weak_top : Oft [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ M] [ âŠ¢ S]
â†’ Oft [Î¨, x:tm âŠ¢ cons Î”[..] x T[] ğŸ˜] [Î¨, x:tm âŠ¢ M[..]] [ âŠ¢ S] =
  / total 1 /
  fn d â‡’ case d of
  | Oft/var l â‡’ Oft/var (lkup_weak l)
  | Oft/app dm1 dm2 m12 â‡’ Oft/app (oft_weak_top dm1) (oft_weak_top dm2) (Mg/c m12 [ âŠ¢ â€¢/us])
  | Oft/lam dm â‡’ Oft/lam (oft_exch (oft_weak_top dm))
  ;

%{ - - - - - - - - - - - - - - - - - -
% More generally:

rec oft_weak : Oft [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ M] [ âŠ¢ S]
â†’ Rmv [Î¦] [Î¨] [Î¦ âŠ¢ Î”'] [Î¦ âŠ¢ #p] [ âŠ¢ ğŸ˜] [ âŠ¢ A] $[Î¦ âŠ¢ $S] [Î¨ âŠ¢ Î”] â†’ Oft [Î¦ âŠ¢ Î”'] [Î¦ âŠ¢ M[$S]] [ âŠ¢ S] = ? ;
%- - - - - - - - - - - - - - - - - - }%

% Substitution lemma

rec subst : Oft [Î¨,x:tm âŠ¢ cons Î”â‚[..] x T[] ğŸ™] [Î¨, x:tm âŠ¢ M] [ âŠ¢ S]
â†’ Oft [Î¨ âŠ¢ Î”â‚‚] [Î¨ âŠ¢ N] [ âŠ¢ T] â†’ Merge [Î¨ âŠ¢ Î”â‚] [Î¨ âŠ¢ Î”â‚‚] [Î¨ âŠ¢ Î”]
â†’ Oft [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ M[..,N]] [ âŠ¢ S] =
  %/ total 1 /
  fn d1, d2, m â‡’ case d1 of
  | Oft/var l â‡’
    let Lkp/toplin exh = lkup_toplin l in
    let [_ âŠ¢ cx/refl] = merge_id m exh in
    d2
  | Oft/app dm1 dm2 (Mg/c m12 mlt12) â‡’
    (case mlt12 of
    | [ âŠ¢ â€¢/a1] â‡’
      let Mg/assoc m13 m' = merge_assoc (merge_comm m12) m in
      let ExStr/tm dm2' = oft_str_top dm2 in
      Oft/app (subst dm1 d2 m13) dm2' (merge_comm m')
    | [ âŠ¢ â€¢/a2] â‡’
      %{
      m12 : Merge [Î¨,x:tm âŠ¢ cons Î”â‚1[..] x T[] ğŸ˜]
                  [Î¨,x:tm âŠ¢ cons Î”â‚â‚‚[..] x T[] ğŸ™]
                  [Î¨,x:tm âŠ¢ cons Î”â‚[..] x T[] ğŸ™]
      m' : Merge [Î¨ âŠ¢ Î”â‚â‚] [Î¨ âŠ¢ Î”â‚â‚‚] [Î¨ âŠ¢ Î”1]

      By assoc. If m' and m then 
        mA : merge [Î¨ âŠ¢ Î”â‚â‚] [Î¨ âŠ¢ Î”*] [Î¨ âŠ¢ Î”]
        mB :  merge [Î¨ âŠ¢ Î”â‚â‚‚] [Î¨ âŠ¢ Î”â‚‚] [Î¨ âŠ¢ Î”*]

      By IH subst dm2 d2 mB : em2 : Oft [Î¨ âŠ¢ Î”*] [Î¨ âŠ¢ M2[..,N]] [ âŠ¢ S']
      By oft_str_top dm1 : Oft [Î¨ âŠ¢ Î”â‚â‚] [Î¨ âŠ¢ M1'] [ âŠ¢ lolli S' S]
      By Oft/app dm1' em2 mA : Oft [Î¨ âŠ¢ Î”] [Î¨ âŠ¢ app M1' M2[..,N]] [ âŠ¢ S']
      }%
      let Mg/assoc m23 m' = merge_assoc m12 m in
      let ExStr/tm dm1' = oft_str_top dm1 in
      Oft/app dm1' (subst dm2 d2 m23) m'
    )
  | Oft/lam dm1' â‡’ Oft/lam (subst (oft_exch dm1') (oft_weak_top d2) (Mg/c m [ âŠ¢ â€¢/a1]))
  ;