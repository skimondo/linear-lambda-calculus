% Top-level exchange lemma
% DZ: Need more general exchange lemma; will not be able to call IH in λ case

rec oft_exch :
Oft [Ψ,x:tm,y:tm ⊢ cons (cons Δ x T₁[] α) y T₂[] β] [Ψ, x:tm, y:tm ⊢ M] [ ⊢ T]
→ Oft [Ψ,y:tm,x:tm ⊢ cons (cons Δ y T₂[] β) x T₁[] α] [Ψ, y:tm, x:tm ⊢ M[..,x,y]] [ ⊢ T] =
  fn d ⇒ case d of
  | Oft/var (Lkp/exh Rmv/t (Exh/c ex)) ⇒ Oft/var (Lkp/exh (Rmv/c Rmv/t) (Exh/c ex))
  | Oft/var (Lkp/exh (Rmv/c Rmv/t) (Exh/c ex)) ⇒ Oft/var (Lkp/exh Rmv/t (Exh/c ex))
  | Oft/var (Lkp/exh (Rmv/c (Rmv/c rm1)) (Exh/c (Exh/c ex))) ⇒ Oft/var (Lkp/exh (Rmv/c (Rmv/c rm1)) (Exh/c (Exh/c ex)))
  %| Oft/app dm1 dm2 mg ⇒ ?
  %| Oft/lam dm ⇒ ?
  ;

%{
BP:

"I think that one can prove exchange by defining an append on contexts and then using append to define exchange. Something like
 
If Append [Ψ ⊢ Δ, x:^a A, y:^b B] [Ψ’ ⊢ Δ’] [Φ ⊢ Δ₀]
and Append [Ψ ⊢ Δ, y:^b B, x:^a A] [Ψ’ ⊢ Δ’] [Φ’ ⊢ Δ₀’]
and Oft [Φ ⊢ Δ₀] [Φ ⊢ M] [ ⊢ T]
and $S: [Φ’ ⊢ Φ] then
Oft [Φ’ ⊢ Δ₀’] [Φ ⊢ M[$S[..]]] [ ⊢ T]

There are probably some weakenings missing in the above sketch, but you get the idea."
}%

% Strengthening lemma

inductive ExStrT : (Ψ:tctx) [Ψ,x:tm ⊢ lctx] → [Ψ, x:tm ⊢ tm] → [ ⊢ tp] → ctype =
  | ExStr/tm :
    Oft [Ψ ⊢ Δ] [Ψ ⊢ M] [ ⊢ S] → ExStrT [Ψ,x:tm ⊢ cons Δ[..] x T[] 𝟘] [Ψ, x:tm ⊢ M[..]] [ ⊢ S]
  ;

rec oft_str_top :
Oft [Ψ,x:tm ⊢ cons Δ[..] x T[] 𝟘] [Ψ, x:tm ⊢ M] [ ⊢ S]
→ ExStrT [Ψ,x:tm ⊢ cons Δ[..] x T[] 𝟘] [Ψ, x:tm ⊢ M] [ ⊢ S] =
  fn d ⇒ case d of
  | Oft/var l ⇒
    let Lkp/str l' = lkup_str_top l in
    ExStr/tm (Oft/var l')
  | Oft/app dm1 dm2 (Mg/c m12 [ ⊢ •/us]) ⇒
    let ExStr/tm dm1' = oft_str_top dm1 in
    let ExStr/tm dm2' = oft_str_top dm2 in
    ExStr/tm (Oft/app dm1' dm2' m12)
  | Oft/lam dm ⇒
    % exchange and IH (induction order on term M, since the typing derivation is not structurally smaller
    let ExStr/tm dm' = oft_str_top (oft_exch dm) in
    ExStr/tm (Oft/lam dm')
  ;

%{ - - - - - - - - - - - - - - - - - -
% More generally:

inductive ExStr : (Ψ:tctx) (Ψ':tctx) {$S:$[Ψ ⊢ Ψ']} [Ψ' ⊢ lctx] → [Ψ ⊢ tm] → [ ⊢ tp] → ctype =
  | ExStr/tm :
    Oft [Ψ' ⊢ Δ] [Ψ' ⊢ M] [ ⊢ A]
    → ExStr $[Ψ ⊢ $S] [Ψ' ⊢ Δ] [Ψ ⊢ M[$S]] [ ⊢ A]
  ;

rec oft_str : (Φ:tctx)
Oft [Ψ ⊢ Δ] [Ψ ⊢ M] [ ⊢ S]
→ Rmv [Ψ] [Φ] [Ψ ⊢ Δ] [Ψ ⊢ #p] [ ⊢ 𝟘] [ ⊢ A] $[Ψ ⊢ $S] [Φ ⊢ Δ']
→ ExStr $[Ψ ⊢ $S] [Φ ⊢ Δ'] [Ψ ⊢ M] [ ⊢ S] =
  %/ total 1 /
  fn d, rm ⇒ case d of
  | Oft/var l ⇒
    let Lkp'/str l' = lkup_str' l rm in
    ExStr/tm (Oft/var l')
  | Oft/app dm1 dm2 m ⇒
    let Mg/str m' [ ⊢ •/us] rm1 rm2 = merge_str m rm in
    let ExStr/tm dm1' = oft_str dm1 rm1 in
    let ExStr/tm dm2' = oft_str dm2 rm2 in
    ExStr/tm (Oft/app dm1' dm2' m')
  | Oft/lam dm ⇒
    let ExStr/tm dm' = oft_str dm (Rmv/c rm) in
    ExStr/tm (Oft/lam dm')
  ;
%- - - - - - - - - - - - - - - - - - }%

% Weakening lemma

rec oft_weak_top : Oft [Ψ ⊢ Δ] [Ψ ⊢ M] [ ⊢ S]
→ Oft [Ψ, x:tm ⊢ cons Δ[..] x T[] 𝟘] [Ψ, x:tm ⊢ M[..]] [ ⊢ S] =
  / total 1 /
  fn d ⇒ case d of
  | Oft/var l ⇒ Oft/var (lkup_weak l)
  | Oft/app dm1 dm2 m12 ⇒ Oft/app (oft_weak_top dm1) (oft_weak_top dm2) (Mg/c m12 [ ⊢ •/us])
  | Oft/lam dm ⇒ Oft/lam (oft_exch (oft_weak_top dm))
  ;

%{ - - - - - - - - - - - - - - - - - -
% More generally:

rec oft_weak : Oft [Ψ ⊢ Δ] [Ψ ⊢ M] [ ⊢ S]
→ Rmv [Φ] [Ψ] [Φ ⊢ Δ'] [Φ ⊢ #p] [ ⊢ 𝟘] [ ⊢ A] $[Φ ⊢ $S] [Ψ ⊢ Δ] → Oft [Φ ⊢ Δ'] [Φ ⊢ M[$S]] [ ⊢ S] = ? ;
%- - - - - - - - - - - - - - - - - - }%

% Substitution lemma

rec subst : Oft [Ψ,x:tm ⊢ cons Δ₁[..] x T[] 𝟙] [Ψ, x:tm ⊢ M] [ ⊢ S]
→ Oft [Ψ ⊢ Δ₂] [Ψ ⊢ N] [ ⊢ T] → Merge [Ψ ⊢ Δ₁] [Ψ ⊢ Δ₂] [Ψ ⊢ Δ]
→ Oft [Ψ ⊢ Δ] [Ψ ⊢ M[..,N]] [ ⊢ S] =
  %/ total 1 /
  fn d1, d2, m ⇒ case d1 of
  | Oft/var l ⇒
    let Lkp/toplin exh = lkup_toplin l in
    let [_ ⊢ cx/refl] = merge_id m exh in
    d2
  | Oft/app dm1 dm2 (Mg/c m12 mlt12) ⇒
    (case mlt12 of
    | [ ⊢ •/a1] ⇒
      let Mg/assoc m13 m' = merge_assoc (merge_comm m12) m in
      let ExStr/tm dm2' = oft_str_top dm2 in
      Oft/app (subst dm1 d2 m13) dm2' (merge_comm m')
    | [ ⊢ •/a2] ⇒
      %{
      m12 : Merge [Ψ,x:tm ⊢ cons Δ₁1[..] x T[] 𝟘]
                  [Ψ,x:tm ⊢ cons Δ₁₂[..] x T[] 𝟙]
                  [Ψ,x:tm ⊢ cons Δ₁[..] x T[] 𝟙]
      m' : Merge [Ψ ⊢ Δ₁₁] [Ψ ⊢ Δ₁₂] [Ψ ⊢ Δ1]

      By assoc. If m' and m then 
        mA : merge [Ψ ⊢ Δ₁₁] [Ψ ⊢ Δ*] [Ψ ⊢ Δ]
        mB :  merge [Ψ ⊢ Δ₁₂] [Ψ ⊢ Δ₂] [Ψ ⊢ Δ*]

      By IH subst dm2 d2 mB : em2 : Oft [Ψ ⊢ Δ*] [Ψ ⊢ M2[..,N]] [ ⊢ S']
      By oft_str_top dm1 : Oft [Ψ ⊢ Δ₁₁] [Ψ ⊢ M1'] [ ⊢ lolli S' S]
      By Oft/app dm1' em2 mA : Oft [Ψ ⊢ Δ] [Ψ ⊢ app M1' M2[..,N]] [ ⊢ S']
      }%
      let Mg/assoc m23 m' = merge_assoc m12 m in
      let ExStr/tm dm1' = oft_str_top dm1 in
      Oft/app dm1' (subst dm2 d2 m23) m'
    )
  | Oft/lam dm1' ⇒ Oft/lam (subst (oft_exch dm1') (oft_weak_top d2) (Mg/c m [ ⊢ •/a1]))
  ;