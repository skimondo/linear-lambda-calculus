%======================================================%
% Lemmas
%======================================================%

%------------------------------------------------------%
% Structural properties of typing judgment
%------------------------------------------------------%

% Exchange lemma:
% If ฮ โข M : A and ฮ[(n, x) โ (m, y)] = ฮ', then ฮ' โข M : A

rec oft_exch : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข oft ฮ M A] โ [ฮจ โข exch ฮ n X m Y ฮ']
โ [ฮจ โข oft ฮ' M A] =
  / total 1 /
  fn oft1, ex1 โ
  let [_ โข exch/u NEQ[] U1 U2] = ex1 in
  case oft1 of
  | [_ โข oft/var U] โ
    let [_ โข look U'] = exch_lookup ex1 [_ โข U] in
    [_ โข oft/var U']
  | [_ โข oft/lam \x.O1] โ
    let [_,x:obj โข O2] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n U1[..]) (upd/n U2[..])] in
    [_ โข oft/lam \x.O2]
  | [_ โข oft/app O1 O2 M1] โ
    let [_ โข exch-mg U1a U2a U1b U2b _ M2 _ _ _ _ _] = exch_merge [_ โข U1] [_ โข U2] [_ โข M1] in
    let [_ โข O1'] = oft_exch [_ โข O1] [_ โข exch/u NEQ[] U1a U2a] in
    let [_ โข O2'] = oft_exch [_ โข O2] [_ โข exch/u NEQ[] U1b U2b] in
    [_ โข oft/app O1' O2' M2]
  ;

rec oft_exch_top : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข oft (cons (cons ฮ Y B[] ฮฒ[]) Z C[] ฮณ[]) M A]
โ [ฮจ โข oft (cons (cons ฮ Z C[] ฮณ[]) Y B[] ฮฒ[]) M A] =
  / total /
  fn oft1 โ oft_exch oft1 (exch_top [_ โข _] [_ โข _] [ โข _] [ โข _] [_ โข _] [ โข _] [ โข _])
  ;

% Strengthening lemma:
% If ฮ, x :โฐ B โข M : A, then (1) M does not depend on x and (2) ฮ โข M : A 

inductive StrTop: (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) {O:[ฮจ โข oft ฮ M A[]]} ctype =
  | Str-Top : [ฮจ โข oft ฮ M A[]] โ {O:[ฮจ,x:obj โข oft (cons ฮ[..] x B[] ๐) M[..] A[]]} StrTop [ฮจ,x:obj โข O];

rec oft_str : {O:[ฮจ,x:obj โข oft (cons ฮ[..] x B[] ๐) M A[]]} StrTop [ฮจ,x:obj โข O] =
  / total d (oft_str d) /
  mlam O โ case [_,x:obj โข O] of
  | [_,x:obj โข oft/var (upd/n U1)] โ
    let [_,x:obj โข U1'] = upd_refl [_,x:obj โข U1] in
    let Prune-Upd [_ โข U2] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
    Str-Top [_ โข oft/var U2] [_,x:obj โข _]
  | [_,x:obj โข oft/lam \y.O1] โ
    let [_,x:obj,y:obj โข O1'[..,y,x]] = oft_exch_top [_,x:obj,y:obj โข O1] in
    let Str-Top [_,x:obj โข O2] [_,x:obj,y:obj โข _] = oft_str [_,x:obj,y:obj โข O1'] in
    Str-Top [_ โข oft/lam \x.O2] [_,x:obj โข _]
  | [_,x:obj โข oft/app O1 O2 (mg/c M1 โข/us)] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    let Str-Top [_ โข O1'] [_,x:obj โข _] = oft_str [_,x:obj โข O1] in
    let Str-Top [_ โข O2'] [_,x:obj โข _] = oft_str [_,x:obj โข O2] in
    Str-Top [_ โข oft/app O1' O2' M2] [_,x:obj โข _]
  ;

% Weakening lemma:
% If ฮ โข M : A, then ฮ, x :โฐ B โข M : A for any B

rec oft_weak : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข oft ฮ M A[]]
โ {B:[ โข tp]} [ฮจ,x:obj โข oft (cons ฮ[..] x B[] ๐) M[..] A[]] =
  / total 1 /
  fn oft1 โ mlam B โ case oft1 of
  | [_ โข oft/var U1] โ [_ โข oft/var (upd/n U1[..])]
  | [_ โข oft/lam \x.O1] โ
    let [_,x:obj,y:obj โข O1'[..,y,x]] = oft_exch_top (oft_weak [_,x:obj โข O1] [ โข B]) in
    [_,x:obj โข oft/lam \y.O1']
  | [_ โข oft/app O1 O2 M1] โ
    let [_,x:obj โข O1'] = oft_weak [_ โข O1] [ โข B] in
    let [_,x:obj โข O2'] = oft_weak [_ โข O2] [ โข B] in
    [_,x:obj โข oft/app O1' O2' (mg/c M1[..] โข/us)]
  ;

%------------------------------------------------------%
% Main lemmas
%------------------------------------------------------%

% Typing is preserved under merge:
% If ฮโ โข M : A and ฮโ โ ฮโ = ฮ, then ฮ โข M : A

rec oft_merge : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข oft ฮโ M A] โ [ฮจ โข merge ฮโ ฮโ ฮ] โ [ฮจ โข oft ฮ M A] =
  / total 1 /
  fn d1, mg โ
  let [_ โข M] = mg in
  case d1 of
  | [_ โข oft/var U1] โ
    let [_ โข merge-look2 _ U2 โข/a1 _ _] = merge_lookup2 [_ โข U1] [_ โข M] in
    [_ โข oft/var U2]
  | [_ โข oft/lam \x.O1] โ
    let [_,x:obj โข O1'] = oft_merge [_,x:obj โข O1] [_,x:obj โข mg/c M[..] โข/a1] in
    [_ โข oft/lam \x.O1']
  | [_ โข oft/app O1 O2 M2] โ
    let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M] [_ โข M2] in
    let [_ โข O2'] = oft_merge [_ โข O2] [_ โข M3] in
    [_ โข oft/app O1 O2' M4]
  ;

% Substitution lemma:
% If (1) ฮโ, x :ยน B โข M : A, (2) ฮโ โข N : B, and (3) ฮโ โ ฮโ = ฮ, then ฮ โข [N/x]M : A

rec sub_lem : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ,x:obj โข oft (cons ฮโ[..] x B[] ๐) M A[]]
โ [ฮจ โข oft ฮโ N B[]] โ [ฮจ โข merge ฮโ ฮโ ฮ]
โ [ฮจ โข oft ฮ M[..,N] A[]] =
  / total d (sub_lem d) /
  fn d1, d2, mg โ
  let [_ โข M1] = mg in
  case d1 of
  | [_,x:obj โข oft/var U1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ oft_merge d2 (merge_comm mg)
    | [_,x:obj โข upd/n U1'] โ
      let [_,x:obj โข U1''] = upd_refl [_,x:obj โข U1'] in
      let Prune-Upd [_ โข U2] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_ โข merge-look2 _ U โข/a1 _ _] = merge_lookup2 [_ โข U2] [_ โข M1] in
      [_ โข oft/var U]
    )
  | [_,x:obj โข oft/lam \y.O1] โ
    let [_,y:obj,x:obj โข O1'[..,x,y]] = oft_exch_top [_,x:obj,y:obj โข O1] in
    let [_,x:obj โข O2] = sub_lem [_,x:obj,y:obj โข O1'] (oft_weak d2 [ โข _]) [_,x:obj โข mg/c M1[..] โข/a1] in
    [_ โข oft/lam \x.O2]
  | [_,x:obj โข oft/app O1 O2 (mg/c M2' MLT[])] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M2'] in
    case [ โข MLT] of
    | [ โข โข/a1] โ
      let [_ โข M2_comm] = merge_comm [_ โข M2] in
      let [_ โข mg-assoc M3 M4_comm _ _] = merge_assoc [_ โข M1] [_ โข M2_comm] in
      let [_ โข M4] = merge_comm [_ โข M4_comm] in
      let Str-Top [_ โข O2'] [_,x:obj โข _] = oft_str [_,x:obj โข O2] in
      let [_ โข O1'] = sub_lem [_,x:obj โข O1] d2 [_ โข M3] in
      [_ โข oft/app O1' O2' M4]
    | [ โข โข/a2] โ
      let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M1] [_ โข M2] in
      let Str-Top [_ โข O1'] [_,x:obj โข _] = oft_str [_,x:obj โข O1] in
      let [_ โข O2'] = sub_lem [_,x:obj โข O2] d2 [_ โข M3] in
      [_ โข oft/app O1' O2' M4]
  ;