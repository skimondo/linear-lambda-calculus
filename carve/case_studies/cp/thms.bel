%======================================================%
% Theorems
%======================================================%

% Subject reduction for CP

rec tps : (Œ®:ctx) (Œî:[Œ® ‚ä¢ lctx N[]]) [Œ® ‚ä¢ P ‚áõ P'] ‚Üí [Œ® ‚ä¢ oft P Œî] ‚Üí [Œ® ‚ä¢ oft P' Œî] =
  / total 1 /
  fn rd, d ‚áí case rd of
  % Principal cut reductions
  | [_ ‚ä¢ Œ≤fwd] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/fwd DU'[] (upd/n U1') U2 E1) (\x.O2)] = d in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U2] in
    let [ ‚ä¢ refl] = dual_uniq [ ‚ä¢ DU] [ ‚ä¢ DU'] in
    let [_ ‚ä¢ merge-upd2 U1a U1b ‚Ä¢/a1 M2 _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M1] [ ‚ä¢ ‚Ä¢/us] in
    let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U1a] (upd_refl [_ ‚ä¢ U1a]) in
    let [_,x:obj ‚ä¢ exh/c E2 _] = [_ ‚ä¢ E1] in
    let [_ ‚ä¢ cx/refl] = merge_id [_ ‚ä¢ M2] (prune_exh [_,x:obj ‚ä¢ E2]) in
    oft_rename [_,x:obj ‚ä¢ O2] (upd_symm [_ ‚ä¢ U1b])
  | [_ ‚ä¢ Œ≤1‚ä•] ‚áí
    let [_ ‚ä¢ oft/pcomp D1 M (\x.oft/close U1 E) (\x.oft/wait U2 O2)] = d in
    (case [_,x:obj ‚ä¢ U1] of
    | [_,x:obj ‚ä¢ upd/t _] ‚áí
      let [_,x:obj ‚ä¢ exh/c E1 _] = [_,y:obj ‚ä¢ E] in
      let [_ ‚ä¢ cx/refl] = merge_id [_ ‚ä¢ M] (prune_exh [_ ‚ä¢ E1]) in
      (case [_,x:obj ‚ä¢ U2] of
      | [_,x:obj ‚ä¢ upd/t _] ‚áí
        let [_,x:obj ‚ä¢ O2'] = (oft_str [_,x:obj ‚ä¢ O2]) in
        let Prune-Oft [_ ‚ä¢ O1] [_,x:obj ‚ä¢ _] = prune_oft [_,x:obj ‚ä¢ O2'] in
        [_ ‚ä¢ O1]
      | [_,x:obj ‚ä¢ upd/n U2] ‚áí impossible upd_contra [_,x:obj ‚ä¢ U2]
      )
    | [_,x:obj ‚ä¢ upd/n U1] ‚áí
      let [_,x:obj ‚ä¢ exh/c _ T[]] = [_,x:obj ‚ä¢ E] in
      impossible [ ‚ä¢ T]
    )
  | [_ ‚ä¢ Œ≤‚äó‚Öã] ‚áí
    let [_ ‚ä¢ oft/pcomp (D‚äó DU1[] DU2[]) M1 (\x.oft/out U1 (mg/c M2' MLT1[]) (\y.O1) (\y.O2)) (\x.oft/inp U2 \y.\z.O3)] = d in
    let Prune-Merge [_ ‚ä¢ M2] [_,x:obj ‚ä¢ _] = prune_merge [_,x:obj ‚ä¢ M2'] in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U1] in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U2] in
    let [ ‚ä¢ ‚Ä¢/a2] = [ ‚ä¢ MLT1] in
    let [_ ‚ä¢ mg-assoc M3 M _ _] = merge_assoc [_ ‚ä¢ M1] [_ ‚ä¢ M2] in
    % Typing judgments
    let [ ‚ä¢ _]:[ ‚ä¢ dual A A'] = [ ‚ä¢ DU1] in
    let [_,x:obj ‚ä¢ O1'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O1] in
    let [_,x:obj ‚ä¢ O2''] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O2] in
    let [_,x:obj,y:obj ‚ä¢ O2'[..,y,x]] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O2''[..,x]] [_,x:obj,y:obj ‚ä¢ y] [ ‚ä¢ A']) in
    let [_,x:obj,y:obj,z:obj ‚ä¢ O3''] = oft_exch_top (oft_str (oft_exch_top2 [_,y:obj,z:obj,x:obj ‚ä¢ O3[..,x,y,z]])) in
    let Prune-Oft [_,x:obj,y:obj ‚ä¢ O3'[..,y,x]] [_,x:obj,y:obj,z:obj ‚ä¢ _] = prune_oft [_,x:obj,y:obj,z:obj ‚ä¢ O3''] in
    [_ ‚ä¢ oft/pcomp DU1[] M (\x.O1') (\x.oft/pcomp DU2[] (mg/c M3[..] ‚Ä¢/a2) (\y.O2') (\y.O3'))]
  | [_ ‚ä¢ Œ≤‚äï&1] ‚áí
    let [_ ‚ä¢ oft/pcomp (D‚äï DU1[] _) M1 (\x.oft/inl U1 (\z.O1)) (\x.oft/choice U2 (\y.O2) (\y.O3))] = d in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U1] in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U2] in
    let [_,x:obj ‚ä¢ O1'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O1] in
    let [_,x:obj ‚ä¢ O2'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O2] in
    [_ ‚ä¢ oft/pcomp DU1[] M1 (\x.O1') (\x.O2')]
  | [_ ‚ä¢ Œ≤‚äï&2] ‚áí
    let [_ ‚ä¢ oft/pcomp (D‚äï _ DU2[]) M1 (\x.oft/inr U1 (\z.O1)) (\x.oft/choice U2 (\y.O2) (\y.O3))] = d in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U1] in
    let [_,x:obj ‚ä¢ upd-istop _] = upd_var_istop [_,x:obj ‚ä¢ U2] in
    let [_,x:obj ‚ä¢ O1'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O1] in
    let [_,x:obj ‚ä¢ O3'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O3] in
    [_ ‚ä¢ oft/pcomp DU2[] M1 (\x.O1') (\x.O3')]
  % Commuting conversions
  | [_ ‚ä¢ Œ∫‚ä•] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/wait (upd/n U1') O1) (\x.O2)] = d in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    let [_ ‚ä¢ merge-upd2 U2 U ‚Ä¢/a1 M2 _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M1] [ ‚ä¢ ‚Ä¢/us] in
    let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U2] (upd_refl [_ ‚ä¢ U2]) in
    [_ ‚ä¢ oft/wait U (oft/pcomp DU[] M2 (\x.O1) (\x.O2))]
  | [_ ‚ä¢ Œ∫‚äó1] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/out (upd/n U1') (mg/c M2' MLT[]) (\y.O1) (\y.O2)) (\y.O3)] = d in
    let Prune-Merge [_ ‚ä¢ M2] [_,x:obj ‚ä¢ _] = prune_merge [_,x:obj ‚ä¢ M2'] in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    (case [ ‚ä¢ MLT] of
    | [ ‚ä¢ ‚Ä¢/a1] ‚áí
      let [_ ‚ä¢ M2_comm] = merge_comm [_ ‚ä¢ M2] in
      let [_ ‚ä¢ mg-assoc M3 M_comm _ _] = merge_assoc [_ ‚ä¢ M1] [_ ‚ä¢ M2_comm] in
      let [_ ‚ä¢ M] = merge_comm [_ ‚ä¢ M_comm] in
      % Typing judgments
      let [_ ‚ä¢ _]:[_ ‚ä¢ upd _ _ _ _ (B1[] ‚äó _) _ _ _ _] = [_ ‚ä¢ U1] in
      let [_,x:obj,y:obj ‚ä¢ O1'[..,y,x]] = oft_exch_top [_,x:obj,y:obj ‚ä¢ O1] in
      let [_,x:obj ‚ä¢ O2'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O2] in
      let [_,x:obj,y:obj ‚ä¢ O3'] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O3[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B1]) in
      % Conclusion
      [_ ‚ä¢ oft/out U1 M (\x.oft/pcomp DU[] (mg/c M3[..] ‚Ä¢/a1) (\y.O1') (\y.O3')) (\x.O2')]
    | [ ‚ä¢ ‚Ä¢/a2] ‚áí
      let [_,x:obj,y:obj ‚ä¢ _]:[_,x:obj,y:obj ‚ä¢ oft _ (cons (cons Œî‚ÇÇ'[..] _ A[] _) _ _ _)] = [_,x:obj,y:obj ‚ä¢ O2] in
      let [_,x:obj ‚ä¢ LK] = refl_top [_,x:obj ‚ä¢ Œî‚ÇÇ'[..]] [_,x:obj ‚ä¢ x] [ ‚ä¢ A] [ ‚ä¢ ùüô] in
      let [_,x:obj,y:obj ‚ä¢ INP] = oft_lin_in [_,x:obj,y:obj ‚ä¢ O2] [_,x:obj,y:obj ‚ä¢ upd/n LK[..,x]] in
      impossible in_proc_lemma [_,x:obj,y:obj ‚ä¢ INP[..,y,x]]
    )
  | [_ ‚ä¢ Œ∫‚äó2] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/out (upd/n U1') (mg/c M2' MLT[]) (\y.O1) (\y.O2)) (\x.O3)] = d in
    let Prune-Merge [_ ‚ä¢ M2] [_,x:obj ‚ä¢ _] = prune_merge [_,x:obj ‚ä¢ M2'] in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    (case [ ‚ä¢ MLT] of
    | [ ‚ä¢ ‚Ä¢/a1] ‚áí
      let [_,x:obj,y:obj ‚ä¢ _]:[_,x:obj,y:obj ‚ä¢ oft _ (cons (cons Œî‚ÇÅ[..] _ A[] _) _ _ _)] = [_,x:obj,y:obj ‚ä¢ O1] in
      let [_,x:obj ‚ä¢ LK] = refl_top [_,x:obj ‚ä¢ Œî‚ÇÅ[..]] [_,x:obj ‚ä¢ x] [ ‚ä¢ A] [ ‚ä¢ ùüô] in
      let [_,x:obj,y:obj ‚ä¢ INP] = oft_lin_in [_,x:obj,y:obj ‚ä¢ O1] [_,x:obj,y:obj ‚ä¢ upd/n LK[..,x]] in
      impossible in_proc_lemma [_,x:obj,y:obj ‚ä¢ INP[..,y,x]]
    | [ ‚ä¢ ‚Ä¢/a2] ‚áí
      let [_ ‚ä¢ mg-assoc M3 M _ _] = merge_assoc [_ ‚ä¢ M1] [_ ‚ä¢ M2] in
      let [_ ‚ä¢ merge-upd2 U2 U3 ‚Ä¢/a1 M3' _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M3] [ ‚ä¢ ‚Ä¢/us] in
      let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U2] (upd_refl [_ ‚ä¢ U2]) in
      % Typing judgments
      let [_ ‚ä¢ _]:[_ ‚ä¢ upd _ _ _ _ (_ ‚äó B2[]) _ _ _ _] = [_ ‚ä¢ U1] in
      let [_,x:obj ‚ä¢ O1'] = oft_str_cor [_,x:obj,y:obj ‚ä¢ O1] in
      let [_,x:obj,y:obj ‚ä¢ O2'[..,y,x]] = oft_exch_top [_,x:obj,y:obj ‚ä¢ O2] in
      let [_,x:obj,y:obj ‚ä¢ O3'] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O3[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B2]) in
      % Conclusion
      [_ ‚ä¢ oft/out U3 M (\x.O1') (\x.oft/pcomp DU[] (mg/c M3'[..] ‚Ä¢/a1) (\y.O2') (\y.O3'))]
    )
  | [_ ‚ä¢ Œ∫‚Öã] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/inp (upd/n U1') \y.\z.O1) (\x.O2)] = d in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    let [_ ‚ä¢ merge-upd2 U2 U ‚Ä¢/a1 M2 _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M1] [ ‚ä¢ ‚Ä¢/us] in
    let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U2] (upd_refl [_ ‚ä¢ U2]) in
    % O1, O2
    let [_,x:obj,y:obj,z:obj ‚ä¢ O1']:[_,x:obj,y:obj,z:obj ‚ä¢ oft _ (cons (cons (cons _ _ B2[] _) _ B1[] _) _ _ _)] = 
      oft_exch_top2 [_,y:obj,z:obj,x:obj ‚ä¢ O1[..,x,y,z]] in
    let [_,x:obj,y:obj ‚ä¢ O2'] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O2[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B2]) in
    let [_,x:obj,y:obj,z:obj ‚ä¢ O2''[..,y,x,z]] = oft_exch_top (oft_weak [_,x:obj,y:obj,z:obj ‚ä¢ O2'[..,y,z]] [_,x:obj,y:obj,z:obj ‚ä¢ x] [ ‚ä¢ B1]) in
    [_ ‚ä¢ oft/inp U \x.\y.oft/pcomp DU[] (mg/c (mg/c M2[..] ‚Ä¢/a1) ‚Ä¢/a1) (\z.O1') (\z.O2'')]
  | [_ ‚ä¢ Œ∫‚äï1] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/inl (upd/n U1') \y.O1) (\x.O2)] = d in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    let [_ ‚ä¢ _]:[_ ‚ä¢ upd _ _ _ _ (B1[] ‚äï _) _ _ _ _] = [_ ‚ä¢ U1] in
    let [_ ‚ä¢ merge-upd2 U2 U ‚Ä¢/a1 M2 _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M1] [ ‚ä¢ ‚Ä¢/us] in
    let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U2] (upd_refl [_ ‚ä¢ U2]) in
    % Typing judgments
    let [_,x:obj,y:obj ‚ä¢ O1'[..,y,x]] = oft_exch_top [_,x:obj,y:obj ‚ä¢ O1] in
    let [_,x:obj,y:obj ‚ä¢ O2'] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O2[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B1]) in
    % Conclusion
    [_ ‚ä¢ oft/inl U \x.oft/pcomp DU[] (mg/c M2[..] ‚Ä¢/a1) (\y.O1') (\y.O2')]
  | [_ ‚ä¢ Œ∫‚äï2] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/inr (upd/n U1') \y.O1) (\x.O2)] = d in
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    let [_ ‚ä¢ _]:[_ ‚ä¢ upd _ _ _ _ (_ ‚äï B2[]) _ _ _ _] = [_ ‚ä¢ U1] in
    let [_ ‚ä¢ merge-upd2 U2 U ‚Ä¢/a1 M2 _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M1] [ ‚ä¢ ‚Ä¢/us] in
    let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U2] (upd_refl [_ ‚ä¢ U2]) in
    % Typing judgments
    let [_,x:obj,y:obj ‚ä¢ O1'[..,y,x]] = oft_exch_top [_,x:obj,y:obj ‚ä¢ O1] in
    let [_,x:obj,y:obj ‚ä¢ O2'] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O2[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B2]) in
    % Conclusion
    [_ ‚ä¢ oft/inr U \x.oft/pcomp DU[] (mg/c M2[..] ‚Ä¢/a1) (\y.O1') (\y.O2')]
  | [_ ‚ä¢ Œ∫&] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M1 (\x.oft/choice (upd/n U1') (\y.O1) (\y.O2)) (\x.O3)] = d in
    % Get `update` and `merge` judgments
    let Prune-Upd [_ ‚ä¢ U1] [_,x:obj ‚ä¢ _] = prune_upd [_,x:obj ‚ä¢ U1'] in
    let [_ ‚ä¢ _]:[_ ‚ä¢ upd _ _ _ _ (B1[] & B2[]) _ _ _ _] = [_ ‚ä¢ U1] in
    let [_ ‚ä¢ merge-upd2 U2 U ‚Ä¢/a1 M2 _ _ _] = merge_upd_cor2 [_ ‚ä¢ U1] [_ ‚ä¢ M1] [ ‚ä¢ ‚Ä¢/us] in
    let [_ ‚ä¢ cx/refl] = upd_func [_ ‚ä¢ U2] (upd_refl [_ ‚ä¢ U2]) in
    % Typing judgments
    let [_,x:obj,y:obj ‚ä¢ O1_sw[..,y,x]] = oft_exch_top [_,x:obj,y:obj ‚ä¢ O1] in
    let [_,x:obj,y:obj ‚ä¢ O2_sw[..,y,x]] = oft_exch_top [_,x:obj,y:obj ‚ä¢ O2] in
    let [_,x:obj,y:obj ‚ä¢ O3a] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O3[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B1]) in
    let [_,x:obj,y:obj ‚ä¢ O3b] = oft_exch_top (oft_weak [_,x:obj,y:obj ‚ä¢ O3[..,y]] [_,x:obj,y:obj ‚ä¢ x] [ ‚ä¢ B2]) in
    % Conclusion
    [_ ‚ä¢ oft/choice U (\x.oft/pcomp DU[] (mg/c M2[..] ‚Ä¢/a1) (\y.O1_sw) (\y.O3a)) (\x.oft/pcomp DU[] (mg/c M2[..] ‚Ä¢/a1) (\y.O2_sw) (\y.O3b))]
  % Reduction under cut
  | [_ ‚ä¢ Œ≤‚à•1 \x.RD1] ‚áí
    let [_ ‚ä¢ oft/pcomp DU[] M (\x.O1') (\x.O2)] = d in
    let [_,x:obj ‚ä¢ O1] = tps [_,x:obj ‚ä¢ RD1] [_,x:obj ‚ä¢ O1'] in
    [_ ‚ä¢ oft/pcomp DU[] M (\x.O1) (\x.O2)]
  | [_ ‚ä¢ Œ≤‚à•2 \x.RD1] ‚áí 
    let [_ ‚ä¢ oft/pcomp DU[] M (\x.O1) (\x.O2')] = d in
    let [_,x:obj ‚ä¢ O2] = tps [_,x:obj ‚ä¢ RD1] [_,x:obj ‚ä¢ O2'] in
    [_ ‚ä¢ oft/pcomp DU[] M (\x.O1) (\x.O2)]
  % Reductions commute with equivalences
  | [_ ‚ä¢ Œ≤‚â° CG1 RD1 CG2] ‚áí oft_cong (tps [_ ‚ä¢ RD1] (oft_cong d [_ ‚ä¢ CG1])) [_ ‚ä¢ CG2]
  ;

% Equivalence of CP and SCP

rec cp2scp : Enc [Œ® ‚ä¢ Œî] $[Œ¶ ‚ä¢ $œÉ] ‚Üí [Œ® ‚ä¢ oft P Œî] ‚Üí [Œ¶ ‚ä¢ wtp P[$œÉ]] =
  / total 2 / 
  fn ec, d ‚áí
  let _ : Enc [_ ‚ä¢ _] $[_ ‚ä¢ $œÉ] = ec in
  case d of
  | [_ ‚ä¢ oft/fwd DU[] U1 U2 E] ‚áí
    let [_ ‚ä¢ lookintm U3] = lookup_upd (upd_symm [_ ‚ä¢ U1]) [_ ‚ä¢ U2] (lookup_lab_neq_2 (upd_symm [_ ‚ä¢ U1]) [_ ‚ä¢ U2]) in
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U3] in
    let [_ ‚ä¢ hy] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    [_ ‚ä¢ wtp_fwd DU[] _ hx _ hy]
  | [_ ‚ä¢ oft/close U1 _] ‚áí
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    [_ ‚ä¢ wtp_close _ hx]
  | [_ ‚ä¢ oft/wait U1 O1] ‚áí
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    let [_ ‚ä¢ W] = cp2scp (encctx_upd ec [_ ‚ä¢ U1]) [_ ‚ä¢ O1] in
    [_ ‚ä¢ wtp_wait _ hx W]
  | [_ ‚ä¢ oft/out U1 M (\x.O1) (\x.O2)] ‚áí
    let [_ ‚ä¢ M_comm] = merge_comm [_ ‚ä¢ M] in
    let [_ ‚ä¢ merge-look2 _ U2 ‚Ä¢/a1 _ _] = merge_lookup2 [_ ‚ä¢ U1] [_ ‚ä¢ M_comm] in
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U2] in
    let [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1] = cp2scp (Enc/c (encctx_merge ec [_ ‚ä¢ M]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1] in
    let [_,b:block x:obj,h:hyp _ _ ‚ä¢ W2] =
      cp2scp (Enc/c (encctx_upd (encctx_merge ec (merge_comm [_ ‚ä¢ M])) [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O2] in
    let [_ ‚ä¢ LN] = oft_linear [_,x:obj ‚ä¢ O1] in
    [_ ‚ä¢ wtp_out LN[$œÉ] _ hx (\y.\hy.W1[..,<y;hy>]) (\y.\hy.W2[..,<y;hy>])]
  | [_ ‚ä¢ oft/inp U1 \x.\y.O1] ‚áí
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    let [_,b1:block (x:obj,hx:hyp _ _),b2:block (y:obj,hy:hyp _ _) ‚ä¢ W] =
      cp2scp (Enc/c (Enc/c (encctx_upd ec [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj,y:obj ‚ä¢ O1] in
    let [_ ‚ä¢ _]:[_ ‚ä¢ upd _ _ _ _ (A[] ‚Öã _) _ _ _ _] = [_ ‚ä¢ U1] in
    let [_,x:obj ‚ä¢ LN] = oft_linear [_,x:obj,y:obj ‚ä¢ O1] in
    [_ ‚ä¢ wtp_inp (\x.LN[$œÉ[..],x]) _ hx (\y.\hy.\z.\hz.W[..,<y;hy>,<z;hz>])]
  | [_ ‚ä¢ oft/pcomp DU[] M (\x.O1) (\x.O2)] ‚áí
    let [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1] = cp2scp (Enc/c (encctx_merge ec [_ ‚ä¢ M]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1] in
    let [_,b:block x:obj,h:hyp _ _ ‚ä¢ W2] = cp2scp (Enc/c (encctx_merge ec (merge_comm [_ ‚ä¢ M])) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O2] in
    let [_ ‚ä¢ LN1] = oft_linear [_,x:obj ‚ä¢ O1] in
    let [_ ‚ä¢ LN2] = oft_linear [_,x:obj ‚ä¢ O2] in
    [_ ‚ä¢ wtp_pcomp DU[] (\x.\hx.W1[..,<x;hx>]) (\x.\hx.W2[..,<x;hx>]) LN1[$œÉ] LN2[$œÉ]]
  | [_ ‚ä¢ oft/inl U1 \x.O1] ‚áí
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    let [_,b:block x:obj,h:hyp _ _ ‚ä¢ W] = cp2scp (Enc/c (encctx_upd ec [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1] in
    [_ ‚ä¢ wtp_inl _ hx (\y.\hy.W[..,<y;hy>])]
  | [_ ‚ä¢ oft/inr U1 \x.O1] ‚áí
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    let [_,b:block x:obj,h:hyp _ _ ‚ä¢ W] = cp2scp (Enc/c (encctx_upd ec [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1] in
    [_ ‚ä¢ wtp_inr _ hx (\y.\hy.W[..,<y;hy>])]
  | [_ ‚ä¢ oft/choice U1 (\x.O1) (\x.O2)] ‚áí
    let [_ ‚ä¢ hx] = lookup_to_hyp ec [_ ‚ä¢ U1] in
    let [_,b:block x:obj,hx:hyp x _ ‚ä¢ W1] = cp2scp (Enc/c (encctx_upd ec [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1] in
    let [_,b:block x:obj,hx:hyp x _ ‚ä¢ W2] = cp2scp (Enc/c (encctx_upd ec [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O2] in
    [_ ‚ä¢ wtp_choice _ hx (\y.\hy.W1[..,<y;hy>]) (\y.\hy.W2[..,<y;hy>])]
  ;

rec scp2cp : Dec [Œ® ‚ä¢ P] [Œ® ‚ä¢ Œî] $[Œ¶ ‚ä¢ $œÉ] ‚Üí [Œ¶ ‚ä¢ wtp P[$œÉ]] ‚Üí [Œ® ‚ä¢ oft P Œî] =
  / total 2 / 
  fn dc, w ‚áí case dc of
  | Dec/fwd U1 RN ‚áí
    let [_ ‚ä¢ U1'] = U1 in
    let [_ ‚ä¢ wtp_fwd DU[] _ hx _ hy] = w in
    let [_ ‚ä¢ unql U2 E] = relnm_unqlin RN [_ ‚ä¢ hx] in
    let [ ‚ä¢ refl] = hyp_unq [_ ‚ä¢ hy] (dec_lookup_hyp dc U1) in
    [_ ‚ä¢ oft/fwd DU[] U1' U2 E]
  | Dec/close RN ‚áí
    let [_ ‚ä¢ wtp_close _ hx] = w in 
    let [_ ‚ä¢ unql U1 E] = relnm_unqlin RN [_ ‚ä¢ hx] in
    [_ ‚ä¢ oft/close U1 E]
  | Dec/wait U1 DC1 ‚áí
    let [_ ‚ä¢ U1'] = U1 in
    let [_ ‚ä¢ wtp_wait _ hx W1] = w in
    let [_ ‚ä¢ O] = scp2cp DC1 [_ ‚ä¢ W1] in
    [_ ‚ä¢ oft/wait U1' O]
  | Dec/out U1 M DC1 DC2 ‚áí
    let ([_ ‚ä¢ U1'],[_ ‚ä¢ M'],[_ ‚ä¢ M_comm]) = (U1,M,merge_comm M) in
    let [_ ‚ä¢ wtp_out _ _ hx (\y.\hy.W1) (\y.\hy.W2)] = w in
    let [_ ‚ä¢ merge-look2 _ U2 ‚Ä¢/a1 _ _] = merge_lookup2 [_ ‚ä¢ U1'] [_ ‚ä¢ M_comm] in
    let [ ‚ä¢ refl] = hyp_unq [_ ‚ä¢ hx] (dec_lookup_hyp dc [_ ‚ä¢ U2]) in
    let [_,x:obj ‚ä¢ O1] = scp2cp DC1 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1[..,b.1,b.2]] in
    let [_,x:obj ‚ä¢ O2] = scp2cp DC2 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W2[..,b.1,b.2]] in
    [_ ‚ä¢ oft/out U1' M' (\x.O1) (\x.O2)] 
  | Dec/inp U1 DC1 ‚áí
    let [_ ‚ä¢ U1'] = U1 in
    let [_ ‚ä¢ wtp_inp (\y._) _ hx \y.\hy.\z.\hz.W1] = w in
    let [ ‚ä¢ refl] = hyp_unq [_ ‚ä¢ hx] (dec_lookup_hyp dc U1) in
    let [_,x:obj,y:obj ‚ä¢ O1] = scp2cp DC1 [_,b1:block (y:obj,hy:hyp _ _),b2:block (z:obj,hz:hyp _ _) ‚ä¢ W1[..,b1.1,b1.2,b2.1,b2.2]] in
    [_ ‚ä¢ oft/inp U1' \x.\y.O1]
  | Dec/pcomp M DU1 DC1 DC2 ‚áí
    let [_ ‚ä¢ M'] = M in
    let [_ ‚ä¢ wtp_pcomp DU2[] (\y.\hy.W1) (\y.\hy.W2) _ _] = w in
    let [_,x:obj ‚ä¢ O1] = scp2cp DC1 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1[..,b.1,b.2]] in
    let [ ‚ä¢ refl] = dual_uniq DU1 [ ‚ä¢ DU2] in
    let [_,x:obj ‚ä¢ O2] = scp2cp DC2 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W2[..,b.1,b.2]] in
    [_ ‚ä¢ oft/pcomp DU2[] M' (\x.O1) (\x.O2)]
  | Dec/inl U1 DC1 ‚áí
    let [_ ‚ä¢ U1'] = U1 in
    let [_ ‚ä¢ wtp_inl _ hx \y.\hy.W1] = w in
    let [ ‚ä¢ refl] = hyp_unq [_ ‚ä¢ hx] (dec_lookup_hyp dc U1) in
    let [_,x:obj ‚ä¢ O] = scp2cp DC1 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1[..,b.1,b.2]] in
    [_ ‚ä¢ oft/inl U1' \x.O]
  | Dec/inr U1 DC1 ‚áí
    let [_ ‚ä¢ U1'] = U1 in
    let [_ ‚ä¢ wtp_inr _ hx \y.\hy.W1] = w in
    let [ ‚ä¢ refl] = hyp_unq [_ ‚ä¢ hx] (dec_lookup_hyp dc U1) in
    let [_,x:obj ‚ä¢ O] = scp2cp DC1 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1[..,b.1,b.2]] in
    [_ ‚ä¢ oft/inr U1' \x.O]
  | Dec/choice U1 DC1 DC2 ‚áí
    let [_ ‚ä¢ U1'] = U1 in
    let [_ ‚ä¢ wtp_choice _ hx (\y.\hy.W1) (\y.\hy.W2)] = w in
    let [ ‚ä¢ refl] = hyp_unq [_ ‚ä¢ hx] (dec_lookup_hyp dc U1) in
    let [_,x:obj ‚ä¢ O1] = scp2cp DC1 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W1[..,b.1,b.2]] in
    let [_,x:obj ‚ä¢ O2] = scp2cp DC2 [_,b:block x:obj,h:hyp _ _ ‚ä¢ W2[..,b.1,b.2]] in
    [_ ‚ä¢ oft/choice U1' (\x.O1) (\x.O2)]
  ;

% Invertibility of translation

rec enc2dec : Enc [Œ® ‚ä¢ Œî] $[Œ¶ ‚ä¢ $œÉ] ‚Üí [Œ® ‚ä¢ oft P Œî] ‚Üí Dec [Œ® ‚ä¢ P] [Œ® ‚ä¢ Œî] $[Œ¶ ‚ä¢ $œÉ] =
  / total 2 /
  fn e, d ‚áí case d of
  | [_ ‚ä¢ oft/fwd DU[] U1 U2 E] ‚áí Dec/fwd [_ ‚ä¢ U1] (unqlin_to_relnm (encctx_upd e [_ ‚ä¢ U1]) [_ ‚ä¢ U2] [_ ‚ä¢ E])
  | [_ ‚ä¢ oft/close U1 E] ‚áí Dec/close (unqlin_to_relnm e [_ ‚ä¢ U1] [_ ‚ä¢ E])
  | [_ ‚ä¢ oft/wait U1 O1] ‚áí Dec/wait [_ ‚ä¢ U1] (enc2dec (encctx_upd e [_ ‚ä¢ U1]) [_ ‚ä¢ O1])
  | [_ ‚ä¢ oft/out U1 M (\x.O1) (\x.O2)] ‚áí
    Dec/out [_ ‚ä¢ U1] [_ ‚ä¢ M] (enc2dec (Enc/c (encctx_merge e [_ ‚ä¢ M]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1])
      (enc2dec (Enc/c (encctx_upd (encctx_merge e (merge_comm [_ ‚ä¢ M])) [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O2])
  | [_ ‚ä¢ oft/inp U1 (\x.\y.O1)] ‚áí
    Dec/inp [_ ‚ä¢ U1] (enc2dec (Enc/c (Enc/c (encctx_upd e [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj,y:obj ‚ä¢ O1])
  | [_ ‚ä¢ oft/pcomp DU[] M (\x.O1) (\x.O2)] ‚áí
    Dec/pcomp [_ ‚ä¢ M] [ ‚ä¢ DU] (enc2dec (Enc/c (encctx_merge e [_ ‚ä¢ M]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1])
      (enc2dec (Enc/c (encctx_merge e (merge_comm [_ ‚ä¢ M])) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O2])
  | [_ ‚ä¢ oft/inl U1 (\x.O1)] ‚áí Dec/inl [_ ‚ä¢ U1] (enc2dec (Enc/c (encctx_upd e [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1])
  | [_ ‚ä¢ oft/inr U1 (\x.O1)] ‚áí Dec/inr [_ ‚ä¢ U1] (enc2dec (Enc/c (encctx_upd e [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1])
  | [_ ‚ä¢ oft/choice U1 (\x.O1) (\x.O2)] ‚áí
    Dec/choice [_ ‚ä¢ U1] (enc2dec (Enc/c (encctx_upd e [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O1])
      (enc2dec (Enc/c (encctx_upd e [_ ‚ä¢ U1]) [ ‚ä¢ _] [ ‚ä¢ _]) [_,x:obj ‚ä¢ O2])
  ;

rec dec2enc : Dec [Œ® ‚ä¢ P] [Œ® ‚ä¢ Œî] $[Œ¶ ‚ä¢ $œÉ] ‚Üí Enc [Œ® ‚ä¢ Œî] $[Œ¶ ‚ä¢ $œÉ] =
  % Remark: Beluga's totality checker cannot check coverage in this case
  fn d ‚áí case d of
  | Dec/fwd U1 RN ‚áí encctx_upd (relnm_to_encctx RN) (upd_symm U1)
  | Dec/close RN ‚áí relnm_to_encctx RN
  | Dec/wait U1 DC1 ‚áí encctx_upd (dec2enc DC1) (upd_symm U1)
  | Dec/out _ M DC1 _ ‚áí let Enc/c EC1 [ ‚ä¢ _] [ ‚ä¢ _] = dec2enc DC1 in encctx_merge_l EC1 M
  | Dec/inp U1 DC1 ‚áí
    let Enc/c (Enc/c EC1 [ ‚ä¢ _] [ ‚ä¢ _]) [ ‚ä¢ _] [ ‚ä¢ _] = dec2enc DC1 in
    encctx_upd EC1 (upd_symm U1)
  | Dec/pcomp M _ DC1 _ ‚áí let Enc/c EC1 [ ‚ä¢ _] [ ‚ä¢ _] = dec2enc DC1 in encctx_merge_l EC1 M
  | Dec/inl U1 DC1 ‚áí let Enc/c EC1 [ ‚ä¢ _] [ ‚ä¢ _] = dec2enc DC1 in encctx_upd EC1 (upd_symm U1)
  | Dec/inr U1 DC1 ‚áí let Enc/c EC1 [ ‚ä¢ _] [ ‚ä¢ _] = dec2enc DC1 in encctx_upd EC1 (upd_symm U1)
  | Dec/choice U1 DC1 _ ‚áí let Enc/c EC1 [ ‚ä¢ _] [ ‚ä¢ _] = dec2enc DC1 in encctx_upd EC1 (upd_symm U1)
  ;