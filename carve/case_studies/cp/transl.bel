%======================================================%
% Translation between CP and SCP
%======================================================%

%------------------------------------------------------%
% Translation from CP to SCP
%------------------------------------------------------%

% Enc relates Î¦ and Î”, and builds a weakening substitution that maps names in Î¨ to names in Î¦
% Wf [Î¨ âŠ¢ Î”] is implicit, since Î¦ contains only unique assumptions

inductive Enc : (Î¨:ctx) (Î¦:hctx) {Î”:[Î¨ âŠ¢ lctx N[]]} {$Ïƒ:$[Î¦ âŠ¢ Î¨]} ctype =
| Enc/n : Enc [ âŠ¢ nil] $[ âŠ¢ ^]
| Enc/c : Enc [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
  â†’ {A:[ âŠ¢ tp]} {Î±:[ âŠ¢ mult]} Enc [Î¨,x:obj âŠ¢ cons Î”[..] x A[] Î±[]] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1];

%------------------------------------------------------%
% Translation from SCP to CP
%------------------------------------------------------%

% Relate Î¦ with a typing context Î” in which all names are assigned the multiplicity ğŸ˜

inductive RelUsed : (Î¦:hctx) (Î¨:ctx) {Î”:[Î¨ âŠ¢ lctx N[]]} {$Ïƒ:$[Î¦ âŠ¢ Î¨]} ctype =
| relUsed/n : RelUsed [ âŠ¢ nil] $[ âŠ¢ ^]
| relUsed/c : RelUsed [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
  â†’ RelUsed [Î¨,x:obj âŠ¢ cons Î”[..] x A[] ğŸ˜] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1];

% Relate Î¦ with a typing context Î” containing the same typing information, but will all names except X set as `used`

inductive RelName : (Î¨:ctx) (Î¦:hctx) {X:[Î¨ âŠ¢ obj]} {Î”:[Î¨ âŠ¢ lctx N[]]} {$Ïƒ:$[Î¦ âŠ¢ Î¨]} ctype = 
| relName/t : RelUsed [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
  â†’ RelName [Î¨,x:obj âŠ¢ x] [Î¨,x:obj âŠ¢ cons Î”[..] x A[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1]
| relName/n : RelName [Î¨ âŠ¢ X] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
  â†’ RelName [Î¨,x:obj âŠ¢ X[..]] [Î¨,x:obj âŠ¢ cons Î”[..] x B[] ğŸ˜] $[Î¦,b:block x:obj,h:hyp x B[] âŠ¢ $Ïƒ[..],b.1];

% Dec relates Î¦ and Î”, where the choice of multiplicities in Î” depends on some process P;
% ensures that the process is linear w.r.t. all linear channels in the context; and
% builds a weakening substitution that maps names in Î¨ to variables in Î¦.
% Wf [Î¨ âŠ¢ Î”] is implicit since Î¦ contains only unique assumptions

inductive Dec : (Î¨:ctx) (Î¦:hctx) {P:[Î¨ âŠ¢ obj]} {Î”:[Î¨ âŠ¢ lctx N[]]} {$Ïƒ:$[Î¦ âŠ¢ Î¨]} ctype = 
| Dec/fwd : [Î¨ âŠ¢ upd Î” m[] Y Y A'[] A'[] ğŸ™ ğŸ˜ Î”'] % x,y are the only linear channels in Î”
  â†’ RelName [Î¨ âŠ¢ X] [Î¨ âŠ¢ Î”'] $[Î¦ âŠ¢ $Ïƒ] % x is the only linear channel in Î”'
  â†’ Dec [Î¨ âŠ¢ fwd X Y] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/close : RelName [Î¨ âŠ¢ X] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
  â†’ Dec [Î¨ âŠ¢ close X] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/wait : [Î¨ âŠ¢ upd Î” n[] X X âŠ¥ âŠ¥ ğŸ™ ğŸ˜ Î”']
  â†’ Dec [Î¨ âŠ¢ P] [Î¨ âŠ¢ Î”'] $[Î¦ âŠ¢ $Ïƒ]
  â†’ Dec [Î¨ âŠ¢ wait X P] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/out : [Î¨ âŠ¢ upd Î”â‚‚ n[] X X (A[] âŠ— B[]) (A[] âŠ— B[]) ğŸ™ ğŸ˜ Î”â‚‚']
  â†’ [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”]
  â†’ Dec [Î¨,x:obj âŠ¢ P] [Î¨,x:obj âŠ¢ cons Î”â‚[..] x A[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨,x:obj âŠ¢ Q] [Î¨,x:obj âŠ¢ cons Î”â‚‚'[..] x B[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x B[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨ âŠ¢ out X (\x.P) (\x.Q)] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/inp : [Î¨ âŠ¢ upd Î” n[] X X (A[] â…‹ B[]) (A[] â…‹ B[]) ğŸ™ ğŸ˜ Î”']
  â†’ Dec [Î¨,y:obj,x:obj âŠ¢ P[..,y,x]] [Î¨,y:obj,x:obj âŠ¢ cons (cons Î”'[..] y B[] ğŸ™) x A[] ğŸ™]
    $[Î¦,b1:block (y:obj,h:hyp y B[]),b2:block (x:obj,h:hyp x A[]) âŠ¢ $Ïƒ[..],b1.1,b2.1]
  â†’ Dec [Î¨ âŠ¢ inp X \y.\x.P] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/pcomp : [Î¨ âŠ¢ merge Î”â‚ Î”â‚‚ Î”] â†’ [ âŠ¢ dual A A']
  â†’ Dec [Î¨,x:obj âŠ¢ P] [Î¨,x:obj âŠ¢ cons Î”â‚[..] x A[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨,x:obj âŠ¢ Q] [Î¨,x:obj âŠ¢ cons Î”â‚‚[..] x A'[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x A'[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨ âŠ¢ pcomp A[] (\x.P) (\x.Q)] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/inl : [Î¨ âŠ¢ upd Î” n[] X X (A[] âŠ• B[]) (A[] âŠ• B[]) ğŸ™ ğŸ˜ Î”']
  â†’ Dec [Î¨,x:obj âŠ¢ P] [Î¨,x:obj âŠ¢ cons Î”'[..] x A[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨ âŠ¢ inl X \x.P] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/inr : [Î¨ âŠ¢ upd Î” n[] X X (A[] âŠ• B[]) (A[] âŠ• B[]) ğŸ™ ğŸ˜ Î”']
  â†’ Dec [Î¨,x:obj âŠ¢ P] [Î¨,x:obj âŠ¢ cons Î”'[..] x B[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x B[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨ âŠ¢ inr X \x.P] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ]
| Dec/choice : [Î¨ âŠ¢ upd Î” n[] X X (A[] & B[]) (A[] & B[]) ğŸ™ ğŸ˜ Î”']
  â†’ Dec [Î¨,x:obj âŠ¢ P] [Î¨,x:obj âŠ¢ cons Î”'[..] x A[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x A[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨,x:obj âŠ¢ Q] [Î¨,x:obj âŠ¢ cons Î”'[..] x B[] ğŸ™] $[Î¦,b:block x:obj,h:hyp x B[] âŠ¢ $Ïƒ[..],b.1]
  â†’ Dec [Î¨ âŠ¢ choice X (\x.P) (\x.Q)] [Î¨ âŠ¢ Î”] $[Î¦ âŠ¢ $Ïƒ];