%======================================================%
% Lemmas about translation from SCP to CP
%======================================================%

%------------------------------------------------------%
% Appearance of names in processes
%------------------------------------------------------%

% If P does not depend on the variable x then x โ P

rec in_proc_lemma : (ฮจ:ctx) [ฮจ,x:obj โข in_proc x P[..]] โ [ โข false] =
  / total d (in_proc_lemma d) /
  fn a โ case a of
  | [_,x:obj โข inpr/wait_2 A1] โ in_proc_lemma [_,x:obj โข A1]
  | [_,x:obj โข inpr/out_2 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/out_3 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/inp_2 (\y.\z.A1)] โ in_proc_lemma [_,x:obj,y:obj,z:obj โข A1[..,z,x,y]]
  | [_,x:obj โข inpr/pcomp_1 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/pcomp_2 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/inl_2' (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/inr_2 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/choice_2 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  | [_,x:obj โข inpr/choice_3 (\y.A1)] โ in_proc_lemma [_,x:obj,y:obj โข A1[..,y,x]]
  ;

% If P โข ฮ and x appears linearly in ฮ, then x โ P

rec oft_lin_in : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft P ฮ] โ [ฮจ โข upd ฮ n[] X X' A[] A'[] ๐ ฮฑ[] ฮ'] โ [ฮจ โข in_proc X P] =
  / total d (oft_lin_in d) /
  fn d1, u โ
  let [_ โข U_ub] = u in
  case d1 of
  | [_ โข oft/fwd _ U1 U2 E] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/fwd_2]
    | [_ โข look-neq NEQ1[] _ _] โ
      let [_ โข lookintm U'] = lookup_upd [_ โข U1] u [ โข NEQ1] in
      (case comp_look [_ โข U2] [_ โข U'] of
      | [_ โข look-eq _ _] โ [_ โข inpr/fwd_1]
      | [_ โข look-neq NEQ2[] _ _] โ
        let [_ โข lookintm U3] = lookup_upd [_ โข U2] [_ โข U'] [ โข NEQ2] in
        impossible exh_lookup [_ โข E] [_ โข U3]
      )
    )
  | [_ โข oft/close U1 E] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/close]
    | [_ โข look-neq NEQ[] _ _] โ
      let [_ โข lookintm U2] = lookup_upd [_ โข U1] u [ โข NEQ] in
      impossible exh_lookup [_ โข E] [_ โข U2]
    )
  | [_ โข oft/wait U1 O1] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/wait_1]
    | [_ โข look-neq NEQ[] _ _] โ
      let [_ โข lookintm U2] = lookup_upd [_ โข U1] u [ โข NEQ] in
      let [_ โข A] = oft_lin_in [_ โข O1] [_ โข U2] in
      [_ โข inpr/wait_2 A]
    )
  | [_ โข oft/out U1 M (\x.O1) (\x.O2)] โ
    let [_ โข merge-look U2 U3 T[] _ _] = merge_lookup [_ โข U_ub] [_ โข M] in
    (case comp_look [_ โข U1] [_ โข U3] of
    | [_ โข look-eq _ _] โ [_ โข inpr/out_1]
    | [_ โข look-neq NEQ[] _ _] โ
      (case [ โข T] of
      | [ โข โข/a1] โ
        let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O1] [_ โข upd/n U2[..]] in
        [_ โข inpr/out_2 \x.A]
      | [ โข โข/a2] โ
        let [_ โข lookintm U3'] = lookup_upd [_ โข U1] [_ โข U3] [ โข NEQ] in
        let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O2] [_ โข upd/n U3'[..]] in
        [_ โข inpr/out_3 \x.A]
      )
    )
  | [_ โข oft/inp U1 \x.\y.O1] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/inp_1]
    | [_ โข look-neq NEQ[] _ _] โ
      let [_ โข lookintm U2] = lookup_upd [_ โข U1] u [ โข NEQ] in
      let [_,x:obj,y:obj โข A] = oft_lin_in [_,x:obj,y:obj โข O1] [_ โข upd/n (upd/n U2[..])] in
      [_ โข inpr/inp_2 \x.\y.A]
    )
  | [_ โข oft/pcomp _ M (\x.O1) (\x.O2)] โ
    (case merge_lookup [_ โข U_ub] [_ โข M] of
    | [_ โข merge-look U1 _ โข/a1 _ _] โ
      let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O1] [_ โข upd/n U1[..]] in
      [_ โข inpr/pcomp_1 \x.A]
    | [_ โข merge-look _ U2 โข/a2 _ _] โ
      let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O2] [_ โข upd/n U2[..]] in
      [_ โข inpr/pcomp_2 \x.A]
    )
  | [_ โข oft/inl U1 \x.O1] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/inl_1]
    | [_ โข look-neq NEQ[] _ _] โ
      let [_ โข lookintm U2] = lookup_upd [_ โข U1] u [ โข NEQ] in
      let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O1] [_ โข upd/n U2[..]] in
      [_ โข inpr/inl_2' \x.A]
    )
  | [_ โข oft/inr U1 \x.O1] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/inr_1]
    | [_ โข look-neq NEQ[] _ _] โ
      let [_ โข lookintm U2] = lookup_upd [_ โข U1] u [ โข NEQ] in
      let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O1] [_ โข upd/n U2[..]] in
      [_ โข inpr/inr_2 \x.A]
    )
  | [_ โข oft/choice U1 (\x.O1) (\x.O2)] โ
    (case comp_look [_ โข U1] [_ โข U_ub] of
    | [_ โข look-eq _ _] โ [_ โข inpr/choice_1]
    | [_ โข look-neq NEQ[] _ _] โ
      let [_ โข lookintm U2] = lookup_upd [_ โข U1] u [ โข NEQ] in
      let [_,x:obj โข A] = oft_lin_in [_,x:obj โข O1] [_ โข upd/n U2[..]] in
      [_ โข inpr/choice_2 \x.A]
    )
  ;

%------------------------------------------------------%
% Structural properties of CP typing judgment
%------------------------------------------------------%

% 'Prune' LF context to remove dependencies:
% Obtain from [ฮจ,x:obj โข oft P ฮ[..]] that P cannot depend on x

inductive PruneOft : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) {O:[ฮจ โข oft P ฮ]} ctype =
  Prune-Oft : [ฮจ โข oft P ฮ] โ {O:[ฮจ,x:obj โข oft P[..] ฮ[..]]} PruneOft [ฮจ,x:obj โข O];

rec prune_oft : {O:[ฮจ,x:obj โข oft P ฮ[..]]} PruneOft [ฮจ,x:obj โข O] =
  / total d (prune_oft d) /
  mlam O โ case [_ โข O] of
  | [_,x:obj โข oft/fwd DU[] U1 U2 E] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Upd [_ โข U2'] [_,x:obj โข _] = prune_upd [_,x:obj โข U2] in
    let [_ โข E'] = prune_exh [_ โข E] in
    Prune-Oft [_ โข oft/fwd DU[] U1' U2' E'] [_,x:obj โข _]
  | [_,x:obj โข oft/close U1 E] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let [_ โข E'] = prune_exh [_ โข E] in
    Prune-Oft [_ โข oft/close U1' E'] [_,x:obj โข _]
  | [_,x:obj โข oft/wait U1 O1] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Oft [_ โข O1'] [_,x:obj โข _] = prune_oft [_,x:obj โข O1] in
    Prune-Oft [_ โข oft/wait U1' O1'] [_,x:obj โข _]
  | [_,x:obj โข oft/out U1 M (\y.O1) (\y.O2)] โ
    let Prune-Merge [_ โข M'] [_,x:obj โข _] = prune_merge [_,x:obj โข M] in
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1[..,y,x]] in
    let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2[..,y,x]] in
    Prune-Oft [_ โข oft/out U1' M' (\x.O1') (\x.O2')] [_,x:obj โข _]
  | [_,x:obj โข oft/inp U1 \z.\w.O1] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Oft [_,x:obj,y:obj โข O1'] [_ โข _] = prune_oft [_,x:obj,y:obj,z:obj โข O1[..,z,x,y]] in
    Prune-Oft [_ โข oft/inp U1' \z.\w.O1'] [_,x:obj โข _]
  | [_,x:obj โข oft/pcomp DU[] M (\y.O1) (\y.O2)] โ
    let Prune-Merge [_ โข M'] [_,x:obj โข _] = prune_merge [_,x:obj โข M] in
    let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1[..,y,x]] in
    let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2[..,y,x]] in
    Prune-Oft [_ โข oft/pcomp DU[] M' (\x.O1') (\x.O2')] [_,x:obj โข _]
  | [_,x:obj โข oft/inl U1 \y.O1] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1[..,y,x]] in
    Prune-Oft [_ โข oft/inl U1' \x.O1'] [_,x:obj โข _]
  | [_,x:obj โข oft/inr U1 \y.O1] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1[..,y,x]] in
    Prune-Oft [_ โข oft/inr U1' \x.O1'] [_,x:obj โข _]
  | [_,x:obj โข oft/choice U1 (\y.O1) (\y.O2)] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1[..,y,x]] in
    let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2[..,y,x]] in
    Prune-Oft [_ โข oft/choice U1' (\x.O1') (\x.O2')] [_,x:obj โข _]
  ;

% Exchange lemma:
% If P โข ฮ and ฮ[(n, x) โ (m, y)] = ฮ', P โข ฮ'
% (Plus two corollaries as helper lemmas for permuting the topmost elements of a context)

rec oft_exch : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft P ฮ] โ [ฮจ โข exch ฮ n X m Y ฮ'] โ [ฮจ โข oft P ฮ'] =
  fn d1, ex1 โ
  let [_ โข exch/u NEQ[] EX1 EX2] = ex1 in
  case d1 of
  | [_ โข oft/fwd DU U1 U2 E1] โ
    let [_ โข exch-e EX1' EX2' U3 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_ โข exch-e EX1'' EX2'' U4 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1'] [_ โข EX2'] [_ โข U2] in
    let [_ โข E2] = exch_exh [_ โข E1] [_ โข exch/u NEQ[] EX1'' EX2''] in
    [_ โข oft/fwd DU U3 U4 E2]
  | [_ โข oft/close U1 E1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_ โข E2] = exch_exh [_ โข E1] [_ โข exch/u NEQ[] EX1' EX2'] in
    [_ โข oft/close U2 E2]
  | [_ โข oft/wait U1 O1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_ โข O2] = oft_exch [_ โข O1] [_ โข exch/u NEQ[] EX1' EX2'] in
    [_ โข oft/wait U2 O2]
  | [_ โข oft/out U1 M1 (\x.O1) (\x.O2)] โ
    let [_ โข exch-mg EX1a EX2a EX1b EX2b _ M2 _ _ _ _ _] = exch_merge [_ โข EX1] [_ โข EX2] [_ โข M1] in
    let [_ โข exch-e EX1b' EX2b' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1b] [_ โข EX2b] [_ โข U1] in
    let [_,x:obj โข O1'] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n EX1a[..]) (upd/n EX2a[..])] in
    let [_,x:obj โข O2'] = oft_exch [_,x:obj โข O2] [_,x:obj โข exch/u NEQ[] (upd/n EX1b'[..]) (upd/n EX2b'[..])] in
    [_ โข oft/out U2 M2 (\x.O1') (\x.O2')]
  | [_ โข oft/inp U1 \x.\y.O1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_,x:obj,y:obj โข O2] = oft_exch [_,x:obj,y:obj โข O1] [_,x:obj,y:obj โข exch/u NEQ[] (upd/n (upd/n EX1'[..])) (upd/n (upd/n EX2'[..]))] in
    [_ โข oft/inp U2 \x.\y.O2]
  | [_ โข oft/pcomp DU M1 (\x.O1) (\x.O2)] โ
    let [_ โข exch-mg U1a U2a U1b U2b _ M2 _ _ _ _ _] = exch_merge [_ โข EX1] [_ โข EX2] [_ โข M1] in
    let [_,x:obj โข O1'] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n U1a[..]) (upd/n U2a[..])] in
    let [_,x:obj โข O2'] = oft_exch [_,x:obj โข O2] [_,x:obj โข exch/u NEQ[] (upd/n U1b[..]) (upd/n U2b[..])] in
    [_ โข oft/pcomp DU M2 (\x.O1') (\x.O2')]
  | [_ โข oft/inl U1 \x.O1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_,x:obj โข O2] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n EX1'[..]) (upd/n EX2'[..])] in
    [_ โข oft/inl U2 \x.O2]
  | [_ โข oft/inr U1 \x.O1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_,x:obj โข O2] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n EX1'[..]) (upd/n EX2'[..])] in
    [_ โข oft/inr U2 \x.O2]
  | [_ โข oft/choice U1 (\x.O1) (\x.O2)] โ 
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_,x:obj โข O1'] = oft_exch [_,x:obj โข O1] [_,x:obj โข exch/u NEQ[] (upd/n EX1'[..]) (upd/n EX2'[..])] in
    let [_,x:obj โข O2'] = oft_exch [_,x:obj โข O2] [_,x:obj โข exch/u NEQ[] (upd/n EX1'[..]) (upd/n EX2'[..])] in
    [_ โข oft/choice U2 (\x.O1') (\x.O2')]
  ;

rec oft_exch_top : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft P (cons (cons ฮ X A[] ฮฑ[]) Y B[] ฮฒ[])] โ [ฮจ โข oft P (cons (cons ฮ Y B[] ฮฒ[]) X A[] ฮฑ[])] =
  / total /
  fn O โ oft_exch O (exch_top [_ โข _] [_ โข _] [ โข _] [ โข _] [_ โข _] [ โข _] [ โข _])
  ;

rec oft_exch_top2 : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]])
[ฮจ โข oft P (cons (cons (cons ฮ X A ฮฑ) Y B ฮฒ) Z C ฮณ)] โ [ฮจ โข oft P (cons (cons (cons ฮ Y B ฮฒ) Z C ฮณ) X A ฮฑ)] =
  / total /
  fn d1 โ
  let [_ โข _]:[_ โข oft _ (cons (cons (cons ฮ X A[] ฮฑ[]) Y B[] ฮฒ[]) _ _ _)] = d1 in
  let [_ โข exch/u NEQ[] EX1 EX2] = exch_top [_ โข ฮ] [_ โข X] [ โข A] [ โข ฮฑ] [_ โข Y] [ โข B] [ โข ฮฒ] in
  oft_exch_top (oft_exch d1 [_ โข exch/u NEQ[] (upd/n EX1) (upd/n EX2)])
  ;

% Strengthening lemma:
% (1) If P โข (ฮ, x :โฐ A), then P โข ฮ
% (2) if P โข (ฮ, x :โฐ A, y :ยน B), then P โข (ฮ, y :ยน B) [corollary of (1) using exchange lemma]

rec oft_str : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft P (cons ฮ X A[] ๐)] โ [ฮจ โข oft P ฮ] =
  / total d (oft_str d) /
  fn d1 โ case d1 of
  | [_ โข oft/fwd DU (upd/n U1) (upd/n U2) (exh/c E _)] โ [_ โข oft/fwd DU U1 U2 E]
  | [_ โข oft/close (upd/n U1) (exh/c E _)] โ [_ โข oft/close U1 E]
  | [_ โข oft/wait (upd/n U1) O1] โ
    let [_ โข O2] = oft_str [_ โข O1] in
    [_ โข oft/wait U1 O2]
  | [_ โข oft/out (upd/n U1) (mg/c M โข/us) (\x.O1) (\x.O2)] โ
    let [_,x:obj โข O1'] = oft_str (oft_exch_top [_,x:obj โข O1]) in
    let [_,x:obj โข O2'] = oft_str (oft_exch_top [_,x:obj โข O2]) in
    [_ โข oft/out U1 M (\x.O1') (\x.O2')]
  | [_ โข oft/inp (upd/n U1) \x.\y.O1] โ
    let [_,x:obj,y:obj โข O1'] = oft_str (oft_exch_top2 [_,x:obj,y:obj โข O1]) in
    [_ โข oft/inp U1 \x.\y.O1']
  | [_ โข oft/pcomp DU (mg/c M โข/us) (\x.O1) (\x.O2)] โ
    let [_,x:obj โข O1'] = oft_str (oft_exch_top [_,x:obj โข O1]) in
    let [_,x:obj โข O2'] = oft_str (oft_exch_top [_,x:obj โข O2]) in
    [_ โข oft/pcomp DU M (\x.O1') (\x.O2')]
  | [_ โข oft/inl (upd/n U1) \x.O1] โ
    let [_,x:obj โข O2] = oft_str (oft_exch_top [_,x:obj โข O1]) in
    [_ โข oft/inl U1 \x.O2]
  | [_ โข oft/inr (upd/n U1) \x.O1] โ
    let [_,x:obj โข O2] = oft_str (oft_exch_top [_,x:obj โข O1]) in
    [_ โข oft/inr U1 \x.O2]
  | [_ โข oft/choice (upd/n U1) (\x.O1) (\x.O2)] โ
    let [_,x:obj โข O1'] = oft_str (oft_exch_top [_,x:obj โข O1]) in
    let [_,x:obj โข O2'] = oft_str (oft_exch_top [_,x:obj โข O2]) in
    [_ โข oft/choice U1 (\x.O1') (\x.O2')]
  ;

rec oft_str_cor : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ,x:obj,y:obj โข oft P[..,y] (cons (cons ฮ[..] x A[] ๐) y B[] ๐)]
โ [ฮจ,x:obj โข oft P (cons ฮ[..] x B[] ๐)] =
  fn d1 โ
  let [_,x:obj,y:obj โข O1] = oft_str (oft_exch_top d1) in
  let Prune-Oft [_,x:obj โข O2] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1[..,y,x]] in
  [_,x:obj โข O2]
  ;

% Weakening lemma:
% If P โข ฮ, then P โข (ฮ, x :โฐ A) for any x, A

rec oft_weak : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft P ฮ] โ {X:[ฮจ โข obj]} {A:[ โข tp]} [ฮจ โข oft P (cons ฮ X A[] ๐)] =
  / total 1 /
  fn O โ mlam X, A โ
  case O of
  | [_ โข oft/fwd DU[] U1 U2 E] โ [_ โข oft/fwd DU[] (upd/n U1) (upd/n U2) (exh/c E unr/0)]
  | [_ โข oft/close U1 E] โ [_ โข oft/close (upd/n U1) (exh/c E unr/0)]
  | [_ โข oft/wait U1 O1] โ
    let [_ โข O1'] = oft_weak [_ โข O1] [_ โข X] [ โข A] in
    [_ โข oft/wait (upd/n U1) O1']
  | [_ โข oft/out U1 M (\x.O1) (\x.O2)] โ
    let [_,x:obj โข O1'] = oft_exch_top (oft_weak [_,x:obj โข O1] [_,x:obj โข X[..]] [ โข A]) in
    let [_,x:obj โข O2'] = oft_exch_top (oft_weak [_,x:obj โข O2] [_,x:obj โข X[..]] [ โข A]) in
    [_ โข oft/out (upd/n U1) (mg/c M โข/us) (\x.O1') (\x.O2')]
  | [_ โข oft/inp U1 \x.\y.O1] โ
    let [_,x:obj,y:obj โข _]:[_,x:obj,y:obj โข oft _ (cons (cons ฮ'[..] _ C[] _) _ _ _)] = [_,x:obj,y:obj โข O1] in
    let [_,x:obj โข exch/u NEQ[] EX1 EX2] = exch_top [_,x:obj โข ฮ'[..]] [_,x:obj โข x] [ โข C] [ โข ๐] [_,x:obj โข X[..]] [ โข A] [ โข ๐]  in
    let O1'' = oft_exch_top (oft_weak [_,x:obj,y:obj โข O1] [_,x:obj,y:obj โข X[..]] [ โข A]) in
    let [_,x:obj,y:obj โข O1'] = oft_exch O1'' [_,x:obj,y:obj โข exch/u NEQ[] (upd/n EX1[..,x]) (upd/n EX2[..,x])] in
    [_ โข oft/inp (upd/n U1) \x.\y.O1']
  | [_ โข oft/pcomp DU[] M (\x.O1) (\x.O2)] โ
    let [_,x:obj โข O1'] = oft_exch_top (oft_weak [_,x:obj โข O1] [_,x:obj โข X[..]] [ โข A]) in
    let [_,x:obj โข O2'] = oft_exch_top (oft_weak [_,x:obj โข O2] [_,x:obj โข X[..]] [ โข A]) in
    [_ โข oft/pcomp DU[] (mg/c M โข/us) (\x.O1') (\x.O2')]
  | [_ โข oft/inl U1 \x.O1] โ
    let [_,x:obj โข O1'] = oft_exch_top (oft_weak [_,x:obj โข O1] [_,x:obj โข X[..]] [ โข A]) in
    [_ โข oft/inl (upd/n U1) \x.O1']
  | [_ โข oft/inr U1 \x.O1] โ
    let [_,x:obj โข O1'] = oft_exch_top (oft_weak [_,x:obj โข O1] [_,x:obj โข X[..]] [ โข A]) in
    [_ โข oft/inr (upd/n U1) \x.O1']
  | [_ โข oft/choice U1 (\x.O1) (\x.O2)] โ
    let [_,x:obj โข O1'] = oft_exch_top (oft_weak [_,x:obj โข O1] [_,x:obj โข X[..]] [ โข A]) in
    let [_,x:obj โข O2'] = oft_exch_top (oft_weak [_,x:obj โข O2] [_,x:obj โข X[..]] [ โข A]) in
    [_ โข oft/choice (upd/n U1) (\x.O1') (\x.O2')]
  ;

%------------------------------------------------------%
% Main lemmas
%------------------------------------------------------%

% Preservation of typing under structural equivalence

rec oft_cong : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft P ฮ] โ [ฮจ โข P โก Q] โ [ฮจ โข oft Q ฮ] =
  / total 1 /
  fn O, CG โ case CG of
  | [_ โข โกcomm DU[]] โ
    let [_ โข oft/pcomp DU1[] M1 (\x.O1) (\x.O2)] = O in
    let [ โข refl] = dual_uniq [ โข DU] [ โข DU1] in
    let [_ โข M2] = merge_comm [_ โข M1] in
    let [ โข DU2] = dual_sym [ โข DU] in
    [_ โข oft/pcomp DU2[] M2 (\x.O2) (\x.O1)]
  | [_ โข โกassoc] โ
    let [_ โข oft/pcomp DU1[] M1 (\x.oft/pcomp DU2[] (mg/c M2' T1[]) (\y.O1) (\y.O2)) (\x.O3)] = O in
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M2'] in
    case [ โข T1] of
    | [ โข โข/a1] โ
      let [_,x:obj,y:obj โข _]:[_,x:obj,y:obj โข oft _ (cons (cons ฮโ[..] _ A[] _) _ _ _)] = [_,x:obj,y:obj โข O1] in
      let [_,x:obj โข U] = refl_top [_,x:obj โข ฮโ[..]] [_,x:obj โข x] [ โข A] [ โข ๐] in
      let [_,x:obj,y:obj โข NIN] = oft_lin_in [_,x:obj,y:obj โข O1] [_,x:obj,y:obj โข upd/n U[..,x]] in
      impossible in_proc_lemma [_,x:obj,y:obj โข NIN[..,y,x]]
    | [ โข โข/a2] โ
      let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M1] [_ โข M2] in
      let [_,x:obj โข O1'] = oft_str_cor [_,x:obj,y:obj โข O1] in
      let [_,x:obj,y:obj โข O2'[..,y,x]] = oft_exch_top [_,x:obj,y:obj โข O2] in
      let [ โข _]:[ โข dual _ B'] = [ โข DU2] in
      let [_,x:obj,y:obj โข O3'] = oft_exch_top (oft_weak [_,x:obj,y:obj โข O3[..,y]] [_,x:obj,y:obj โข x] [ โข B']) in
      [_ โข oft/pcomp DU2[] M4 (\x.O1') (\x.oft/pcomp DU1[] (mg/c M3[..] โข/a1) (\y.O2') (\y.O3'))]
  ;

% Renaming lemma:
% If P โข (ฮ, x :ยน A), then P[y/x] โข ฮ[y :โฐ A โฆโ y :ยน A]

rec oft_rename : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ,x:obj โข oft P (cons ฮ[..] x A[] ๐)] โ [ฮจ โข upd ฮ n[] X X A[] A[] ๐ ๐ ฮ'] โ [ฮจ โข oft P[..,X] ฮ'] =
  fn O, U โ
  let ([_ โข U_ub],[_ โข U_sym]) = (U,upd_symm U) in
  case O of
  | [_,x:obj โข oft/fwd DU[] U1 U2 E1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข upd/n U2''] = [_,x:obj โข U2] in
      let Prune-Upd [_ โข U2'] [_,x:obj โข _] = prune_upd [_,x:obj โข U2''] in
      let [_,x:obj โข exh/c E2' _] = [_,x:obj โข E1] in
      let [_ โข E2] = prune_exh [_,x:obj โข E2'] in
      [_ โข oft/fwd DU[] U_sym U2' E2]
    | [_,x:obj โข upd/n U1''] โ
      (case [_,x:obj โข U2] of
      | [_,x:obj โข upd/t _] โ
        let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
        let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U_sym] [_ โข U1'] (lookup_lab_neq_2 U [_ โข U1']) in 
        let [_,x:obj โข exh/c E2' _] = [_,x:obj โข E1] in
        let [_ โข E2] = prune_exh [_,x:obj โข E2'] in
        [_ โข oft/fwd DU[] U3 U4 E2]
      | [_,x:obj โข upd/n _] โ
        let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E1] in
        impossible [ โข T]
      )
    )
  | [_,x:obj โข oft/close U1 E] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ 
      let [_,x:obj โข exh/c E1 _] = [_ โข E] in
      let [_ โข E2] = prune_exh [_,x:obj โข E1] in
      [_ โข oft/close U_sym E2]
    | [_,x:obj โข upd/n _] โ
      let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E] in
      impossible [ โข T]
    )
  | [_,x:obj โข oft/wait U1 O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข O1''] = oft_str [_,x:obj โข O1] in
      let Prune-Oft [_ โข O1'] [_,x:obj โข _] = prune_oft [_,x:obj โข O1''] in
      [_ โข oft/wait U_sym O1']
    | [_,x:obj โข upd/n U1''] โ
      let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U_sym] [_ โข U1'] (lookup_lab_neq_2 U [_ โข U1']) in 
      let [_ โข O1'] = oft_rename [_,x:obj โข O1] (upd_symm [_ โข U4]) in
      [_ โข oft/wait U3 O1']
    )
  | [_,x:obj โข oft/out U1 (mg/c M T[]) (\y.O1) (\y.O2)] โ
    let Prune-Merge [_ โข M1] [_,x:obj โข _] = prune_merge [_,x:obj โข M] in
    let [_ โข merge-upd U2 U3 โข/us M2 _ _ _] = merge_upd_cor [_ โข U_ub] [_ โข M1] [ โข T] in
    (case [ โข T] of
    | [ โข โข/a1] โ
      let [_ โข cx/refl] = upd_func [_ โข U3] (upd_refl [_ โข U3]) in
      let [_,x:obj โข upd/n U1''] = [_,x:obj โข U1] in
      let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_,x:obj,y:obj โข O1''] = oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]] in
      let [_,x:obj โข O1'] = oft_rename [_,x:obj,y:obj โข O1''] [_,x:obj โข upd/n U2[..]] in
      let [_,x:obj,y:obj โข O2''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2''] in
      [_ โข oft/out U1' M2 (\y.O1') (\y.O2')]
    | [ โข โข/a2] โ
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj,y:obj โข O1''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1''] in
      let [_ โข U3_sym] = upd_symm [_ โข U3] in
      (case [_,x:obj โข U1] of
      | [_,x:obj โข upd/t _] โ
        let [_,x:obj,y:obj โข O2''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
        let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2''] in
        [_ โข oft/out U3_sym M2 (\x.O1') (\x.O2')]
      | [_,x:obj โข upd/n U1''] โ
        let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
        let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U3_sym] [_ โข U1'] (lookup_lab_neq_2 [_ โข U3] [_ โข U1']) in 
        let [_,x:obj,y:obj โข O2''] = oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]] in
        let [_,x:obj โข O2'] = oft_rename [_,x:obj,y:obj โข O2''] (upd_symm [_,x:obj โข upd/n U4[..]]) in
        [_ โข oft/out U3 M2 (\x.O1') (\x.O2')]
      )
    )
  | [_,x:obj โข oft/inp U1 \y.\z.O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj,z:obj โข O1'] = oft_str (oft_exch_top2 [_,y:obj,z:obj,x:obj โข O1[..,x,y,z]]) in
      let Prune-Oft [_,x:obj,y:obj โข O1''] [_,x:obj,y:obj,z:obj โข _] = prune_oft [_,x:obj,y:obj,z:obj โข O1'] in
      [_ โข oft/inp U_sym \x.\y.O1'']
    | [_,x:obj โข upd/n U1''] โ
      let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U_sym] [_ โข U1'] (lookup_lab_neq_2 U [_ โข U1']) in 
      let [_,x:obj,y:obj โข O1'] = oft_rename (oft_exch_top2 [_,y:obj,z:obj,x:obj โข O1[..,x,y,z]]) (upd_symm [_,x:obj,y:obj โข upd/n (upd/n U4[..])]) in
      [_ โข oft/inp U3 \x.\y.O1']
    )
  | [_,x:obj โข oft/pcomp DU[] (mg/c M T[]) (\y.O1) (\y.O2)] โ
    let Prune-Merge [_ โข M1] [_,x:obj โข _] = prune_merge [_,x:obj โข M] in
    let [_ โข merge-upd U1 U2 โข/us M2 _ _ _] = merge_upd_cor [_ โข U_ub] [_ โข M1] [ โข T] in
    (case [ โข T] of
    | [ โข โข/a1] โ
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj,y:obj โข O1''] = oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]] in
      let [_,x:obj โข O1'] = oft_rename [_,x:obj,y:obj โข O1''] [_,x:obj โข upd/n U1[..]] in
      let [_,x:obj,y:obj โข O2''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2''] in
      [_ โข oft/pcomp DU[] M2 (\x.O1') (\x.O2')]
    | [ โข โข/a2] โ
      let [_ โข cx/refl] = upd_func [_ โข U1] (upd_refl [_ โข U1]) in
      let [_,x:obj,y:obj โข O1''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1''] in
      let [_,x:obj,y:obj โข O2''] = oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]] in
      let [_,x:obj โข O2'] = oft_rename [_,x:obj,y:obj โข O2''] [_,x:obj โข upd/n U2[..]] in
      [_ โข oft/pcomp DU[] M2 (\x.O1') (\x.O2')]
    )
  | [_,x:obj โข oft/inl U1 \y.O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj โข O1''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1''] in
      [_ โข oft/inl U_sym \x.O1']
    | [_,x:obj โข upd/n U1''] โ
      let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U_sym] [_ โข U1'] (lookup_lab_neq_2 U [_ โข U1']) in 
      let [_,x:obj,y:obj โข O1'] = oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]] in
      let [_,x:obj โข O1''] = oft_rename [_,x:obj,y:obj โข O1'] (upd_symm [_,x:obj โข upd/n U4[..]]) in
      [_ โข oft/inl U3 \x.O1'']
    )
  | [_,x:obj โข oft/inr U1 \y.O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj โข O1''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1''] in
      [_ โข oft/inr U_sym \x.O1']
    | [_,x:obj โข upd/n U1''] โ
      let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U_sym] [_ โข U1'] (lookup_lab_neq_2 U [_ โข U1']) in 
      let [_,x:obj,y:obj โข O1'] = oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]] in
      let [_,x:obj โข O1''] = oft_rename [_,x:obj,y:obj โข O1'] (upd_symm [_,x:obj โข upd/n U4[..]]) in
      [_ โข oft/inr U3 \x.O1'']
    )
  | [_,x:obj โข oft/choice U1 (\y.O1) (\y.O2)] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj โข O1''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let [_,x:obj,y:obj โข O2''] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O1'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1''] in
      let Prune-Oft [_,x:obj โข O2'] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2''] in
      [_ โข oft/choice U_sym (\x.O1') (\x.O2')]
    | [_,x:obj โข upd/n U1''] โ
      let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1''] in
      let [_ โข upd-ch U3 U4 _ _] = upd_changeorder [_ โข U_sym] [_ โข U1'] (lookup_lab_neq_2 U [_ โข U1']) in 
      let [_,x:obj,y:obj โข O1''] = oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]] in
      let [_,x:obj,y:obj โข O2''] = oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]] in
      let [_,x:obj โข O1'] = oft_rename [_,x:obj,y:obj โข O1''] (upd_symm [_,x:obj โข upd/n U4[..]]) in
      let [_,x:obj โข O2'] = oft_rename [_,x:obj,y:obj โข O2''] (upd_symm [_,x:obj โข upd/n U4[..]]) in
      [_ โข oft/choice U3 (\x.O1') (\x.O2')]
    )
  ;