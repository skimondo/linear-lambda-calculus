%======================================================%
% Lemmas about translation from CP to SCP
%======================================================%

%------------------------------------------------------%
% Properties of Enc judgment
%------------------------------------------------------%

% Obtain Enc judgment from RelUsed and RelName judgments

rec relus_to_encctx : RelUsed [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn ru โ case ru of
  | relUsed/n โ Enc/n
  | relUsed/c ru1 โ Enc/c (relus_to_encctx ru1) [ โข _] [ โข _]
  ;

rec relnm_to_encctx : RelName [ฮจ โข _] [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn rn โ case rn of
  | relName/t ru โ Enc/c (relus_to_encctx ru) [ โข _] [ โข _]
  | relName/n rn โ Enc/c (relnm_to_encctx rn) [ โข _] [ โข _]
  ;

% Enc [ฮจ โข ฮโ โ ฮโ] [ฮฆ โข ฯ] iff Enc [ฮจ โข ฮโ] [ฮฆ โข ฯ]

rec encctx_merge : Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ [ฮจ โข merge ฮโ ฮโ ฮ] โ Enc [ฮจ โข ฮโ] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn ec, m โ case m of
  | [_ โข mg/n] โ ec
  | [_ โข mg/c M1 _] โ
    let Enc/c ec1 [ โข _] [ โข _] = ec in
    let Prune-Merge [_ โข M1'] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    Enc/c (encctx_merge ec1 [_ โข M1']) [ โข _] [ โข _]
  ;

rec encctx_merge_l : Enc [ฮจ โข ฮโ] $[ฮฆ โข $ฯ] โ [ฮจ โข merge ฮโ ฮโ ฮ] โ Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn ec, m โ case m of
  | [_ โข mg/n] โ ec
  | [_ โข mg/c M1 _] โ
    let Enc/c ec1 [ โข _] [ โข _] = ec in
    let Prune-Merge [_ โข M1'] [_,x:obj โข _] = prune_merge_l [_,x:obj โข M1] in
    Enc/c (encctx_merge_l ec1 [_ โข M1']) [ โข _] [ โข _]
  ;

% Updating multiplicities in the explicit context preserves the Enc relation

rec encctx_upd : Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ [ฮจ โข upd ฮ _ X X A[] A[] _ _ ฮ'] โ Enc [ฮจ โข ฮ'] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn e, u โ case u of
  | [_ โข upd/t _] โ
    let Enc/c ec1 [ โข _] [ โข _] = e in
    Enc/c ec1 [ โข _] [ โข _]
  | [_ โข upd/n U1] โ
    let Enc/c ec1 [ โข _] [ โข _] = e in
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    Enc/c (encctx_upd ec1 [_ โข U1']) [ โข _] [ โข _]
  ;

% Obtain SCP hyp judgment from CP lookup judgment:
% If Enc [ฮจ โข ฮ] [ฮฆ โข ฯ] and (X : A) โ ฮ, then (X[ฯ] : A) โ ฮฆ

rec lookup_to_hyp : Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ [ฮจ โข upd ฮ _ X X' A[] A' ฮฑ ฮฑ' ฮ'] โ [ฮฆ โข hyp X[$ฯ] A[]] =
  / total 1 /
  fn e, u โ case u of
  | [_ โข upd/t _] โ let Enc/c ec1 [ โข _] [ โข _] = e in [_,b:block x:obj,h:hyp _ _ โข b.2]
  | [_ โข upd/n U1] โ
    let Enc/c ec1 [ โข _] [ โข _] = e in
    let [_,x:obj โข U1'] = upd_refl [_,x:obj โข U1] in
    let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
    let [_ โข hx] = lookup_to_hyp ec1 [_ โข U1''] in
    [_,b:block x:obj,h:hyp _ _ โข hx[..]]
  ;

% If Enc [ฮจ โข ฮ] [ฮฆ โข ฯ] and exh(ฮ), then RelUsed [ฮจ โข ฮ] [ฮฆ โข ฯ]

rec exh_to_relus : Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ [ฮจ โข exh ฮ] โ RelUsed [ฮจ โข ฮ] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn ec, e โ case e of
  | [_ โข exh/n] โ let Enc/n = ec in relUsed/n
  | [_ โข exh/c E1 unr/0] โ
    let Enc/c ec1 [ โข _] [ โข _] = ec in
    relUsed/c (exh_to_relus ec1 (prune_exh [_,x:obj โข E1]))
  ;

% If Enc [ฮจ โข ฮ] [ฮฆ โข ฯ] and X:A is the unique linear element of ฮ, then RelName [ฮจ โข X] [ฮจ โข ฮ] [ฮฆ โข ฯ]

rec unqlin_to_relnm : Enc [ฮจ โข ฮ] $[ฮฆ โข $ฯ] โ [ฮจ โข upd ฮ _ X X A[] A[] ๐ ๐ ฮ'] โ [ฮจ โข exh ฮ'] โ RelName [ฮจ โข X] [ฮจ โข ฮ] $[ฮฆ โข $ฯ] =
  / total 1 /
  fn ec, u, e โ case u of
  | [_ โข upd/t _] โ
    let Enc/c ec1 [ โข _] [ โข _] = ec in
    let [_,x:obj โข exh/c E1 unr/0] = e in
    relName/t (exh_to_relus ec1 (prune_exh [_,x:obj โข E1]))
  | [_ โข upd/n U1] โ
    let Enc/c ec1 [ โข _] [ โข _] = ec in
    let [_,x:obj โข exh/c E1 unr/0] = e in
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    relName/n (unqlin_to_relnm ec1 [_ โข U1'] (prune_exh [_,x:obj โข E1]))
  ;

%------------------------------------------------------%
% Extract linearity judgment from CP typing judgment
%------------------------------------------------------%

% If P โข (x, X :ยน A), then P is linear with respect to x

rec oft_linear : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ,x:obj โข oft P (cons ฮ[..] x A[] ๐)] โ [ฮจ โข linear \x.P] =
  / total d (oft_linear d) /
  fn d1 โ case d1 of
  | [_,x:obj โข oft/fwd _ U1 U2 E] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข upd/n U2'] = [_,x:obj โข U2] in
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U2'] in
      [_ โข l_fwd2]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      (case [_,x:obj โข U2] of
      | [_,x:obj โข upd/t _] โ [_ โข l_fwd1]
      | [_,x:obj โข upd/n _] โ
        let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E] in
        impossible [ โข T]
      )
    )
  | [_,x:obj โข oft/close U1 E] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ [_ โข l_close]
    | [_,x:obj โข upd/n _] โ
      let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E] in
      impossible [ โข T]
    )
  | [_,x:obj โข oft/wait U1 O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข O2'] = oft_str [_,x:obj โข O1] in
      let Prune-Oft [_ โข O2] [_,x:obj โข _] = prune_oft [_,x:obj โข O2'] in
      [_ โข l_wait]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข LN] = oft_linear [_,x:obj โข O1] in
      [_ โข l_wait2 LN]
    )
  | [_,x:obj โข oft/out U1 (mg/c M1 MLT[]) (\y.O1) (\y.O2)] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [ โข โข/a2] = [ โข MLT] in
      let [_,x:obj,y:obj โข O1'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let [_,x:obj,y:obj โข O2'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      let Prune-Oft [_,x:obj โข _] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1'] in
      let Prune-Oft [_,x:obj โข O2''] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2'] in
      let [_ โข LN2] = oft_linear [_,x:obj โข O2''] in
      [_ โข l_out LN2]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      (case [ โข MLT] of
      | [ โข โข/a1] โ
        let [_,x:obj โข LN] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
        let [_,x:obj,y:obj โข O2'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
        let Prune-Oft [_,x:obj โข _] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2'] in
        [_ โข l_out2 \x.LN]
      | [ โข โข/a2] โ
        let [_,x:obj,y:obj โข O1'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
        let Prune-Oft [_,x:obj โข _] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1'] in
        let [_,x:obj โข LN] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
        [_ โข l_out3 \x.LN]
      )
    )
  | [_,x:obj โข oft/inp U1 \y.\z.O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj,z:obj โข O2'] = oft_str (oft_exch_top2 [_,y:obj,z:obj,x:obj โข O1[..,x,y,z]]) in
      let Prune-Oft [_,x:obj,y:obj โข O2] [_,x:obj,y:obj,z:obj โข _] = prune_oft [_,x:obj,y:obj,z:obj โข O2'] in
      let [_,x:obj โข LN] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      [_ โข l_inp \x.LN]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_,x:obj,y:obj โข LN] = oft_linear (oft_exch_top2 [_,y:obj,z:obj,x:obj โข O1[..,x,y,z]]) in
      [_ โข l_inp2 \x.\y.LN]
    )
  | [_,x:obj โข oft/pcomp DU[] (mg/c M1 MLT[]) (\y.O1) (\y.O2)] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    (case [ โข MLT] of
    | [ โข โข/a1] โ
      let [_,x:obj โข LN1] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let [_,x:obj,y:obj โข O2'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      let Prune-Oft [_,x:obj โข _] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2'] in
      [_ โข l_pcomp1 \x.LN1]
    | [ โข โข/a2] โ
      let [_,x:obj,y:obj โข O1'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข _] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1'] in
      let [_,x:obj โข LN1] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      [_ โข l_pcomp2 \x.LN1]
    )
  | [_,x:obj โข oft/inl U1 \y.O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj โข O2'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O2] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2'] in
      let [_ โข LN] = oft_linear [_,x:obj โข O2] in
      [_ โข l_inl LN]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_,x:obj โข LN] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      [_ โข l_inl2 \x.LN]
    )
  | [_,x:obj โข oft/inr U1 \y.O1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj โข O2'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O2] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2'] in
      let [_ โข LN] = oft_linear [_,x:obj โข O2] in
      [_ โข l_inr LN]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_,x:obj โข LN] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      [_ โข l_inr2 \x.LN]
    )
  | [_,x:obj โข oft/choice U1 (\y.O1) (\y.O2)] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj,y:obj โข O1'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let [_,x:obj,y:obj โข O2'] = oft_str (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      let Prune-Oft [_,x:obj โข O1''] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O1'] in
      let Prune-Oft [_,x:obj โข O2''] [_,x:obj,y:obj โข _] = prune_oft [_,x:obj,y:obj โข O2'] in
      let [_ โข LN1] = oft_linear [_,x:obj โข O1''] in
      let [_ โข LN2] = oft_linear [_,x:obj โข O2''] in
      [_ โข l_choice LN1 LN2]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข _] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_,x:obj โข LN1] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O1[..,y,x]]) in
      let [_,x:obj โข LN2] = oft_linear (oft_exch_top [_,x:obj,y:obj โข O2[..,y,x]]) in
      [_ โข l_choice2 (\x.LN1) (\x.LN2)]
    )
  ;