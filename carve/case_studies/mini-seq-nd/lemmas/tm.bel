%------------------------------------------------------%
% Properties of variables
%------------------------------------------------------%

% For any terms M,N, either M = N or M ≠ N

inductive CompareTerms : (Ψ:ctx) {M:[Ψ ⊢ var]} {N:[Ψ ⊢ var]} ctype =
  | Ct-Eq : CompareTerms [Ψ ⊢ M] [Ψ ⊢ M]
  | Ct-Neq : ([Ψ ⊢ var_eq M N] → [ ⊢ false]) → CompareTerms [Ψ ⊢ M] [Ψ ⊢ N];

rec neq_weakᵗ : (Ψ:ctx) ([Ψ ⊢ var_eq M N] → [ ⊢ false]) → ([Ψ,x:var ⊢ var_eq M[..] N[..]] → [ ⊢ false]) =
  / total /
  fn NEQ, EQ ⇒
  let [_,x:var ⊢ var/refl] = EQ in
  impossible NEQ [_ ⊢ var/refl]
  ;

rec neq_commᵗ : (Ψ:ctx) ([Ψ ⊢ var_eq M N] → [ ⊢ false]) → ([Ψ ⊢ var_eq N M] → [ ⊢ false]) =
  / total /
  fn NEQ, EQ ⇒
  let [_ ⊢ var/refl] = EQ in
  impossible NEQ [_ ⊢ var/refl]
  ;

LF comp_subtm-0 : (var → var) → (var → var) → type = 
  | subtm/app1 : comp_subtm-0 (\x.app x _) (\x.app x _)
  | subtm/app2 : comp_subtm-0 (\x.app _ x) (\x.app _ x)
  | subtm/coerce : comp_subtm-0 (\x.coerce x _) (\x.coerce x _)
  ;

LF comp_subtm-1 : ((var → var) → var) → ((var → var) → var) → type = 
  | subtm/lam : comp_subtm-1 (\x.lam x) (\x.lam x)
  ;

rec subtm_neq-0 : (Ψ:ctx) ([Ψ ⊢ var_eq N N'] → [ ⊢ false]) → [Ψ ⊢ comp_subtm-0 (\x.M) (\x.M')]
→ ([Ψ ⊢ var_eq M[..,N] M'[..,N']] → [ ⊢ false]) =
  / total /
  fn NEQ, SUB, EQ ⇒ case SUB of
  | [_ ⊢ subtm/app1] ⇒ let [_ ⊢ var/refl] = EQ in NEQ [_ ⊢ var/refl]
  | [_ ⊢ subtm/app2] ⇒ let [_ ⊢ var/refl] = EQ in NEQ [_ ⊢ var/refl]
  | [_ ⊢ subtm/coerce] ⇒ let [_ ⊢ var/refl] = EQ in NEQ [_ ⊢ var/refl]
  ;

rec subtm_neq-1 : (Ψ:ctx) ([Ψ,x:var ⊢ var_eq N N'] → [ ⊢ false]) → [Ψ ⊢ comp_subtm-1 (\x.M) (\x.M')]
→ ([Ψ ⊢ var_eq M[..,\x.N] M'[..,\x.N']] → [ ⊢ false]) =
  / total /
  fn NEQ, SUB, EQ ⇒ case SUB of
  | [_ ⊢ subtm/lam] ⇒ let [_ ⊢ var/refl] = EQ in NEQ [_ ⊢ var/refl]
  ;

rec coerce_tp_neq : (Ψ:ctx) ([ ⊢ eq A B] → [ ⊢ false]) → ([Ψ ⊢ var_eq (coerce M A[]) (coerce M B[])] → [ ⊢ false]) =
  fn NEQ, EQ ⇒
  let [_ ⊢ var/refl] = EQ in
  NEQ [ ⊢ refl]
  ;

rec comp_vars : (Ψ:ctx) {M:[Ψ ⊢ var]} {N:[Ψ ⊢ var]} CompareTerms [Ψ ⊢ M] [Ψ ⊢ N] =
  mlam M, N ⇒
  case [_ ⊢ M] of
  | [_ ⊢ #p] ⇒
    (case [_ ⊢ N] of
    | [Ψ ⊢ #q] ⇒
    (case [Ψ] of
    | [ ] ⇒ impossible [ ⊢ M]
    | [_,x:var] ⇒
      (case [_,x:var ⊢ M] of
      | [_,x:var ⊢ x] ⇒
        (case [_,x:var ⊢ N] of
        | [_,x:var ⊢ x] ⇒ Ct-Eq
        | [_,x:var ⊢ #q[..]] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
        )
      | [_,x:var ⊢ #p[..]] ⇒
        (case [_,x:var ⊢ N] of
        | [_,x:var ⊢ x] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
        | [_,x:var ⊢ #q[..]] ⇒ (case comp_vars [_ ⊢ #p] [_ ⊢ #q] of
          | Ct-Eq ⇒ Ct-Eq
          | Ct-Neq NEQ ⇒ Ct-Neq (neq_weakᵗ NEQ))
        )
      )
    )
    | [_ ⊢ lam \x.N'] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ app N₁ N₂] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ coerce N' B] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    )
  | [_ ⊢ lam \x.M'] ⇒
    (case [_ ⊢ N] of
    | [_ ⊢ #q] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ lam \x.N'] ⇒
      (case comp_vars [_,x:var ⊢ M'] [_,x:var ⊢ N'] of
      | Ct-Eq ⇒ Ct-Eq
      | Ct-Neq NEQ ⇒ Ct-Neq (subtm_neq-1 NEQ [_ ⊢ subtm/lam])
      )
    | [_ ⊢ app N₁ N₂] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ coerce N' B] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    )
  | [_ ⊢ app M₁ M₂] ⇒
    (case [_ ⊢ N] of
    | [_ ⊢ #q] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ lam \x.N'] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ app N₁ N₂] ⇒
      (case comp_vars [_ ⊢ M₁] [_ ⊢ N₁] of
      | Ct-Eq ⇒
        (case comp_vars [_ ⊢ M₂] [_ ⊢ N₂] of
        | Ct-Eq ⇒ Ct-Eq
        | Ct-Neq NEQ ⇒ Ct-Neq (subtm_neq-0 NEQ [_ ⊢ subtm/app2])
        )
      | Ct-Neq NEQ ⇒ Ct-Neq (subtm_neq-0 NEQ [_ ⊢ subtm/app1])
      )
    | [_ ⊢ coerce N' B] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    )
  | [_ ⊢ coerce M' A[]] ⇒
    (case [_ ⊢ N] of
    | [_ ⊢ #q] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ lam \x.N'] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ app N₁ N₂] ⇒ Ct-Neq (fn EQ ⇒ impossible EQ)
    | [_ ⊢ coerce N' B[]] ⇒
      (case comp_vars [_ ⊢ M'] [_ ⊢ N'] of
      | Ct-Eq ⇒
        (case comp_tps [ ⊢ A] [ ⊢ B] of
        | Tp-Eq ⇒ Ct-Eq
        | Tp-Neq NEQ ⇒ Ct-Neq (coerce_tp_neq NEQ)
        )
      | Ct-Neq NEQ ⇒ Ct-Neq (subtm_neq-0 NEQ [_ ⊢ subtm/coerce])
      )
    )
  ;

% 'Prune' LF context to remove dependencies

inductive PruneTerm : (Ψ:ctx) {M:[Ψ,x:var ⊢ var]} ctype =
  | Prune-Term : [Ψ,x:var ⊢ var_eq M M'[..]] → PruneTerm [Ψ,x:var ⊢ M];

rec prune_var : {M:[Ψ,x:var ⊢ var]} ([Ψ,x:var ⊢ var_eq M x] → [ ⊢ false]) → PruneTerm [Ψ,x:var ⊢ M] =
  / total /
  mlam M ⇒ fn NEQ ⇒ case [_,x:var ⊢ M] of
  | [_,x:var ⊢ x] ⇒ impossible NEQ [_,x:var ⊢ var/refl]
  | [_,x:var ⊢ M'[..]] ⇒ Prune-Term [_,x:var ⊢ var/refl]
  ;