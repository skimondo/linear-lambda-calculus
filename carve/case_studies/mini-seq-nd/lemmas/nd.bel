%------------------------------------------------------%
% Strengthening / weakening properties
%------------------------------------------------------%

inductive PruneChk : (Ψ:ctx) {CH:[Ψ,x:var ⊢ chk Δ[..] M C[]]} ctype =
  Prune-Chk : [Ψ ⊢ chk Δ M C[]]
  → {CH:[Ψ,x:var ⊢ chk Δ[..] M[..] C[]]} PruneChk [Ψ,x:var ⊢ CH];

inductive PruneSyn : (Ψ:ctx) {SYN:[Ψ,x:var ⊢ syn Δ[..] M C[]]} ctype =
  Prune-Syn : [Ψ ⊢ syn Δ M C[]]
  → {SYN:[Ψ,x:var ⊢ syn Δ[..] M[..] C[]]} PruneSyn [Ψ,x:var ⊢ SYN];

rec prune_chk : {CH:[Ψ,x:var ⊢ chk Δ[..] M C[]]} PruneChk [Ψ,x:var ⊢ CH] =
  mlam CH ⇒ case [_,x:var ⊢ CH] of
  | [_,x:var ⊢ conv SYN1] ⇒
    let Prune-Syn [_ ⊢ SYN2] [_,x:var ⊢ _] = prune_syn [_,x:var ⊢ SYN1] in
    Prune-Chk [_ ⊢ conv SYN2] [_,x:var ⊢ _]
  | [_,x:var ⊢ I-o \y.CH1] ⇒
    let Prune-Chk [_,y:var ⊢ CH2] [_,y:var,x:var ⊢ _] = prune_chk [_,y:var,x:var ⊢ CH1[..,x,y]] in
    Prune-Chk [_ ⊢ I-o \y.CH2] [_,x:var ⊢ _]

and rec prune_syn : {SYN:[Ψ,x:var ⊢ syn Δ[..] M C[]]} PruneSyn [Ψ,x:var ⊢ SYN] =
  mlam SYN ⇒
  case [_,x:var ⊢ SYN] of
  | [_,x:var ⊢ coe CH1] ⇒
    let Prune-Chk [_ ⊢ CH2] [_,x:var ⊢ _] = prune_chk [_,x:var ⊢ CH1] in
    Prune-Syn [_ ⊢ coe CH2] [_,x:var ⊢ _]
  | [_,x:var ⊢ init Rmv1 EXH1] ⇒
    let Prune-Rmv [_,x:var ⊢ cx/refl] [_ ⊢ var/refl] [_ ⊢ Rmv2] [_ ⊢ _] = prune_rmv [_,x:var ⊢ Rmv1] in
    let [_ ⊢ EXH2] = prune_exh [_,x:var ⊢ EXH1] in
    Prune-Syn [_ ⊢ init Rmv2 EXH2] [_,x:var ⊢ _]
  | [_,x:var ⊢ E-o SYN1 CH1 MG1] ⇒
    let Prune-Merge [_,x:var ⊢ cx/refl] [_ ⊢ cx/refl] [_ ⊢ MG2] [_ ⊢ _] = prune_merge [_,x:var ⊢ MG1] in
    let Prune-Syn [_ ⊢ SYN2] [_,x:var ⊢ _] = prune_syn [_,x:var ⊢ SYN1] in
    let Prune-Chk [_ ⊢ CH2] [_,x:var ⊢ _] = prune_chk [_,x:var ⊢ CH1] in
    Prune-Syn [_ ⊢ E-o SYN2 CH2 MG2] [_,x:var ⊢ _]
  ;

rec chk_str : [Ψ ⊢ chk Δ M C] → [Ψ ⊢ rmv Δ X A[] used n[] Δ'] → Wf [Ψ ⊢ Δ] → [Ψ ⊢ chk Δ' M C] =
  / total 1 /
  fn ch1, rm, wf ⇒
  let [_ ⊢ RMV] = rm in
  case ch1 of
  | [_ ⊢ conv SYN1] ⇒ let [_ ⊢ SYN2] = syn_str [_ ⊢ SYN1] rm wf in [_ ⊢ conv SYN2]
  | [_ ⊢ I-o \x.CH1] ⇒ let [_,x:var ⊢ CH2] = chk_str [_,x:var ⊢ CH1] [_,x:var ⊢ rmv/n RMV[..]] (wf_extcons wf) in [_ ⊢ I-o \x.CH2]

and rec syn_str : [Ψ ⊢ syn Δ M C] → [Ψ ⊢ rmv Δ X A[] used n[] Δ'] → Wf [Ψ ⊢ Δ] → [Ψ ⊢ syn Δ' M C] =
  / total 1 /
  fn s1, rm, wf ⇒
  let [_ ⊢ RMV] = rm in
  case s1 of
  | [_ ⊢ coe CH1] ⇒ let [_ ⊢ CH2] = chk_str [_ ⊢ CH1] rm wf in [_ ⊢ coe CH2]
  | [_ ⊢ init RMV1 EXH1] ⇒
    let [_ ⊢ rmv-po RMV2 RMV3 _ _ _ _] = rmv_pushout [_ ⊢ RMV1] [_ ⊢ RMV] (lookup_lab_neq [_ ⊢ RMV1] rm wf) in
    let [_ ⊢ EXH2] = exh_str [_ ⊢ EXH1] [_ ⊢ RMV2] in
    [_ ⊢ init RMV3 EXH2]
  | [_ ⊢ E-o SYN1 CH1 MG1] ⇒
    let [_ ⊢ mg-str RMV1 RMV2 •/us MG2 _ _] = merge_str [_ ⊢ RMV] [_ ⊢ MG1] in
    let [_ ⊢ SYN2] = syn_str [_ ⊢ SYN1] [_ ⊢ RMV1] (wf_merge wf [_ ⊢ MG1]) in
    let [_ ⊢ CH2] = chk_str [_ ⊢ CH1] [_ ⊢ RMV2] (wf_merge_r wf [_ ⊢ MG1]) in
    [_ ⊢ E-o SYN2 CH2 MG2]
  ;

rec chk_weak : [Ψ ⊢ chk Δ M C] → [Ψ ⊢ rmv Δ' X A[] used n[] Δ] → Wf [Ψ ⊢ Δ'] → [Ψ ⊢ chk Δ' M C] =
  / total 1 /
  fn ch1, rm, wf ⇒
  let [_ ⊢ RMV] = rm in
  case ch1 of
  | [_ ⊢ conv SYN1] ⇒ let [_ ⊢ SYN2] = syn_weak [_ ⊢ SYN1] rm wf in [_ ⊢ conv SYN2]
  | [_ ⊢ I-o \x.CH1] ⇒
    let [_,x:var ⊢ CH2] = chk_weak [_,x:var ⊢ CH1] [_,x:var ⊢ rmv/n RMV[..]] (wf_extcons wf) in
    [_ ⊢ I-o \x.CH2]

and rec syn_weak : [Ψ ⊢ syn Δ M C] → [Ψ ⊢ rmv Δ' X A[] used n[] Δ] → Wf [Ψ ⊢ Δ'] → [Ψ ⊢ syn Δ' M C] =
  / total 1 /
  fn sy, rm, wf ⇒
  let [_ ⊢ RMV] = rm in
  case sy of
  | [_ ⊢ coe CH1] ⇒ let [_ ⊢ CH2] = chk_weak [_ ⊢ CH1] rm wf in [_ ⊢ coe CH2]
  | [_ ⊢ init RMV1 EXH1] ⇒
    let [_ ⊢ rmv-ch RMV2 RMV3 _ _ _ _] = rmv_changeorder [_ ⊢ RMV] [_ ⊢ RMV1] in
    let [_ ⊢ EXH2] = exh_weak [_ ⊢ EXH1] [_ ⊢ RMV3] in
    [_ ⊢ init RMV2 EXH2]
  | [_ ⊢ E-o SYN1 CH1 MG1] ⇒
    let [_ ⊢ mg-weak RMV1 RMV2 MG2 _ _ _] = merge_weak [_ ⊢ RMV] [_ ⊢ MG1] [ ⊢ •/us] in
    let [_ ⊢ SYN2] = syn_weak [_ ⊢ SYN1] [_ ⊢ RMV1] (wf_merge wf [_ ⊢ MG2]) in
    let [_ ⊢ CH2] = chk_weak [_ ⊢ CH1] [_ ⊢ RMV2] (wf_merge_r wf [_ ⊢ MG2]) in
    [_ ⊢ E-o SYN2 CH2 MG2]
  ;