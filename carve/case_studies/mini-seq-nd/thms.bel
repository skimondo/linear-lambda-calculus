%------------------------------------------------------%
% Cut admissability
%------------------------------------------------------%

rec cut_admis : [Ψ ⊢ seq Δ₁ A[]] → [Ψ,x:var ⊢ seq Δ₂' C[]]
→ [Ψ,x:var ⊢ rmv Δ₂' x A[] lin n[] Δ₂[..]] → [Ψ ⊢ merge Δ₁ Δ₂ Δ]
→ Wf [Ψ ⊢ Δ]
→ [Ψ ⊢ seq Δ C[]] =
  fn s1, s2, rm, mg, wf ⇒
  let [_ ⊢ MG]:[_ ⊢ merge Δ₁ Δ₂ _] = mg in
  let [_ ⊢ get-len LN2] = get_len [_ ⊢ Δ₂] in
  let ([_ ⊢ MG_comm],[_,x:var ⊢ RMV]) = (merge_comm mg,rm) in
  let WF1 = wf_weak (wf_ext (wf_merge_r wf mg)) rm notin_contra in
  case (s1,s2) of
  % Axiom cases
  | ([_ ⊢ hyp RMV1 EXH1],[_,x:var ⊢ _]) ⇒
    %{
    Sketch of case:
          exh(Δ₁⧵{Y :¹ A}) 
    s1 = -----------------, s2 arbitrary
             Δ₁ ⇒ A

    - Δ₁⧵{Y :¹ A} ⋈ Δ₂⧵{Y :⁰ A} = Δ⧵{Y :¹ A} by merge_str2
    - Δ₂⧵{Y :⁰ A} = Δ⧵{Y :¹ A} by merge_id
    - Δ₂⧵{Y :⁰ A} = (Δ₂'⧵{Y :⁰ A})⧵{x :¹ A} by rmv_changeorder
      ∴ Δ⧵{Y :¹ A} = (Δ₂'⧵{Y :⁰ A})⧵{x :¹ A} (†)
    - Δ₂'⧵{Y :⁰ A} ⇒ C by seq_str
    - Δ ⇒ C by seq_rename, using (†)
    }%
    let [_ ⊢ mg-str2 RMV2 RMV12 •/a1 MG1 _ _] = merge_str2 [_ ⊢ RMV1] [_ ⊢ MG] in
    let [_ ⊢ cx/refl] = merge_id [_ ⊢ MG1] [_ ⊢ EXH1] in
    let [_,x:var ⊢ rmv-ch RMV2a RMV2b _ _ _ _] = rmv_changeorder [_,x:var ⊢ RMV] [_,x:var ⊢ RMV2[..]] in
    let S3 = seq_str s2 [_,x:var ⊢ RMV2a] WF1 in
    prune_seq (seq_rename S3 [_,x:var ⊢ RMV2b] [_,x:var ⊢ RMV12[..]] (wf_str WF1 [_ ⊢ RMV2a]) (wf_ext wf))
  | ([_ ⊢ _],[_,x:var ⊢ hyp RMV1 EXH1]) ⇒
    %{
    Sketch of case:
          exh(Δ₂'⧵{Y :¹ C}) 
    s2 = -----------------, s1 arbitrary
             Δ₂' ⇒ C

    Subcase: x = Y
    - A = C by str_runq
    - Δ₁ = Δ by merge_id_r
    - Δ ⇒ A by assumption

    Subcase: x ≠ Y
    - (x :¹ A) ∈ Δ₂'⧵{Y :¹ C} by lookup_str
    - ↯ by exh_lookup
    }%
    let [_,x:var ⊢ _]:[_,x:var ⊢ rmv _ e _ _ _ _] = [_,x:var ⊢ RMV1] in
    (case comp_vars [_,x:var ⊢ e] [_,x:var ⊢ x] of
    | Ct-Eq ⇒
      let [_,x:var ⊢ tp-mult-nat-lctx-refl] = str_runq [_,x:var ⊢ RMV1] rm WF1 in
      let [_ ⊢ cx/refl] = merge_id_r mg (prune_exh [_,x:var ⊢ EXH1]) in
      s1
    | Ct-Neq NEQ ⇒
      let [_,x:var ⊢ look RMV2] = lookup_str [_,x:var ⊢ RMV1] rm NEQ in
      impossible exh_lookup [_,x:var ⊢ EXH1] [_,x:var ⊢ RMV2]
    )
  % Commutative cases
  | ([_ ⊢ L-o RMV12 MG1 SQ1 \x.SQ2],[_,x:var ⊢ _]) ⇒
    let [_ ⊢ mg-str2 RMV3 RMV123 •/a1 MG2 _ _] = merge_str2 [_ ⊢ RMV12] [_ ⊢ MG] in
    let [_,x:var ⊢ rmv-ch RMV3a RMV3b _ _ _ _] = rmv_changeorder [_,x:var ⊢ RMV] [_,x:var ⊢ RMV3[..]] in
    let [_ ⊢ merge-assoc MG4 MG5 _ _] = merge_assoc [_ ⊢ MG2] [_ ⊢ MG1] in
    let [_ ⊢ _]:[_ ⊢ rmv _ _ (_ -o B₂[]) _ _ _] = [_ ⊢ RMV12] in
    let [_,x:var,y:var ⊢ SQ3] = seq_weak_cor (seq_str s2 [_ ⊢ RMV3a] WF1) (wf_str WF1 [_ ⊢ RMV3a]) [ ⊢ B₂] in
    let [_,x:var ⊢ SQ4] = cut_admis [_,x:var ⊢ SQ2] [_,x:var,y:var ⊢ SQ3[..,y,x]] [_,x:var,y:var ⊢ rmv/n RMV3b[..,y]]
      [_,x:var ⊢ mg/c MG4[..] •/a1] (wf_extcons (wf_merge_r (wf_str wf [_ ⊢ RMV123]) [_ ⊢ MG5])) in
    [_ ⊢ L-o RMV123 MG5 SQ1 \x.SQ4]
  | ([_ ⊢ _],[_,x:var ⊢ R-o \y.SQ1]) ⇒
    let [_,x:var ⊢ SQ2] = cut_admis (seq_weak_cor s1 (wf_merge wf mg) [ ⊢ _]) [_,y:var,x:var ⊢ SQ1[..,x,y]]
      [_,y:var,x:var ⊢ rmv/n RMV[..,x]] [_,x:var ⊢ mg/c MG[..] •/a2] (wf_extcons wf) in
    [_ ⊢ R-o \x.SQ2]
  % Principal cases
  | ([_ ⊢ _],[_,x:var ⊢ L-o RMV23 MG1 SQ1 \y.SQ2]) ⇒
    let [_,x:var ⊢ _]:[_,x:var ⊢ rmv _ e (B₁[] -o B₂[]) _ _ _] = [_,x:var ⊢ RMV23] in
    (case comp_vars [_,x:var ⊢ x] [_,x:var ⊢ e] of
    | Ct-Eq ⇒
      let [_,x:var ⊢ tp-mult-nat-lctx-refl] = str_runq rm [_,x:var ⊢ RMV23] WF1 in
      let Prune-Merge [_,x:var ⊢ cx/refl] [_ ⊢ cx/refl] [_ ⊢ MG1'] [_ ⊢ _] = prune_merge [_,x:var ⊢ MG1] in
      let [_ ⊢ MG1_comm] = merge_comm [_ ⊢ MG1'] in
      let [_ ⊢ merge-assoc MG2 MG3 _ _] = merge_assoc [_ ⊢ MG_comm] [_ ⊢ MG1_comm] in
      let [_ ⊢ LN1] = len_merge1_l mg (len_merge2_r mg [_ ⊢ LN2]) in
      let [_ ⊢ LN3] = len_merge1_r [_ ⊢ MG1'] [_ ⊢ LN2] in
      let [_ ⊢ R-o \x.SQ3] = s1 in
      let SQ4 = cut_admis (prune_seq [_,x:var ⊢ SQ1]) [_,x:var ⊢ SQ3] [_,x:var ⊢ rmv/t LN1[..]] [_ ⊢ MG2] (wf_merge_r wf [_ ⊢ MG3]) in
      cut_admis SQ4 (prune_seq [_,x:var,y:var ⊢ SQ2[..,y,x]]) [_,x:var ⊢ rmv/t LN3[..]] (merge_comm [_ ⊢ MG3]) wf
    | Ct-Neq NEQ ⇒
      let [_,x:var ⊢ rmv-po RMV23a' RMV23b _ _ _ _] = rmv_pushout [_ ⊢ RMV] [_ ⊢ RMV23] NEQ in
      let Prune-Rmv [_ ⊢ cx/refl] [_,x:var ⊢ tm/refl] [_ ⊢ RMV23a] [_,x:var ⊢ _] = prune_rmv [_ ⊢ RMV23a'] in
      let [_ ⊢ mg-str2 RMV1a RMV123a •/a1 MG2 _ _] = merge_str2 [_ ⊢ RMV23a] [_ ⊢ MG_comm] in
      let [_,x:var ⊢ mg-str RMV2b RMV3b MLT[] MG3' _ _] = merge_str [_ ⊢ RMV23b] [_ ⊢ MG1] in
      let Prune-Merge [_,x:var ⊢ cx/refl] [_ ⊢ cx/refl] [_ ⊢ MG3] [_ ⊢ _] = prune_merge [_,x:var ⊢ MG3'] in
      (case [ ⊢ MLT] of
      | [ ⊢ •/a1] ⇒
        let [_ ⊢ MG3_comm] = merge_comm [_ ⊢ MG3] in
        let [_ ⊢ merge-assoc MG5_comm MG6_comm _ _] = merge_assoc [_ ⊢ MG2] [_ ⊢ MG3_comm] in
        let [_ ⊢ MG5] = merge_comm [_ ⊢ MG5_comm] in
        let [_ ⊢ MG6] = merge_comm [_ ⊢ MG6_comm] in
        let [_,x:var ⊢ SQ2'] = prune_seq (seq_str [_,x:var,y:var ⊢ SQ2[..,y,x]] [_,x:var,y:var ⊢ rmv/n RMV3b[..,y]]
          (wf_swap (wf_extcons (wf_merge_r (wf_str WF1 [_,x:var ⊢ RMV23]) [_ ⊢ MG1])))) in
        let [_ ⊢ SQ3] = cut_admis (seq_str s1 [_ ⊢ RMV1a] (wf_merge wf mg))
          [_,x:var ⊢ SQ1] [_,x:var ⊢ RMV2b] [_ ⊢ MG5] (wf_merge (wf_str wf [_ ⊢ RMV123a]) [_ ⊢ MG6]) in
        [_ ⊢ L-o RMV123a MG6 SQ3 \x.SQ2']
      | [ ⊢ •/a2] ⇒
        let [_ ⊢ merge-assoc MG5_comm MG6 _ _] = merge_assoc [_ ⊢ MG2] [_ ⊢ MG3] in
        let [_ ⊢ MG5] = merge_comm [_ ⊢ MG5_comm] in
        let [_ ⊢ SQ1'] = prune_seq (seq_str [_,x:var ⊢ SQ1] [_,x:var ⊢ RMV2b] (wf_merge (wf_str WF1 [_,x:var ⊢ RMV23]) [_ ⊢ MG1])) in
        let S1' = seq_weak_cor (seq_str s1 [_ ⊢ RMV1a] (wf_merge wf mg)) (wf_merge_r (wf_str wf [_ ⊢ RMV123a]) [_ ⊢ MG2]) [ ⊢ B₂] in
        let [_,x:var ⊢ SQ3] = cut_admis S1' [_,x:var,y:var ⊢ SQ2[..,y,x]] [_,x:var,y:var ⊢ rmv/n RMV3b[..,y]]
          [_,x:var ⊢ mg/c MG5[..] •/a2] (wf_extcons (wf_merge_r (wf_str wf [_ ⊢ RMV123a]) [_ ⊢ MG6])) in
        [_ ⊢ L-o RMV123a MG6 SQ1' \x.SQ3]
      )
    )
  ;

%------------------------------------------------------%
% Substitution properties
%------------------------------------------------------%

rec subst_chk : [Ψ,x:var ⊢ chk Δ₁ e C[]] → [Ψ ⊢ syn Δ₂ s A[]]
→ [Ψ,x:var ⊢ rmv Δ₁ x A[] lin n[] Δ₁'[..]] → [Ψ ⊢ merge Δ₁' Δ₂ Δ]
→ Wf [Ψ ⊢ Δ]
→ [Ψ ⊢ chk Δ e[..,s] C[]] =
  %/ total c (subst_chk _ _ _ _ _ _ _ _ _ c _ _ _ _) /
  fn ch1, sy2, rm, mg, wf ⇒
  let [_ ⊢ SYN2] = sy2 in
  let [_,x:var ⊢ RMV] = rm in
  let [_ ⊢ MG]:[_ ⊢ merge _ Δ' _] = mg in
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ'] in
  let WF1 = wf_weak (wf_ext (wf_merge wf mg)) rm notin_contra in
  case ch1 of
  | [_,x:var ⊢ conv SYN1] ⇒ let [_ ⊢ SYN2] = subst_syn [_,x:var ⊢ SYN1] sy2 rm mg wf in [_ ⊢ conv SYN2]
  | [_,x:var ⊢ I-o \y.CH1']:[_,x:var ⊢ chk _ _ (C[] -o _)] ⇒
    let SYN2_wk = syn_weak [_,x:var ⊢ SYN2[..]] (str_top [_,x:var ⊢ LN[..]] [_,x:var ⊢ x] [ ⊢ C] [ ⊢ used]) (wf_extcons (wf_merge_r wf mg)) in
    let [_,y:var ⊢ CH3] = subst_chk [_,y:var,x:var ⊢ CH1'[..,x,y]] SYN2_wk [_,y:var,x:var ⊢ rmv/n RMV[..,x]] [_,y:var ⊢ mg/c MG[..] •/a1] (wf_extcons wf) in
    [_ ⊢ I-o \x.CH3]

and rec subst_syn : [Ψ,x:var ⊢ syn Δ₁ e C[]] → [Ψ ⊢ syn Δ₂ s A[]]
→ [Ψ,x:var ⊢ rmv Δ₁ x A[] lin n[] Δ₁'[..]] → [Ψ ⊢ merge Δ₁' Δ₂ Δ]
→ Wf [Ψ ⊢ Δ]
→ [Ψ ⊢ syn Δ e[..,s] C[]] =
  %/ total c (subst_syn _ _ _ _ _ _ _ _ _ c _ _ _ _) /
  fn sy1, sy2, rm, mg, wf ⇒
  let ([_,x:var ⊢ RMV],[_ ⊢ MG]) = (rm,mg) in
  let WF1 = wf_weak (wf_ext (wf_merge wf mg)) rm notin_contra in
  case sy1 of
  | [_,x:var ⊢ coe CH1] ⇒ let [_ ⊢ CH2] = subst_chk [_ ⊢ CH1] sy2 rm mg wf in [_ ⊢ coe CH2]
  | [_,x:var ⊢ init RMV1 EXH1]:[_,x:var ⊢ syn _ e _] ⇒
    %{
    Here we have
    RMV1 : [Ψ,x:var ⊢ rmv Δ₁ e C[] lin m[] Δ₁'']
    EXH1 : [Ψ,x:var ⊢ exh Δ₁'']

    It must be the case that e = x; otherwise, (x : A)^1 ∈ Δ₁'' by exh_lookup,
    contradicting the fact that Δ₁'' is exhausted.
    Then by str_runq, C = A and Δ₁'' = Δ₁'

    Since Δ₁' ⋈ Δ₂ = Δ and exh(Δ₁'), it follows from merge_id that Δ₂ = Δ.
    Thus Δ ⊢ s ⟹ A by assumption.
    }%
    (case comp_vars [_,x:var ⊢ e] [_,x:var ⊢ x] of
    | Ct-Eq ⇒
      let [_,x:var ⊢ tp-mult-nat-lctx-refl] = str_runq rm [_,x:var ⊢ RMV1] WF1 in
      let [_ ⊢ cx/refl] = merge_id mg (prune_exh [_,x:var ⊢ EXH1]) in
      sy2
    | Ct-Neq NEQ ⇒
      let [_,x:var ⊢ look RMV2] = lookup_str [_ ⊢ RMV1] rm NEQ in
      impossible exh_lookup [_,x:var ⊢ EXH1] [_,x:var ⊢ RMV2]
    )
  | [_,x:var ⊢ E-o SYN1 CH1 MG1] ⇒
    let [_,x:var ⊢ mg-str RMV1 RMV2 MLT[] MG2' _ _] = merge_str [_,x:var ⊢ RMV] [_,x:var ⊢ MG1] in
    let Prune-Merge [_,x:var ⊢ cx/refl] [_ ⊢ cx/refl] [_ ⊢ MG2] [_ ⊢ _] = prune_merge [_,x:var ⊢ MG2'] in
    (case [ ⊢ MLT] of
    | [ ⊢ •/a1] ⇒
      let [_ ⊢ MG2_comm] = merge_comm [_ ⊢ MG2] in
      let [_ ⊢ merge-assoc MG3 MG4 _ _] = merge_assoc [_ ⊢ MG] [_ ⊢ MG2_comm] in
      let [_ ⊢ MG4_comm] = merge_comm [_ ⊢ MG4] in
      let [_ ⊢ SYN2] = subst_syn [_,x:var ⊢ SYN1] sy2 [_,x:var ⊢ RMV1] [_ ⊢ MG3] (wf_merge_r wf [_ ⊢ MG4]) in
      let [_,x:var ⊢ CH1'] = chk_str [_,x:var ⊢ CH1] [_,x:var ⊢ RMV2] (wf_weak_cor (wf_merge wf [_ ⊢ MG4]) [_,x:var ⊢ RMV2]) in
      let Prune-Chk [_ ⊢ CH1_pr] [_,x:var ⊢ _] = prune_chk [_,x:var ⊢ CH1'] in
      [_ ⊢ E-o SYN2 CH1_pr MG4_comm]
    | [ ⊢ •/a2] ⇒
      let [_ ⊢ merge-assoc MG3 MG4 _ _] = merge_assoc [_ ⊢ MG] [_ ⊢ MG2] in
      let [_,x:var ⊢ SYN1'] = syn_str [_ ⊢ SYN1] [_ ⊢ RMV1] (wf_merge (wf_weak (wf_ext (wf_merge wf mg)) rm notin_contra) [_ ⊢ MG1]) in
      let Prune-Syn [_ ⊢ SYN1_pr] [_,x:var ⊢ _] = prune_syn [_,x:var ⊢ SYN1'] in
      let [_ ⊢ CH2] = subst_chk [_,x:var ⊢ CH1] sy2 [_,x:var ⊢ RMV2] [_ ⊢ MG3] (wf_merge_r wf [_ ⊢ MG4]) in
      [_ ⊢ E-o SYN1_pr CH2 MG4]
    )
  ;

%------------------------------------------------------%
% Translation theorems
%------------------------------------------------------%

% Lemma: If (X : A)^1 ∈ₙ Δ, then Δ' ⊢ X ⟹ A, where
% Δ' ⋈ Δ[X:A^1 ↦ X:A^0] = Δ

LF rmv_syn : rmv _ _ _ _ _ _ → type =
  | rmv-syn :
    syn Δ₁ X A →
    merge Δ₁ Δ₂ Δ → rmv Δ₂ X A used n Δ' →
    {RMV:rmv Δ X A lin n Δ'}
    rmv_syn RMV;

rec rmv_syn_lemma : {RMV:[Ψ ⊢ rmv Δ X A[] lin n[] _]} Wf [Ψ ⊢ Δ] → [Ψ ⊢ rmv_syn RMV] =
  / total /
  mlam RMV ⇒ fn wf ⇒
  let [_ ⊢ _]:[_ ⊢ rmv Δ X A[] lin n[] _] = [_ ⊢ RMV] in
  let [_ ⊢ merge-getid MG1 EXH1] = merge_getid [_ ⊢ Δ] in
  let [_ ⊢ mg-str RMV1a RMV2a MLT1[] MG2 _ _] = merge_str [_ ⊢ RMV] [_ ⊢ MG1] in
  case [ ⊢ MLT1] of
  | [ ⊢ •/a1] ⇒
    let [_ ⊢ tp-mult-nat-lctx-refl] = str_runq [_ ⊢ RMV1a] [_ ⊢ RMV] wf in
    let [_ ⊢ mg-weak RMV1b RMV2b MG3 _ _ _] = merge_weak [_ ⊢ RMV] [_ ⊢ MG2] [ ⊢ •/a2] in
    let [_ ⊢ MG3_comm] = merge_comm [_ ⊢ MG3] in
    let [_ ⊢ EXH2] = exh_str [_ ⊢ EXH1] [_ ⊢ RMV2a] in
    [_ ⊢ rmv-syn (init RMV2b EXH2) MG3_comm RMV1b _]
  | [ ⊢ •/a2] ⇒ impossible exh_lookup [_ ⊢ EXH1] [_ ⊢ RMV2a]
  ;

% From sequent calculus to natural deduction:
% If Δ ⊢ A, then Δ ⊢ e ⟸ A for some e

LF inhabit : lctx → tp → type =
  | inh : chk Δ e A → inhabit Δ A
  ;

rec seq2nd : [Ψ ⊢ seq Δ A] → Wf [Ψ ⊢ Δ] → [Ψ ⊢ inhabit Δ A] =
  / total 1 /
  fn sq, wf ⇒
  let [_ ⊢ _]:[_ ⊢ seq Δ A] = sq in
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ] in
  case sq of
  | [_ ⊢ hyp RMV EXH] ⇒ [_ ⊢ inh (conv (init RMV EXH))]
  | [_ ⊢ R-o \x.Sa] ⇒
    let [_,x:var ⊢ inh CH] = seq2nd [_,x:var ⊢ Sa] (wf_extcons wf) in
    [_ ⊢ inh (I-o \x.CH)]
  | [_ ⊢ L-o RMV1 MG1 SYN1 \x.SYN2] ⇒
    %{
    By assumption we have
    RMV1 : [Ψ ⊢ rmv Δ s (A[] -o B[]) lin n[] Δ']
    MG1  : [Ψ ⊢ merge Δ₁' Δ₂' Δ']
    SYN1 : [Ψ ⊢ seq Δ₁' A[]]
    SYN2 : [Ψ,x:var ⊢ seq (cons Δ₂'[..] x B[] lin) C[]]

    We call rmv_syn_lemma to get that
    SYN3 : [Ψ ⊢ syn Δ₃ s (A[] -o B[])]
    MG2  : [Ψ ⊢ merge Δ₃ Δ₁₂ Δ]
    RMV2 : [Ψ ⊢ rmv Δ₁₂ s (A[] -o B[]) used n[] Δ']

    Using merge_weak, merge_comm, and merge_assoc, we obtain
    RMV3 : [Ψ ⊢ rmv Δ₁ s (A[] -o B[]) used n[] Δ₁']
    RMV4 : [Ψ ⊢ rmv Δ₂ s (A[] -o B[]) used n[] Δ₂']
    MG3  : [Ψ ⊢ merge Δ₁ Δ₂ Δ₁₂]
    MG4  : [Ψ ⊢ merge Δ₁ Δ₃ Δ₁₃]
    MG5  : [Ψ ⊢ merge Δ₂ Δ₁₃ Δ]

    By seq2nd we obtain (for some e₁,e₂)
    CH1' : [Ψ ⊢ chk Δ₁' e₁ A[]]
    CH2' : [Ψ,x:var ⊢ chk (cons Δ₂'[..] x B[] lin) e₂ C[]]
    which we can weaken with chk_weak (using RMV3, RMV4) to get
    CH1  : [Ψ ⊢ chk Δ₁ e₁ A[]]
    CH2  : [Ψ,x:var ⊢ chk (cons Δ₂[..] x B[] lin) e₂ C[]]

    Then by E-o (using SYN3, CH1, and MG4) we have SYN4 : [Ψ ⊢ syn Δ₁₃ (app s e₁) B[]],
    so we can call subst_chk using CH2, SYN3, and MG5 to get CH3 : [Ψ ⊢ chk Δ e₂[.., app s e₁] C[]]
    }%
    let [_ ⊢ rmv-syn SYN3 MG2 RMV2 _] = rmv_syn_lemma [_ ⊢ RMV1] wf in
    let [_ ⊢ mg-weak RMV3 RMV4 MG3 _ _ _] = merge_weak [_ ⊢ RMV2] [_ ⊢ MG1] [ ⊢ •/us] in
    let [_ ⊢ MG2_comm] = merge_comm [_ ⊢ MG2] in
    let [_ ⊢ MG3_comm] = merge_comm [_ ⊢ MG3] in
    let [_ ⊢ merge-assoc MG4_comm MG5 _ _] = merge_assoc [_ ⊢ MG2_comm] [_ ⊢ MG3_comm] in
    let [_ ⊢ MG4] = merge_comm [_ ⊢ MG4_comm] in
    let [_ ⊢ inh CH1'] = seq2nd [_ ⊢ SYN1] (wf_merge (wf_str wf [_ ⊢ RMV1]) [_ ⊢ MG1]) in
    let [_,x:var ⊢ inh CH2'] = seq2nd [_,x:var ⊢ SYN2] (wf_extcons (wf_merge_r (wf_str wf [_ ⊢ RMV1]) [_ ⊢ MG1])) in
    let [_ ⊢ CH1] = chk_weak [_ ⊢ CH1'] [_ ⊢ RMV3] (wf_merge (wf_merge_r wf [_ ⊢ MG2]) [_ ⊢ MG3]) in
    let [_,x:var ⊢ CH2] = chk_weak [_,x:var ⊢ CH2'] [_ ⊢ rmv/n RMV4[..]] (wf_extcons (wf_merge wf [_ ⊢ MG5])) in
    let SYN4 = [_ ⊢ E-o SYN3 CH1 MG4] in
    let [_ ⊢ LN1] = len_merge1_l [_ ⊢ MG5] [_ ⊢ LN] in
    let [_ ⊢ CH3] = subst_chk [_,x:var ⊢ CH2] SYN4 [_,x:var ⊢ rmv/t LN1[..]] [_ ⊢ MG5] wf in
    [_ ⊢ inh CH3]
  ;

% From natural deduction to sequent calculus:
% (i)  If Δ ⊢ e ⟸ C, then Δ ⊢ C
% (ii) If Δ₁ ⊢ s ⟹ A and Δ₂,x:A^1 ⊢ C, then Δ₁ ⋈ Δ₂ ⊢ C

rec chk2seq : [Ψ ⊢ chk Δ e A] → Wf [Ψ ⊢ Δ] → [Ψ ⊢ seq Δ A] =
  / total c (chk2seq c) /
  fn d, wf ⇒
  case d of
  | [_ ⊢ conv SYN1]:[_ ⊢ chk Δ _ _] ⇒
    let [_ ⊢ merge-getid MG_id EXH] = merge_getid [_ ⊢ Δ] in
    let [_ ⊢ _]:[_ ⊢ merge _ Δ' _] = [_ ⊢ MG_id] in
    let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ'] in
    syn2seq [_ ⊢ SYN1] [_,x:var ⊢ hyp (rmv/t LN[..]) EXH[..]] [_ ⊢ MG_id] wf
  | [_ ⊢ I-o \x.CH1] ⇒ let [_,x:var ⊢ SQ1] = chk2seq [_,x:var ⊢ CH1] (wf_extcons wf) in [_ ⊢ R-o \x.SQ1]

and rec syn2seq : [Ψ ⊢ syn Δ₁ s A[]] → [Ψ,x:var ⊢ seq (cons Δ₂[..] x A[] lin) C[]]
→ [Ψ ⊢ merge Δ₁ Δ₂ Δ] → Wf [Ψ ⊢ Δ]
→ [Ψ ⊢ seq Δ C[]] =
  / total s (syn2seq s) /
  fn sn, sq, mg, wf ⇒
  let [_,x:var ⊢ SQ] = sq in
  let [_ ⊢ MG]:[_ ⊢ merge Δ₁ Δ₂ Δ] = mg in
  let [_ ⊢ get-len LN1] = get_len [_ ⊢ Δ₂] in
  case sn of
  | [_ ⊢ coe CH1] ⇒ let [_ ⊢ SQ1] = chk2seq [_ ⊢ CH1] (wf_merge wf mg) in
    cut_admis [_ ⊢ SQ1] sq [_,x:var ⊢ rmv/t LN1[..]] [_ ⊢ MG] wf
  | [_ ⊢ init RMV1 EXH1] ⇒ cut_admis [_ ⊢ hyp RMV1 EXH1] sq [_,x:var ⊢ rmv/t LN1[..]] [_ ⊢ MG] wf
  | [_ ⊢ E-o SYN1 CH MG1] ⇒
    let [_ ⊢ MG1_comm] = merge_comm [_ ⊢ MG1] in
    let [_ ⊢ merge-assoc MG2 MG3 _ _] = merge_assoc [_ ⊢ MG] [_ ⊢ MG1] in
    let [_ ⊢ _]:[_ ⊢ merge _ _ Δ'] = [_ ⊢ MG2] in
    let [_ ⊢ get-len LN2] = get_len [_ ⊢ Δ'] in
    let [_ ⊢ SQ1] = chk2seq [_ ⊢ CH] (wf_merge_r (wf_merge wf mg) [_ ⊢ MG1]) in
    syn2seq [_ ⊢ SYN1] [_,x:var ⊢ L-o (rmv/t LN2[..]) MG2[..] SQ1[..] \y.SQ[..,y]] [_ ⊢ MG3] wf
  ;

% Corollary: If Δ ⊢ s ⟹ A then Δ ⊢ A

rec syn2seq_cor : [Ψ ⊢ syn Δ s A[]] → Wf [Ψ ⊢ Δ] → [Ψ ⊢ seq Δ A[]] =
  / total 1 /
  fn sy1, wf ⇒
  let [_ ⊢ _]:[_ ⊢ syn Δ _ _] = sy1 in
  let [_ ⊢ merge-getid MG EXH] = merge_getid [_ ⊢ Δ] in
  let [_ ⊢ _]:[_ ⊢ merge _ Δ' _] = [_ ⊢ MG] in
  let [_ ⊢ get-len LN] = get_len [_ ⊢ Δ'] in
  syn2seq sy1 [_,x:var ⊢ hyp (rmv/t LN[..]) EXH[..]] [_ ⊢ MG] wf
  ;