%======================================================%
% Theorems
%======================================================%

% Cut elimination for the linear sequent calculus

rec cut_admis : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข seq_cf ฮโ A[]] โ [ฮจ,x:obj โข seq_cf (cons ฮโ[..] x A[] ๐) C[]]
โ [ฮจ โข merge ฮโ ฮโ ฮ] โ [ฮจ โข seq_cf ฮ C[]] =
  % Remark: Beluga's totality checker cannot check coverage in this case
  fn s1, s2, mg โ
  let ([_ โข M1],[_ โข M1_comm]) = (mg,merge_comm mg) in
  let ([_ โข S1],[_,x:obj โข S2]) = (s1,s2) in
  case (s1,s2) of
  % Axiom cases
  | ([_ โข hyp_cf U1 E1],[_,x:obj โข _]) โ
    %{
    Sketch of case:
          exh(ฮโ[Y :ยน A โฆ Y :โฐ A])
    s1 = --------------------------, s2 arbitrary
             ฮโ โ A

    - ฮโ[Y :ยน A โฆ Y :โฐ A] โ ฮโ = ฮ[Y :ยน A โฆ Y :โฐ A] by merge_upd_cor2
      (using upd_func, upd_symm to show that ฮโ[Y :โฐ A โฆ Y :โฐ A] โก ฮโ)
    - ฮ[Y :ยน A โฆ Y :โฐ A] = ฮโ by merge_id, since exh(ฮโ[Y :ยน A โฆ Y :โฐ A])
    - ฮ โ C by seqcf_rename
    }%
    let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_ โข cx/refl] = merge_id [_ โข M2] [_ โข E1] in
    seqcf_rename s2 (upd_symm [_ โข U3])
  | ([_ โข _],[_,x:obj โข hyp_cf U1 E1]) โ
    %{
    Sketch of case:
          exh((ฮโ, x :ยน A)[Y :ยน C โฆ Y :โฐ C])
    s2 = ------------------------------------, s1 arbitrary
             ฮโ โ C

    Subcase: x = Y
    - exh(ฮโ) by definition, so ฮโ = ฮ by merge_id_r
    - ฮ โ A by assumption

    Subcase: x โ Y
    - (x :ยน A) โ ฮโ[Y :ยน A โฆ Y :โฐ A]
    - โฏ by definition of exh
    }%
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข exh/c E2 _] = [_,x:obj โข E1] in
      let [_ โข cx/refl] = merge_id_r mg (prune_exh [_ โข E2]) in
      s1
    | [_,x:obj โข upd/n _] โ
      let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E1] in
      impossible [ โข T]
    )
  % Commutative cases
  | ([_ โข Lโ_cf U1 SQ1],[_,x:obj โข _]) โ
    let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_ โข SQ3] = cut_admis [_ โข SQ1] s2 [_ โข M2] in
    [_ โข Lโ_cf U3 SQ3]
  | ([_ โข Lโ_cf U1 \x.\y.SQ1],[_,x:obj โข _]) โ
    let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_,x:obj,y:obj โข SQ3] = cut_admis [_,x:obj,y:obj โข SQ1]
      (seqcf_exch_top (seqcf_weak (seqcf_exch_top (seqcf_weak [_,x:obj,y:obj,z:obj โข S2[..,z]] [_ โข _] [ โข _])) [_ โข _] [ โข _]))
      [_,x:obj,y:obj โข mg/c (mg/c M2[..] โข/a1) โข/a1] in
    [_ โข Lโ_cf U3 \x.\y.SQ3]
  | ([_ โข L-o_cf U1 M2 SQ1 \x.SQ2],[_,x:obj โข _]) โ
    let [_ โข merge-upd2 U2 U3 โข/a1 M1' _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M1'] [_ โข M2] in
    let [_,x:obj โข SQ3] = cut_admis [_,x:obj โข SQ2] (seqcf_exch_top (seqcf_weak [_,x:obj,y:obj โข S2[..,y]] [_ โข _] [ โข _]))
      [_,x:obj โข mg/c M3[..] โข/a1] in
    [_ โข L-o_cf U3 M4 SQ1 \x.SQ3]
  | ([_ โข L&1_cf U1 \x.SQ1],[_,x:obj โข _]) โ
    let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_,x:obj โข SQ2] = cut_admis [_,x:obj โข SQ1]
      (seqcf_exch_top (seqcf_weak [_,x:obj,y:obj โข S2[..,y]] [_ โข _] [ โข _]))
      [_,x:obj โข mg/c M2[..] โข/a1] in
    [_ โข L&1_cf U3 \x.SQ2]
  | ([_ โข L&2_cf U1 \x.SQ1],[_,x:obj โข _]) โ
    let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_,x:obj โข SQ2] = cut_admis [_,x:obj โข SQ1]
      (seqcf_exch_top (seqcf_weak [_,x:obj,y:obj โข S2[..,y]] [_ โข _] [ โข _]))
      [_,x:obj โข mg/c M2[..] โข/a1] in
    [_ โข L&2_cf U3 \x.SQ2]
  | ([_ โข Lโ_cf U1 (\x.SQ1) (\x.SQ2)],[_,x:obj โข _]) โ
    let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1] [_ โข M1] [ โข โข/us] in
    let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
    let [_,x:obj โข SQ1'] = cut_admis [_,x:obj โข SQ1]
      (seqcf_exch_top (seqcf_weak [_,x:obj,y:obj โข S2[..,y]] [_ โข _] [ โข _]))
      [_,x:obj โข mg/c M2[..] โข/a1] in
    let [_,x:obj โข SQ2'] = cut_admis [_,x:obj โข SQ2]
      (seqcf_exch_top (seqcf_weak [_,x:obj,y:obj โข S2[..,y]] [_ โข _] [ โข _]))
      [_,x:obj โข mg/c M2[..] โข/a1] in
    [_ โข Lโ_cf U3 (\x.SQ1') (\x.SQ2')]
  | ([_ โข _],[_,x:obj โข Rโ_cf E]) โ
      let [_,x:obj โข exh/c _ T[]] = [_,x:obj โข E] in
      impossible [ โข T]
  | ([_ โข _],[_,x:obj โข Rโ_cf SQ1 SQ2 (mg/c M2' MLT[])]) โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M2'] in
    (case [ โข MLT] of
    | [ โข โข/a1] โ
      let [_ โข mg-assoc2 M3 M4 _ _] = merge_assoc_2 [_ โข M1_comm] [_ โข M2] in
      let [_ โข SQ3] = prune_seq_cf (seqcf_str [_,x:obj โข SQ2]) in
      let [_ โข SQ4] = cut_admis s1 [_,x:obj โข SQ1] (merge_comm [_ โข M3]) in
      [_ โข Rโ_cf SQ4 SQ3 M4]
    | [ โข โข/a2] โ
      let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M1_comm] [_ โข M2] in
      let [_ โข SQ3] = prune_seq_cf (seqcf_str [_,x:obj โข SQ1]) in
      let [_ โข SQ4] = cut_admis s1 [_,x:obj โข SQ2] (merge_comm [_ โข M3]) in
      [_ โข Rโ_cf SQ3 SQ4 M4]
    )
  | ([_ โข _],[_,x:obj โข R-o_cf \y.SQ1]) โ
    let [_,x:obj โข SQ2] = cut_admis (seqcf_weak [_,x:obj โข S1[..]] [_ โข _] [ โข _])
      (seqcf_exch_top [_,y:obj,x:obj โข SQ1[..,x,y]]) [_,x:obj โข mg/c M1[..] โข/a2] in
    [_ โข R-o_cf \x.SQ2]
  | ([_ โข _],[_,x:obj โข R&_cf SQ1 SQ2]) โ
    let [_ โข SQ3] = cut_admis s1 [_,x:obj โข SQ1] mg in
    let [_ โข SQ4] = cut_admis s1 [_,x:obj โข SQ2] mg in
    [_ โข R&_cf SQ3 SQ4]
  | ([_ โข _],[_,x:obj โข Rโ1_cf SQ1]) โ
    let [_ โข SQ1'] = cut_admis s1 [_,x:obj โข SQ1] mg in
    [_ โข Rโ1_cf SQ1']
  | ([_ โข _],[_,x:obj โข Rโ2_cf SQ1]) โ
    let [_ โข SQ1'] = cut_admis s1 [_,x:obj โข SQ1] mg in
    [_ โข Rโ2_cf SQ1']
  % Principal cases
  | ([_ โข _],[_,x:obj โข Lโ_cf U1 SQ1]) โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ unit_lemma_cf s1 (prune_seq_cf (seqcf_str [_,x:obj โข SQ1])) mg
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข merge-upd2 U2 U3 โข/a1 M2 _ _ _] = merge_upd_cor2 [_ โข U1''] [_ โข M1_comm] [ โข โข/us] in
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_ โข SQ2] = cut_admis s1 [_,x:obj โข SQ1] (merge_comm [_ โข M2]) in
      [_ โข Lโ_cf U3 SQ2]
    )
  | ([_ โข _],[_,x:obj โข Lโ_cf U1 \y.\z.SQ1]) โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_ โข Rโ_cf SQ2 SQ3 M2] = s1 in % left and hyp rules already covered, others impossible
      let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M1] [_ โข M2] in
      let SQ4' = cut_admis (seqcf_weak [_,x:obj โข SQ3[..]] [_ โข _] [ โข _])
        (prune_seq_cf (seqcf_str (seqcf_exch_top2 [_,x:obj,y:obj,z:obj โข SQ1[..,z,x,y]]))) [_,x:obj โข mg/c M3[..] โข/a2] in
      cut_admis [_ โข SQ2] SQ4' [_ โข M4]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข merge-upd2 U2 U3 โข/a1 M2_comm _ _ _] = merge_upd_cor2 [_ โข U1''] [_ โข M1_comm] [ โข โข/us] in
      let [_ โข M2] = merge_comm [_ โข M2_comm] in
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj,y:obj โข SQ2[..,y,x]] = cut_admis (seqcf_weak (seqcf_weak [_,x:obj,y:obj โข S1[..]] [_ โข _] [ โข _]) [_ โข _] [ โข _])
        (seqcf_exch_top2 [_,x:obj,y:obj,z:obj โข SQ1[..,z,y,x]]) [_ โข mg/c (mg/c M2[..] โข/a2) โข/a2] in
      [_ โข Lโ_cf U3 \x.\y.SQ2]
    )
  | ([_ โข _],[_,x:obj โข L-o_cf U1 M2 SQ1 \y.SQ2]) โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข mg/c M2'' โข/us] = [_,x:obj โข M2] in
      let Prune-Merge [_ โข M2'] [_,x:obj โข _] = prune_merge [_,x:obj โข M2''] in
      let [_ โข mg-assoc2 M3 M4 _ _] = merge_assoc_2 [_ โข M1_comm] [_ โข M2'] in
      let [_ โข R-o_cf \x.SQ3] = s1 in % left and hyp rules already covered, others impossible
      let SQ4 = cut_admis (prune_seq_cf (seqcf_str [_,x:obj โข SQ1])) [_,x:obj โข SQ3] [_ โข M3] in
      cut_admis SQ4 (prune_seq_cf (seqcf_str (seqcf_exch_top [_,x:obj,y:obj โข SQ2[..,y,x]]))) [_ โข M4]
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข merge-upd2 U2 U3 โข/a1 M3 _ _ _] = merge_upd_cor2 [_ โข U1''] [_ โข M1_comm] [ โข โข/us] in
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj โข mg/c M2'' MLT[]] = [_,x:obj โข M2] in
      let Prune-Merge [_ โข M2'] [_,x:obj โข _] = prune_merge [_,x:obj โข M2''] in
      (case [ โข MLT] of
      | [ โข โข/a1] โ
        let [_ โข mg-assoc2 M4 M5 _ _] = merge_assoc_2 [_ โข M3] [_ โข M2'] in
        let [_,x:obj โข SQ2'] = prune_seq_cf (seqcf_str (seqcf_exch_top [_,x:obj,y:obj โข SQ2[..,y,x]])) in
        let [_ โข SQ3] = cut_admis s1 [_,x:obj โข SQ1] (merge_comm [_ โข M4]) in
        [_ โข L-o_cf U3 M5 SQ3 \x.SQ2']
      | [ โข โข/a2] โ
        let [_ โข mg-assoc M4_comm M5 _ _] = merge_assoc [_ โข M3] [_ โข M2'] in
        let [_ โข M4] = merge_comm [_ โข M4_comm] in
        let [_ โข SQ1'] = prune_seq_cf (seqcf_str [_,x:obj โข SQ1]) in
        let [_,x:obj โข SQ3] = cut_admis (seqcf_weak [_,x:obj โข S1[..]] [_ โข _] [ โข _])
          (seqcf_exch_top [_,x:obj,y:obj โข SQ2[..,y,x]]) [_,x:obj โข mg/c M4[..] โข/a2] in
        [_ โข L-o_cf U3 M5 SQ1' \x.SQ3]
      )
    )
  | ([_ โข _],[_,x:obj โข L&1_cf U1 \y.SQ1]) โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_ โข R&_cf SQ2 _] = s1 in % left and hyp rules already covered, others impossible
      cut_admis [_ โข SQ2] (prune_seq_cf (seqcf_str (seqcf_exch_top [_,x:obj,y:obj โข SQ1[..,y,x]]))) mg
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข merge-upd2 U2 U3 โข/a1 M2_comm _ _ _] = merge_upd_cor2 [_ โข U1''] [_ โข M1_comm] [ โข โข/us] in
      let [_ โข M2] = merge_comm [_ โข M2_comm] in
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj โข SQ3] = cut_admis (seqcf_weak [_,x:obj โข S1[..]] [_ โข _] [ โข _])
        (seqcf_exch_top [_,x:obj,y:obj โข SQ1[..,y,x]]) [_,x:obj โข mg/c M2[..] โข/a2] in
      [_ โข L&1_cf U3 \x.SQ3]
    )
  | ([_ โข _],[_,x:obj โข L&2_cf U1 \y.SQ1]) โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_ โข R&_cf _ SQ3] = s1 in % left and hyp rules already covered, others impossible
      cut_admis [_ โข SQ3] (prune_seq_cf (seqcf_str (seqcf_exch_top [_,x:obj,y:obj โข SQ1[..,y,x]]))) mg
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข merge-upd2 U2 U3 โข/a1 M2_comm _ _ _] = merge_upd_cor2 [_ โข U1''] [_ โข M1_comm] [ โข โข/us] in
      let [_ โข M2] = merge_comm [_ โข M2_comm] in
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj โข SQ3] = cut_admis (seqcf_weak [_,x:obj โข S1[..]] [_ โข _] [ โข _])
        (seqcf_exch_top [_,x:obj,y:obj โข SQ1[..,y,x]]) [_,x:obj โข mg/c M2[..] โข/a2] in
      [_ โข L&2_cf U3 \x.SQ3]
    )
  | ([_ โข _],[_,x:obj โข Lโ_cf U1 (\y.SQ1) (\y.SQ2)]) โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      (case s1 of
      | [_ โข Rโ1_cf SQ3] โ cut_admis [_ โข SQ3] (prune_seq_cf (seqcf_str (seqcf_exch_top [_,x:obj,y:obj โข SQ1[..,y,x]]))) mg
      | [_ โข Rโ2_cf SQ3] โ cut_admis [_ โข SQ3] (prune_seq_cf (seqcf_str (seqcf_exch_top [_,x:obj,y:obj โข SQ2[..,y,x]]))) mg
      )
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข merge-upd2 U2 U3 โข/a1 M2_comm _ _ _] = merge_upd_cor2 [_ โข U1''] [_ โข M1_comm] [ โข โข/us] in
      let [_ โข M2] = merge_comm [_ โข M2_comm] in
      let [_ โข cx/refl] = upd_func [_ โข U2] (upd_refl [_ โข U2]) in
      let [_,x:obj โข SQ3] = cut_admis (seqcf_weak [_,x:obj โข S1[..]] [_ โข _] [ โข _])
        (seqcf_exch_top [_,x:obj,y:obj โข SQ1[..,y,x]]) [_,x:obj โข mg/c M2[..] โข/a2] in
      let [_,x:obj โข SQ4] = cut_admis (seqcf_weak [_,x:obj โข S1[..]] [_ โข _] [ โข _])
        (seqcf_exch_top [_,x:obj,y:obj โข SQ2[..,y,x]]) [_,x:obj โข mg/c M2[..] โข/a2] in
      [_ โข Lโ_cf U3 (\x.SQ3) (\x.SQ4)]
    )
  ;

rec cut_elim : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข seq ฮ C] โ [ฮจ โข seq_cf ฮ C] =
  / total 1 /
  fn sq โ case sq of
  | [_ โข hyp U1 E] โ [_ โข hyp_cf U1 E]
  | [_ โข Rโ E] โ [_ โข Rโ_cf E]
  | [_ โข Lโ U1 SQ1] โ let [_ โข SQ1'] = cut_elim [_ โข SQ1] in [_ โข Lโ_cf U1 SQ1']
  | [_ โข Rโ SQ1 SQ2 M1] โ
    let [_ โข SQ1'] = cut_elim [_ โข SQ1] in
    let [_ โข SQ2'] = cut_elim [_ โข SQ2] in
    [_ โข Rโ_cf SQ1' SQ2' M1]
  | [_ โข Lโ U1 \x.\y.SQ1] โ
    let [_,x:obj,y:obj โข SQ1'] = cut_elim [_,x:obj,y:obj โข SQ1] in
    [_ โข Lโ_cf U1 \x.\y.SQ1']
  | [_ โข R-o \x.SQ1] โ
    let [_,x:obj โข SQ1'] = cut_elim [_,x:obj โข SQ1] in
    [_ โข R-o_cf \x.SQ1']
  | [_ โข L-o U1 M1 SQ1 \x.SQ2] โ
    let [_ โข SQ1'] = cut_elim [_ โข SQ1] in
    let [_,x:obj โข SQ2'] = cut_elim [_,x:obj โข SQ2] in
    [_ โข L-o_cf U1 M1 SQ1' \x.SQ2']
  | [_ โข R& SQ1 SQ2] โ
    let [_ โข SQ1'] = cut_elim [_ โข SQ1] in
    let [_ โข SQ2'] = cut_elim [_ โข SQ2] in
    [_ โข R&_cf SQ1' SQ2']
  | [_ โข L&1 U1 \x.SQ1] โ
    let [_,x:obj โข SQ1'] = cut_elim [_,x:obj โข SQ1] in
    [_ โข L&1_cf U1 \x.SQ1']
  | [_ โข L&2 U1 \x.SQ1] โ
    let [_,x:obj โข SQ1'] = cut_elim [_,x:obj โข SQ1] in
    [_ โข L&2_cf U1 \x.SQ1']
  | [_ โข Rโ1 SQ1] โ let [_ โข SQ1'] = cut_elim [_ โข SQ1] in [_ โข Rโ1_cf SQ1']
  | [_ โข Rโ2 SQ1] โ let [_ โข SQ1'] = cut_elim [_ โข SQ1] in [_ โข Rโ2_cf SQ1']
  | [_ โข Lโ U1 (\x.SQ1) (\x.SQ2)] โ
    let [_,x:obj โข SQ1'] = cut_elim [_,x:obj โข SQ1] in
    let [_,x:obj โข SQ2'] = cut_elim [_,x:obj โข SQ2] in
    [_ โข Lโ_cf U1 (\x.SQ1') (\x.SQ2')]
  | [_ โข cut M1 SQ1 \x.SQ2] โ cut_admis (cut_elim [_ โข SQ1]) (cut_elim [_,x:obj โข SQ2]) [_ โข M1]
  ;

% Equivalence of linear sequent calculus and natural deduction calculus
% (1) If ฮ โข A and ฮ โข ฯ : ฮ, then ฮ โข e โธ A for some e
% (2) If ฮ โข e โธ C, then ฮ โข C
% (3) If ฮโ โข s โน A, (ฮโ, x :ยน A) โข C, and ฮโ โ ฮโ = ฮ, then ฮ โข C

LF inhabit : lctx _ โ tp โ type =
| inh : chk ฮ _ C โ inhabit ฮ C;

rec seq2nd : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) (ฮ:[ฮจ โข lctx M[]])
[ฮจ โข seq ฮ C] โ [ฮจ โข wf_subst ฮ ฯ ฮ] โ [ฮจ โข inhabit ฮ C] =
  / total 1 /
  fn sq, sub โ
  let [_ โข SUB] = sub in
  case sq of
  | [_ โข hyp U1 E1] โ
    let [_ โข sub-up SUB1 CH1 M1 _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_ โข cx/refl] = merge_id [_ โข M1] (subst_exh [_ โข SUB1] [_ โข E1]) in
    [_ โข inh CH1]
  | [_ โข Rโ E1] โ
    let [_ โข E2] = subst_exh sub [_ โข E1] in
    [_ โข inh (Iโ E2)]
  | [_ โข Lโ U1 SQ1] โ
    let [_ โข sub-up SUB1 CH1 M1 _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_ โข M1_comm] = merge_comm [_ โข M1] in
    let [_ โข inh CH2] = seq2nd [_ โข SQ1] [_ โข SUB1] in
    [_ โข inh (Eโ (coe CH1) CH2 M1_comm)]
  | [_ โข Rโ SY1 SY2 M1] โ
    let [_ โข sub-mg SUB1 SUB2 M2 _ _] = subst_merge [_ โข SUB] [_ โข M1] in
    let [_ โข inh CH1] = seq2nd [_ โข SY1] [_ โข SUB1] in
    let [_ โข inh CH2] = seq2nd [_ โข SY2] [_ โข SUB2] in
    [_ โข inh (Iโ CH1 CH2 M2)]
  | [_ โข Lโ U1 \x.\y.SQ1] โ
    let [_ โข sub-up SUB1 CH1 M1 _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_ โข M1_comm] = merge_comm [_ โข M1] in
    let [_,x:obj,y:obj โข inh CH2] = seq2nd [_,x:obj,y:obj โข SQ1]
      (subst_extend (subst_extend [_,x:obj,y:obj โข SUB1[..]] [_,x:obj,y:obj โข x] [ โข _] [ โข _])  [_,x:obj,y:obj โข y] [ โข _] [ โข _]) in
    [_ โข inh (Eโ (coe CH1) (\x.\y.CH2) M1_comm)]
  | [_ โข R-o \x.SQ1] โ
    let [_,x:obj โข inh CH] = seq2nd [_,x:obj โข SQ1] (subst_extend [_,x:obj โข SUB[..]] [_,x:obj โข x] [ โข _] [ โข _]) in
    [_ โข inh (I-o \x.CH)]
  | [_ โข L-o U1 M1 SQ1 \x.SQ2] โ
    let [_ โข sub-up SUB1 CH_AB Ma _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_ โข sub-mg SUB2 SUB3 Mb _ _] = subst_merge [_ โข SUB1] [_ โข M1] in
    let [_ โข Mb_comm] = merge_comm [_ โข Mb] in
    let [_ โข mg-assoc Mc_comm Md _ _] = merge_assoc [_ โข Ma] [_ โข Mb_comm] in
    let [_ โข Mc] = merge_comm [_ โข Mc_comm] in
    let [_ โข inh CH_A] = seq2nd [_ โข SQ1] [_ โข SUB2] in
    let [_,x:obj โข inh CH_C'] = seq2nd [_,x:obj โข SQ2] [_,x:obj โข wf_subst_cons1 SUB3[..] (conv (E-o (coe CH_AB[..]) CH_A[..] Mc[..])) Md[..]] in
    let Prune-Chk [_ โข CH_C] [_,x:obj โข _] = prune_chk [_,x:obj โข CH_C'] in
    [_ โข inh CH_C]
  | [_ โข R& SQ1 SQ2] โ
    let [_ โข inh CH1] = seq2nd [_ โข SQ1] sub in
    let [_ โข inh CH2] = seq2nd [_ โข SQ2] sub in
    [_ โข inh (I& CH1 CH2)]
  | [_ โข L&1 U1 \x.SQ1] โ
    let [_ โข sub-up SUB1 CH1 M1 _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_,x:obj โข inh CH2] = seq2nd [_,x:obj โข SQ1] (subst_extend [_,x:obj โข SUB1[..]] [_,x:obj โข x] [ โข _] [ โข _]) in
    let [_ โข CH3] = subst_chk [_ โข CH2] [_ โข E&1 (coe CH1)] [_ โข M1] in
    [_ โข inh CH3]
  | [_ โข L&2 U1 \x.SQ1] โ
    let [_ โข sub-up SUB1 CH1 M1 _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_,x:obj โข inh CH2] = seq2nd [_,x:obj โข SQ1] (subst_extend [_,x:obj โข SUB1[..]] [_,x:obj โข x] [ โข _] [ โข _]) in
    let [_ โข CH3] = subst_chk [_ โข CH2] [_ โข E&2 (coe CH1)] [_ โข M1] in
    [_ โข inh CH3]
  | [_ โข Rโ1 SQ1] โ
    let [_ โข inh CH] = seq2nd [_ โข SQ1] sub in
    [_ โข inh (Iโ1 CH)]
  | [_ โข Rโ2 SQ1] โ
    let [_ โข inh CH] = seq2nd [_ โข SQ1] sub in
    [_ โข inh (Iโ2 CH)]
  | [_ โข Lโ U1 (\x.SQ1) (\x.SQ2)] โ
    let [_ โข sub-up SUB1 CH1 M1 _ _] = subst_upd [_ โข SUB] [_ โข U1] in
    let [_ โข M1_comm] = merge_comm [_ โข M1] in
    let [_,x:obj โข inh CH2] = seq2nd [_,x:obj โข SQ1] (subst_extend [_,x:obj โข SUB1[..]] [_,x:obj โข x] [ โข _] [ โข _]) in
    let [_,x:obj โข inh CH3] = seq2nd [_,x:obj โข SQ2] (subst_extend [_,x:obj โข SUB1[..]] [_,x:obj โข x] [ โข _] [ โข _]) in
    [_ โข inh (Eโ (coe CH1) (\x.CH2) (\x.CH3) M1_comm)]
  | [_ โข cut M1 SQ1 \x.SQ2] โ
    let [_ โข sub-mg SUB1 SUB2 M2 _ _] = subst_merge [_ โข SUB] [_ โข M1] in
    let [_ โข inh CH1] = seq2nd [_ โข SQ1] [_ โข SUB1] in
    let [_,x:obj โข inh CH2] = seq2nd [_,x:obj โข SQ2] (subst_extend [_,x:obj โข SUB2[..]] [_,x:obj โข x] [ โข _] [ โข _]) in
    let [_ โข CH3] = subst_chk [_,x:obj โข CH2] [_ โข coe CH1] (merge_comm [_ โข M2]) in
    [_ โข inh CH3]
  ;

rec chk2seq : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข chk ฮ e A] โ [ฮจ โข seq ฮ A] =
  / total c (chk2seq c) /
  fn d โ case d of
  | [_ โข conv SY1]:[_ โข chk ฮ _ C[]] โ
    let [_ โข merge-getid M_id E] = merge_getid [_ โข ฮ] in
    let [_ โข _]:[_ โข merge _ ฮ' _] = [_ โข M_id] in
    let [_,x:obj โข U] = upd_top [_,x:obj โข ฮ'[..]] [_,x:obj โข x] [_,x:obj โข x] [ โข C] [ โข C] [ โข ๐] [ โข ๐] in
    syn2seq [_ โข SY1] [_,x:obj โข hyp U (exh/c E[..] unr/0)] [_ โข M_id]
  | [_ โข Iโ E] โ [_ โข Rโ E]
  | [_ โข Eโ SY1 CH1 M] โ
    let [_ โข SQ1]:[_ โข seq ฮ' _] = chk2seq [_ โข CH1] in
    let [_,x:obj โข SQ1'] = seq_weak [_,x:obj โข SQ1[..]] [_,x:obj โข x] [ โข โ] in
    let [_,x:obj โข U] = upd_top [_,x:obj โข ฮ'[..]] [_,x:obj โข x] [_,x:obj โข x] [ โข โ] [ โข โ] [ โข ๐] [ โข ๐] in
    syn2seq [_ โข SY1] [_,x:obj โข Lโ U SQ1'] [_ โข M]
  | [_ โข Iโ CH1 CH2 M] โ
    let [_ โข S1] = chk2seq [_ โข CH1] in
    let [_ โข S2] = chk2seq [_ โข CH2] in
    [_ โข Rโ S1 S2 M]
  | [_ โข Eโ SY1 (\x.\y.CH1) M] โ
    let [_,x:obj,y:obj โข SQ1]:[_,x:obj,y:obj โข seq (cons (cons ฮโ[..] _ B1[] _) _ B2[] _) _] = chk2seq [_,x:obj,y:obj โข CH1] in
    let [_,x:obj,y:obj,z:obj โข SQ1'[..,y,x,z]] = seq_exch_top3 (seq_weak [_,x:obj,y:obj,z:obj โข SQ1[..,x,z]] [_,x:obj,y:obj,z:obj โข y] [ โข B1 โ B2]) in
    let [_,x:obj โข U] = upd_top [_,x:obj โข ฮโ[..]] [_,x:obj โข x] [_,x:obj โข x] [ โข B1 โ B2] [ โข B1 โ B2] [ โข ๐] [ โข ๐] in
    syn2seq [_ โข SY1] [_,x:obj โข Lโ U \y.\z.SQ1'] [_ โข M]
  | [_ โข I-o \x.CH1] โ let [_,x:obj โข SQ1] = chk2seq [_,x:obj โข CH1] in [_ โข R-o \x.SQ1]
  | [_ โข I& CH1 CH2] โ
    let [_ โข SQ1] = chk2seq [_ โข CH1] in
    let [_ โข SQ2] = chk2seq [_ โข CH2] in
    [_ โข R& SQ1 SQ2]
  | [_ โข Iโ1 CH] โ let [_ โข SQ] = chk2seq [_ โข CH] in [_ โข Rโ1 SQ]
  | [_ โข Iโ2 CH] โ let [_ โข S1] = chk2seq [_ โข CH] in [_ โข Rโ2 S1]
  | [_ โข Eโ SY1 (\x.CH1) (\x.CH2) M] โ
    let [_,x:obj โข SQ1]:[_,x:obj โข seq (cons _ _ B1[] _) _] = chk2seq [_,x:obj โข CH1] in
    let [_,x:obj โข SQ2]:[_,x:obj โข seq (cons _ _ B2[] _) _] = chk2seq [_,x:obj โข CH2] in
    let [_,x:obj,y:obj โข SQ1'] = seq_exch_top (seq_weak [_,x:obj,y:obj โข SQ1[..,y]] [_,x:obj,y:obj โข x] [ โข B1 โ B2]) in
    let [_,x:obj,y:obj โข SQ2'] = seq_exch_top (seq_weak [_,x:obj,y:obj โข SQ2[..,y]] [_,x:obj,y:obj โข x] [ โข B1 โ B2]) in
    syn2seq [_ โข SY1] [_,x:obj โข Lโ (upd/t _) (\y.SQ1') (\y.SQ2')] [_ โข M]

and rec syn2seq : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]])
[ฮจ โข syn ฮโ s A[]] โ [ฮจ,x:obj โข seq (cons ฮโ[..] x A[] ๐) C[]] โ [ฮจ โข merge ฮโ ฮโ ฮ]
โ [ฮจ โข seq ฮ C[]] =
  / total s (syn2seq s) /
  fn sn, sq, mg โ
  let [_,x:obj โข SQ] = sq in
  let [_ โข M] = mg in
  case sn of
  | [_ โข coe CH1] โ let [_ โข SQ1] = chk2seq [_ โข CH1] in [_ โข cut M SQ1 \x.SQ]
  | [_ โข init RMV1 E1] โ [_ โข cut M (hyp RMV1 E1) \x.SQ]
  | [_ โข E-o SY1 CH M1] โ
    let [_ โข M1_comm] = merge_comm [_ โข M1] in
    let [_ โข mg-assoc M2 M3 _ _] = merge_assoc [_ โข M] [_ โข M1] in
    let [_ โข SQ1] = chk2seq [_ โข CH] in
    let [_ โข _]:[_ โข syn _ _ (B1[] -o B2[])] = [_ โข SY1] in
    let [_,x:obj โข SQ1'] = seq_weak [_,x:obj โข SQ1[..]] [_,x:obj โข x] [ โข B1 -o B2] in
    let [_,x:obj,y:obj โข SQ'] = seq_exch_top (seq_weak [_,x:obj,y:obj โข SQ[..,y]] [_,x:obj,y:obj โข x] [ โข B1 -o B2]) in
    syn2seq [_ โข SY1] [_,x:obj โข L-o (upd/t _) (mg/c M2[..] โข/us) SQ1' \y.SQ'] [_ โข M3]
  | [_ โข E&1 SY1] โ
    let [_ โข _]:[_ โข syn _ _ (B1[] & B2[])] = [_ โข SY1] in
    let [_,x:obj,y:obj โข SQ'] = seq_exch_top (seq_weak [_,x:obj,y:obj โข SQ[..,y]] [_,x:obj,y:obj โข x] [ โข B1 & B2]) in
    syn2seq [_ โข SY1] [_,x:obj โข L&1 (upd/t _) \y.SQ'] mg
  | [_ โข E&2 SY1] โ
    let [_ โข _]:[_ โข syn _ _ (B1[] & B2[])] = [_ โข SY1] in
    let [_,x:obj,y:obj โข SQ'] = seq_exch_top (seq_weak [_,x:obj,y:obj โข SQ[..,y]] [_,x:obj,y:obj โข x] [ โข B1 & B2]) in
    syn2seq [_ โข SY1] [_,x:obj โข L&2 (upd/t _) \y.SQ'] mg
  ;